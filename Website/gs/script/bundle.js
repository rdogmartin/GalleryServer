/*! jsviews.js v0.9.81 (Beta) single-file version: http://jsviews.com/ */
/*! includes JsRender, JsObservable and JsViews - see: http://jsviews.com/#download */

/* Interactive data-driven views using JsRender templates */

//<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< JsRender >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
/* JsRender:
 * See http://jsviews.com/#jsrender and http://github.com/BorisMoore/jsrender
 * Copyright 2016, Boris Moore
 * Released under the MIT License.
 */

//jshint -W018, -W041

(function (factory, global) {
    // global var is the this object, which is window when running in the usual browser environment
    var $ = global.jQuery;

    if (typeof exports === "object") { // CommonJS e.g. Browserify
        module.exports = $
			? factory(global, $)
			: function ($) { // If no global jQuery, take jQuery passed as parameter: require("jsviews")(jQuery)
			    return factory(global, $);
			};
    } else if (typeof define === "function" && define.amd) { // AMD script loader, e.g. RequireJS
        define(["jquery"], function ($) {
            return factory(global, $);
        }); // Require jQuery
    } else { // Browser using plain <script> tag
        factory(global, false);
    }
}(

// factory (for jsviews.js)
function (global, $) {
    "use strict";

    //========================== Top-level vars ==========================

    // global var is the this object, which is window when running in the usual browser environment
    var setGlobals = $ === false; // Only set globals if script block in browser (not AMD and not CommonJS)

    $ = $ || global.jQuery; // $ is jQuery passed in by CommonJS loader (Browserify), or global jQuery.

    if (!$ || !$.fn) {
        // jQuery is not loaded.
        throw "JsViews requires jQuery"; // We require jQuery
    }

    var versionNumber = "v0.9.81",

        jsvStoreName, rTag, rTmplString, topView, $views, $observe, $observable, $expando,

    //TODO	tmplFnsCache = {},
        $isFunction, $isArray, $templates, $converters, $helpers, $tags, $sub, $subSettings, $subSettingsAdvanced, $viewsSettings, delimOpenChar0, delimOpenChar1, delimCloseChar0, delimCloseChar1, linkChar, setting, baseOnError,

        rPath = /^(!*?)(?:null|true|false|\d[\d.]*|([\w$]+|\.|~([\w$]+)|#(view|([\w$]+))?)([\w$.^]*?)(?:[.[^]([\w$]+)\]?)?)$/g,
        //        not                               object     helper    view  viewProperty pathTokens      leafToken

        rParams = /(\()(?=\s*\()|(?:([([])\s*)?(?:(\^?)(!*?[#~]?[\w$.^]+)?\s*((\+\+|--)|\+|-|&&|\|\||===|!==|==|!=|<=|>=|[<>%*:?\/]|(=))\s*|(!*?[#~]?[\w$.^]+)([([])?)|(,\s*)|(\(?)\\?(?:(')|("))|(?:\s*(([)\]])(?=\s*[.^]|\s*$|[^([])|[)\]])([([]?))|(\s+)/g,
        //          lftPrn0        lftPrn        bound            path    operator err                                                eq             path2       prn    comma   lftPrn2   apos quot      rtPrn rtPrnDot                           prn2  space
        // (left paren? followed by (path? followed by operator) or (path followed by left paren?)) or comma or apos or quot or right paren or space

        isRenderCall,
        rNewLine = /[ \t]*(\r\n|\n|\r)/g,
        rUnescapeQuotes = /\\(['"])/g,
        rEscapeQuotes = /['"\\]/g, // Escape quotes and \ character
        rBuildHash = /(?:\x08|^)(onerror:)?(?:(~?)(([\w$_\.]+):)?([^\x08]+))\x08(,)?([^\x08]+)/gi,
        rTestElseIf = /^if\s/,
        rFirstElem = /<(\w+)[>\s]/,
        rAttrEncode = /[\x00`><"'&=]/g, // Includes > encoding since rConvertMarkers in JsViews does not skip > characters in attribute strings
        rIsHtml = /[\x00`><\"'&=]/,
        rHasHandlers = /^on[A-Z]|^convert(Back)?$/,
        rWrappedInViewMarker = /^\#\d+_`[\s\S]*\/\d+_`$/,
        rHtmlEncode = rAttrEncode,
        viewId = 0,
        charEntities = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            "\x00": "&#0;",
            "'": "&#39;",
            '"': "&#34;",
            "`": "&#96;",
            "=": "&#61;"
        },
        HTML = "html",
        OBJECT = "object",
        tmplAttr = "data-jsv-tmpl",
        jsvTmpl = "jsvTmpl",
        indexStr = "For #index in nested block use #getIndex().",
        $render = {},

        jsr = global.jsrender,
        jsrToJq = jsr && $ && !$.render, // JsRender already loaded, without jQuery. but we will re-load it now to attach to jQuery

        jsvStores = {
            template: {
                compile: compileTmpl
            },
            tag: {
                compile: compileTag
            },
            viewModel: {
                compile: compileViewModel
            },
            helper: {},
            converter: {}
        };

    // views object ($.views if jQuery is loaded, jsrender.views if no jQuery, e.g. in Node.js)
    $views = {
        jsviews: versionNumber,
        sub: {
            // subscription, e.g. JsViews integration
            View: View,
            Err: JsViewsError,
            tmplFn: tmplFn,
            parse: parseParams,
            extend: $extend,
            extendCtx: extendCtx,
            syntaxErr: syntaxError,
            onStore: {},
            addSetting: addSetting,
            settings: {
                allowCode: false
            },
            advSet: noop, // Update advanced settings
            _ths: tagHandlersFromProps,
            _tg: function () { }, // Constructor for tagDef
            _cnvt: convertVal,
            _tag: renderTag,
            _er: error,
            _err: onRenderError,
            _html: htmlEncode,
            _cp: retVal, // Get compiled contextual parameters (or properties) ~foo=expr. In JsRender, simply returns val.
            _sq: function (token) {
                if (token === "constructor") {
                    syntaxError("");
                }
                return token;
            }
        },
        settings: {
            delimiters: $viewsDelimiters,
            advanced: function (value) {
                return value
					? (
							$extend($subSettingsAdvanced, value),
							$sub.advSet(),
							$viewsSettings
						)
						: $subSettingsAdvanced;
            }
        },
        getCtx: retVal, // Get ctx.foo value. In JsRender, simply returns val.
        map: dataMap    // If jsObservable loaded first, use that definition of dataMap
    };

    function getDerivedMethod(baseMethod, method) {
        return function () {
            var ret,
                tag = this,
                prevBase = tag.base;

            tag.base = baseMethod; // Within method call, calling this.base will call the base method
            ret = method.apply(tag, arguments); // Call the method
            tag.base = prevBase; // Replace this.base to be the base method of the previous call, for chained calls
            return ret;
        };
    }

    function getMethod(baseMethod, method) {
        // For derived methods (or handlers declared declaratively as in {{:foo onChange=~fooChanged}} replace by a derived method, to allow using this.base(...)
        // or this.baseApply(arguments) to call the base implementation. (Equivalent to this._super(...) and this._superApply(arguments) in jQuery UI)
        if ($isFunction(method)) {
            method = getDerivedMethod(
                    !baseMethod
                        ? noop // no base method implementation, so use noop as base method
                        : baseMethod._d
                            ? baseMethod // baseMethod is a derived method, so us it
                            : getDerivedMethod(noop, baseMethod), // baseMethod is not derived so make its base method be the noop method
                    method
                );
            method._d = 1; // Add flag that this is a derived method
        }
        return method;
    }

    function tagHandlersFromProps(tag, tagCtx) {
        for (var prop in tagCtx.props) {
            if (rHasHandlers.test(prop)) {
                tag[prop] = getMethod(tag[prop], tagCtx.props[prop]);
                // Copy over the onFoo props, convert and convertBack from tagCtx.props to tag (overrides values in tagDef).
                // Note: unsupported scenario: if handlers are dynamically added ^onFoo=expression this will work, but dynamically removing will not work.
            }
        }
    }

    function retVal(val) {
        return val;
    }

    function noop() {
        return "";
    }

    function dbgBreak(val) {
        // Usage examples: {{dbg:...}}, {{:~dbg(...)}}, {{dbg .../}}, {^{for ... onAfterLink=~dbg}} etc.
        try {
            console.log("JsRender dbg breakpoint: " + val);
            throw "dbg breakpoint"; // To break here, stop on caught exceptions.
        }
        catch (e) { }
        return this.base ? this.baseApply(arguments) : val;
    }

    function JsViewsError(message) {
        // Error exception type for JsViews/JsRender
        // Override of $.views.sub.Error is possible
        this.name = ($.link ? "JsViews" : "JsRender") + " Error";
        this.message = message || this.name;
    }

    function $extend(target, source) {
        for (var name in source) {
            target[name] = source[name];
        }
        return target;
    }

    (JsViewsError.prototype = new Error()).constructor = JsViewsError;

    //========================== Top-level functions ==========================

    //===================
    // views.delimiters
    //===================

    function $viewsDelimiters(openChars, closeChars, link) {
        // Set the tag opening and closing delimiters and 'link' character. Default is "{{", "}}" and "^"
        // openChars, closeChars: opening and closing strings, each with two characters
        if (!openChars) {
            return $subSettings.delimiters;
        }
        if ($isArray(openChars)) {
            return $viewsDelimiters.apply($views, openChars);
        }

        $subSettings.delimiters = [openChars, closeChars, linkChar = link ? link.charAt(0) : linkChar];

        delimOpenChar0 = openChars.charAt(0); // Escape the characters - since they could be regex special characters
        delimOpenChar1 = openChars.charAt(1);
        delimCloseChar0 = closeChars.charAt(0);
        delimCloseChar1 = closeChars.charAt(1);
        openChars = "\\" + delimOpenChar0 + "(\\" + linkChar + ")?\\" + delimOpenChar1; // Default is "{^{"
        closeChars = "\\" + delimCloseChar0 + "\\" + delimCloseChar1;                   // Default is "}}"
        // Build regex with new delimiters
        //          [tag    (followed by / space or })  or cvtr+colon or html or code] followed by space+params then convertBack?
        rTag = "(?:(\\w+(?=[\\/\\s\\" + delimCloseChar0 + "]))|(\\w+)?(:)|(>)|(\\*))\\s*((?:[^\\"
            + delimCloseChar0 + "]|\\" + delimCloseChar0 + "(?!\\" + delimCloseChar1 + "))*?)";

        // Make rTag available to JsViews (or other components) for parsing binding expressions
        $sub.rTag = "(?:" + rTag + ")";
        //                        { ^? {   tag+params slash?  or closingTag                                                   or comment
        rTag = new RegExp("(?:" + openChars + rTag + "(\\/)?|\\" + delimOpenChar0 + "(\\" + linkChar + ")?\\" + delimOpenChar1 + "(?:(?:\\/(\\w+))\\s*|!--[\\s\\S]*?--))" + closeChars, "g");

        // Default:  bind     tagName         cvt   cln html code    params            slash   bind2         closeBlk  comment
        //      /(?:{(\^)?{(?:(\w+(?=[\/\s}]))|(\w+)?(:)|(>)|(\*))\s*((?:[^}]|}(?!}))*?)(\/)?|{(\^)?{(?:(?:\/(\w+))\s*|!--[\s\S]*?--))}}

        $sub.rTmpl = new RegExp("<.*>|([^\\\\]|^)[{}]|" + openChars + ".*" + closeChars);
        // $sub.rTmpl looks for html tags or { or } char not preceded by \\, or JsRender tags {{xxx}}. Each of these strings are considered
        // NOT to be jQuery selectors
        return $viewsSettings;
    }

    //=========
    // View.get
    //=========

    function getView(inner, type) { //view.get(inner, type)
        if (!type && inner !== true) {
            // view.get(type)
            type = inner;
            inner = undefined;
        }

        var views, i, l, found,
            view = this,
            root = !type || type === "root";
        // If type is undefined, returns root view (view under top view).

        if (inner) {
            // Go through views - this one, and all nested ones, depth-first - and return first one with given type.
            // If type is undefined, i.e. view.get(true), return first child view.
            found = type && view.type === type && view;
            if (!found) {
                views = view.views;
                if (view._.useKey) {
                    for (i in views) {
                        if (found = type ? views[i].get(inner, type) : views[i]) {
                            break;
                        }
                    }
                } else {
                    for (i = 0, l = views.length; !found && i < l; i++) {
                        found = type ? views[i].get(inner, type) : views[i];
                    }
                }
            }
        } else if (root) {
            // Find root view. (view whose parent is top view)
            while (view.parent) {
                found = view;
                view = view.parent;
            }
        } else {
            while (view && !found) {
                // Go through views - this one, and all parent ones - and return first one with given type.
                found = view.type === type ? view : undefined;
                view = view.parent;
            }
        }
        return found;
    }

    function getNestedIndex() {
        var view = this.get("item");
        return view ? view.index : undefined;
    }

    getNestedIndex.depends = function () {
        return [this.get("item"), "index"];
    };

    function getIndex() {
        return this.index;
    }

    getIndex.depends = "index";

    //==========
    // View.hlp
    //==========

    function getHelper(helper, isContextCb) {
        // Helper method called as view.hlp(key) from compiled template, for helpers or template parameters ~foo
        var wrapped, deps,
        view = this,
        res = view.ctx;

        if (res) {
            res = res[helper];
        }
        if (res === undefined) {
            res = $helpers[helper];
        }
        if (res && res._cp) { // If this helper resource is a contextual parameter, ~foo=expr
            if (isContextCb) { // In a context callback for a contextual param, return the [currentData, dependencies...] array - needed for observe call
                deps = $sub._ceo(res[1].deps);  // fn deps, with any exprObs cloned
                deps.unshift(res[0].data);      // view.data
                deps._cp = true;
                return deps;
            }
            res = $views.getCtx(res); // If a contextual param, but not a context callback, return evaluated param - fn(data, view, j)
        }

        if (res) {
            if ($isFunction(res) && !res._wrp) {
                // If it is of type function, and not already wrapped, we will wrap it, so if called with no this pointer it will be called with the
                // view as 'this' context. If the helper ~foo() was in a data-link expression, the view will have a 'temporary' linkCtx property too.
                // Note that helper functions on deeper paths will have specific this pointers, from the preceding path.
                // For example, ~util.foo() will have the ~util object as 'this' pointer
                wrapped = function () {
                    return res.apply((!this || this === global) ? view : this, arguments);
                };
                wrapped._wrp = view;
                $extend(wrapped, res); // Attach same expandos (if any) to the wrapped function
            }
        }
        return wrapped || res;
    }

    function getTemplate(tmpl) {
        return tmpl && (tmpl.fn
            ? tmpl
            : this.getRsc("templates", tmpl) || $templates(tmpl)); // not yet compiled
    }

    //==============
    // views._cnvt
    //==============

    function convertVal(converter, view, tagCtx, onError) {
        // self is template object or linkCtx object
        var tag, value,
            // if tagCtx is an integer, then it is the key for the compiled function to return the boundTag tagCtx
            boundTag = typeof tagCtx === "number" && view.tmpl.bnds[tagCtx - 1],
            linkCtx = view.linkCtx; // For data-link="{cvt:...}"...

        if (onError !== undefined) {
            tagCtx = onError = { props: {}, args: [onError] };
        } else if (boundTag) {
            tagCtx = boundTag(view.data, view, $sub);
        }

        value = tagCtx.args[0];
        if (converter || boundTag) {
            tag = linkCtx && linkCtx.tag;
            if (!tag) {
                tag = $extend(new $sub._tg(), {
                    _: {
                        inline: !linkCtx,
                        bnd: boundTag,
                        unlinked: true
                    },
                    tagName: ":",
                    cvt: converter,
                    flow: true,
                    tagCtx: tagCtx
                });
                if (linkCtx) {
                    linkCtx.tag = tag;
                    tag.linkCtx = linkCtx;
                }
                tagCtx.ctx = extendCtx(tagCtx.ctx, (linkCtx ? linkCtx.view : view).ctx);
            }
            tag._er = onError && value;
            tagHandlersFromProps(tag, tagCtx);

            tagCtx.view = view;

            tag.ctx = tagCtx.ctx || tag.ctx || {};
            tagCtx.ctx = undefined;

            value = tag.cvtArgs(converter !== "true" && converter)[0]; // If there is a convertBack but no convert, converter will be "true"

            // Call onRender (used by JsViews if present, to add binding annotations around rendered content)
            value = boundTag && view._.onRender
                ? view._.onRender(value, view, tag)
                : value;
        }
        return value != undefined ? value : "";
    }

    function convertArgs(converter) {
        var tag = this,
            tagCtx = tag.tagCtx,
            view = tagCtx.view,
            args = tagCtx.args;

        converter = converter || tag.convert;
        converter = converter && ("" + converter === converter
            ? (view.getRsc("converters", converter) || error("Unknown converter: '" + converter + "'"))
            : converter);

        args = !args.length && !tagCtx.index // On the opening tag with no args, bind to the current data context
            ? [view.data]
            : converter
                ? args.slice() // If there is a converter, use a copy of the tagCtx.args array for rendering, and replace the args[0] in
                // the copied array with the converted value. But we do not modify the value of tag.tagCtx.args[0] (the original args array)
                : args; // If no converter, get the original tagCtx.args

        if (converter) {
            if (converter.depends) {
                tag.depends = $sub.getDeps(tag.depends, tag, converter.depends, converter);
            }
            args[0] = converter.apply(tag, args);
        }
        return args;
    }

    //=============
    // views._tag
    //=============

    function getResource(resourceType, itemName) {
        var res, store,
            view = this;
        while ((res === undefined) && view) {
            store = view.tmpl && view.tmpl[resourceType];
            res = store && store[itemName];
            view = view.parent;
        }
        return res || $views[resourceType][itemName];
    }

    function renderTag(tagName, parentView, tmpl, tagCtxs, isUpdate, onError) {
        parentView = parentView || topView;
        var tag, tag_, tagDef, template, tags, attr, parentTag, i, l, itemRet, tagCtx, tagCtxCtx, content, callInit, mapDef, thisMap, args, props, initialTmpl, tagDataMap,
            ret = "",
            linkCtx = parentView.linkCtx || 0,
            ctx = parentView.ctx,
            parentTmpl = tmpl || parentView.tmpl,
            // if tagCtx is an integer, then it is the key for the compiled function to return the boundTag tagCtxs
            boundTag = typeof tagCtxs === "number" && parentView.tmpl.bnds[tagCtxs - 1];

        if (tagName._is === "tag") {
            tag = tagName;
            tagName = tag.tagName;
            tagCtxs = tag.tagCtxs;
            template = tag.template;
        } else {
            tagDef = parentView.getRsc("tags", tagName) || error("Unknown tag: {{" + tagName + "}} ");
            template = tagDef.template;
        }

        if (onError !== undefined) {
            ret += onError;
            tagCtxs = onError = [{ props: {}, args: [] }];
        } else if (boundTag) {
            tagCtxs = boundTag(parentView.data, parentView, $sub);
        }

        l = tagCtxs.length;
        for (i = 0; i < l; i++) {
            tagCtx = tagCtxs[i];
            if (!linkCtx || !linkCtx.tag || i && !linkCtx.tag._.inline || tag._er) {
                // Initialize tagCtx
                // For block tags, tagCtx.tmpl is an integer > 0
                if (content = parentTmpl.tmpls && tagCtx.tmpl) {
                    content = tagCtx.content = parentTmpl.tmpls[content - 1];
                }
                tagCtx.index = i;
                tagCtx.tmpl = content; // Set the tmpl property to the content of the block tag
                tagCtx.render = renderContent;
                tagCtx.view = parentView;
                tagCtx.ctx = extendCtx(tagCtx.ctx, ctx); // Clone and extend parentView.ctx
            }
            if (tmpl = tagCtx.props.tmpl) {
                // If the tmpl property is overridden, set the value (when initializing, or, in case of binding: ^tmpl=..., when updating)
                tagCtx.tmpl = parentView.getTmpl(tmpl);
            }

            if (!tag) {
                // This will only be hit for initial tagCtx (not for {{else}}) - if the tag instance does not exist yet
                // Instantiate tag if it does not yet exist
                // If the tag has not already been instantiated, we will create a new instance.
                // ~tag will access the tag, even within the rendering of the template content of this tag.
                // From child/descendant tags, can access using ~tag.parent, or ~parentTags.tagName
                tag = new tagDef._ctr();
                callInit = !!tag.init;

                tag.parent = parentTag = ctx && ctx.tag;
                tag.tagCtxs = tagCtxs;
                tagDataMap = tag.dataMap;

                if (linkCtx) {
                    tag._.inline = false;
                    linkCtx.tag = tag;
                    tag.linkCtx = linkCtx;
                }
                if (tag._.bnd = boundTag || linkCtx.fn) {
                    // Bound if {^{tag...}} or data-link="{tag...}"
                    tag._.arrVws = {};
                } else if (tag.dataBoundOnly) {
                    error("{^{" + tagName + "}} tag must be data-bound");
                }
                //TODO better perf for childTags() - keep child tag.tags array, (and remove child, when disposed)
                // tag.tags = [];
            }
            tagCtxs = tag.tagCtxs;
            tagDataMap = tag.dataMap;

            tagCtx.tag = tag;
            if (tagDataMap && tagCtxs) {
                tagCtx.map = tagCtxs[i].map; // Copy over the compiled map instance from the previous tagCtxs to the refreshed ones
            }
            if (!tag.flow) {
                tagCtxCtx = tagCtx.ctx = tagCtx.ctx || {};

                // tags hash: tag.ctx.tags, merged with parentView.ctx.tags,
                tags = tag.parents = tagCtxCtx.parentTags = ctx && extendCtx(tagCtxCtx.parentTags, ctx.parentTags) || {};
                if (parentTag) {
                    tags[parentTag.tagName] = parentTag;
                    //TODO better perf for childTags: parentTag.tags.push(tag);
                }
                tags[tag.tagName] = tagCtxCtx.tag = tag;
            }
        }
        if (!(tag._er = onError)) {
            tagHandlersFromProps(tag, tagCtxs[0]);
            tag.rendering = {}; // Provide object for state during render calls to tag and elses. (Used by {{if}} and {{for}}...)
            for (i = 0; i < l; i++) {
                tagCtx = tag.tagCtx = tagCtxs[i];
                props = tagCtx.props;
                args = tag.cvtArgs();

                if (mapDef = props.dataMap || tagDataMap) {
                    if (args.length || props.dataMap) {
                        thisMap = tagCtx.map;
                        if (!thisMap || thisMap.src !== args[0] || isUpdate) {
                            if (thisMap && thisMap.src) {
                                thisMap.unmap(); // only called if observable map - not when only used in JsRender, e.g. by {{props}}
                            }
                            thisMap = tagCtx.map = mapDef.map(args[0], props, undefined, !tag._.bnd);
                        }
                        args = [thisMap.tgt];
                    }
                }
                tag.ctx = tagCtx.ctx;

                if (!i) {
                    if (callInit) {
                        initialTmpl = tag.template;
                        tag.init(tagCtx, linkCtx, tag.ctx);
                        callInit = undefined;
                    }
                    if (linkCtx) {
                        // Set attr on linkCtx to ensure outputting to the correct target attribute.
                        // Setting either linkCtx.attr or this.attr in the init() allows per-instance choice of target attrib.
                        linkCtx.attr = tag.attr = linkCtx.attr || tag.attr;
                    }
                    attr = tag.attr;
                    tag._.noVws = attr && attr !== HTML;
                }

                itemRet = undefined;
                if (tag.render) {
                    itemRet = tag.render.apply(tag, args);
                    if (parentView.linked && itemRet && tag.linkedElem && !rWrappedInViewMarker.test(itemRet)) {
                        // When a tag renders content from the render method, with data linking, and has a linkedElem binding, then we need to wrap with
                        // view markers, if absent, so the content is a view associated with the tag, which will correctly dispose bindings if deleted.
                        itemRet = renderWithViews($.templates(itemRet), args[0], undefined, undefined, parentView, undefined, undefined, tag);
                    }
                }
                if (!args.length) {
                    args = [parentView]; // no arguments - (e.g. {{else}}) get data context from view.
                }
                if (itemRet === undefined) {
                    itemRet = tagCtx.render(args[0], true) || (isUpdate ? undefined : "");
                }
                // No return value from render, and no template/content tagCtx.render(...), so return undefined
                ret = ret ? ret + (itemRet || "") : itemRet; // If no rendered content, this will be undefined
            }
            tag.rendering = undefined;
        }
        tag.tagCtx = tagCtxs[0];
        tag.ctx = tag.tagCtx.ctx;

        if (tag._.noVws) {
            if (tag._.inline) {
                // inline tag with attr set to "text" will insert HTML-encoded content - as if it was element-based innerText
                ret = attr === "text"
                    ? $converters.html(ret)
                    : "";
            }
        }
        return boundTag && parentView._.onRender
            // Call onRender (used by JsViews if present, to add binding annotations around rendered content)
            ? parentView._.onRender(ret, parentView, tag)
            : ret;
    }

    //=================
    // View constructor
    //=================

    function View(context, type, parentView, data, template, key, onRender, contentTmpl) {
        // Constructor for view object in view hierarchy. (Augmented by JsViews if JsViews is loaded)
        var views, parentView_, tag, self_,
            self = this,
            isArray = type === "array";

        self.content = contentTmpl;
        self.views = isArray ? [] : {};
        self.parent = parentView;
        self.type = type || "top";
        self.data = data;
        self.tmpl = template;
        // If the data is an array, this is an 'array view' with a views array for each child 'item view'
        // If the data is not an array, this is an 'item view' with a views 'hash' object for any child nested views
        // ._.useKey is non zero if is not an 'array view' (owning a data array). Use this as next key for adding to child views hash
        self_ = self._ = {
            key: 0,
            useKey: isArray ? 0 : 1,
            id: "" + viewId++,
            onRender: onRender,
            bnds: {}
        };
        self.linked = !!onRender;
        if (parentView) {
            views = parentView.views;
            parentView_ = parentView._;
            if (parentView_.useKey) {
                // Parent is not an 'array view'. Add this view to its views object
                // self._key = is the key in the parent view hash
                views[self_.key = "_" + parentView_.useKey++] = self;
                self.index = indexStr;
                self.getIndex = getNestedIndex;
            } else if (views.length === (self_.key = self.index = key)) { // Parent is an 'array view'. Add this view to its views array
                views.push(self); // Adding to end of views array. (Using push when possible - better perf than splice)
            } else {
                views.splice(key, 0, self); // Inserting in views array
            }
            // If no context was passed in, use parent context
            // If context was passed in, it should have been merged already with parent context
            self.ctx = context || parentView.ctx;
        } else {
            self.ctx = context;
        }
    }

    View.prototype = {
        get: getView,
        getIndex: getIndex,
        getRsc: getResource,
        getTmpl: getTemplate,
        hlp: getHelper,
        _is: "view"
    };

    //====================================================
    // Registration
    //====================================================

    function compileChildResources(parentTmpl) {
        var storeName, storeNames, resources;
        for (storeName in jsvStores) {
            storeNames = storeName + "s";
            if (parentTmpl[storeNames]) {
                resources = parentTmpl[storeNames];    // Resources not yet compiled
                parentTmpl[storeNames] = {};               // Remove uncompiled resources
                $views[storeNames](resources, parentTmpl); // Add back in the compiled resources
            }
        }
    }

    //===============
    // compileTag
    //===============

    function compileTag(name, tagDef, parentTmpl) {
        var tmpl, baseTag, prop,
            compiledDef = new $sub._tg();

        function Tag() {
            var tag = this;
            tag._ = {
                inline: true,
                unlinked: true
            };

            tag.tagName = name;
        }

        if ($isFunction(tagDef)) {
            // Simple tag declared as function. No presenter instantation.
            tagDef = {
                depends: tagDef.depends,
                render: tagDef
            };
        } else if ("" + tagDef === tagDef) {
            tagDef = { template: tagDef };
        }
        if (baseTag = tagDef.baseTag) {
            tagDef.flow = !!tagDef.flow; // Set flow property, so defaults to false even if baseTag has flow=true
            tagDef.baseTag = baseTag = "" + baseTag === baseTag
                ? (parentTmpl && parentTmpl.tags[baseTag] || $tags[baseTag])
                : baseTag;

            compiledDef = $extend(compiledDef, baseTag);

            for (prop in tagDef) {
                compiledDef[prop] = getMethod(baseTag[prop], tagDef[prop]);
            }
        } else {
            compiledDef = $extend(compiledDef, tagDef);
        }

        // Tag declared as object, used as the prototype for tag instantiation (control/presenter)
        if ((tmpl = compiledDef.template) !== undefined) {
            compiledDef.template = "" + tmpl === tmpl ? ($templates[tmpl] || $templates(tmpl)) : tmpl;
        }
        if (compiledDef.init !== false) {
            // Set init: false on tagDef if you want to provide just a render method, or render and template, but no constructor or prototype.
            // so equivalent to setting tag to render function, except you can also provide a template.
            (Tag.prototype = compiledDef).constructor = compiledDef._ctr = Tag;
        }

        if (parentTmpl) {
            compiledDef._parentTmpl = parentTmpl;
        }
        return compiledDef;
    }

    function baseApply(args) {
        // In derived method (or handler declared declaratively as in {{:foo onChange=~fooChanged}} can call base method,
        // using this.baseApply(arguments) (Equivalent to this._superApply(arguments) in jQuery UI)
        return this.base.apply(this, args);
    }

    //===============
    // compileTmpl
    //===============

    function compileTmpl(name, tmpl, parentTmpl, options) {
        // tmpl is either a template object, a selector for a template script block, the name of a compiled template, or a template object

        //==== nested functions ====
        function lookupTemplate(value) {
            // If value is of type string - treat as selector, or name of compiled template
            // Return the template object, if already compiled, or the markup string
            var currentName, tmpl;
            if (("" + value === value) || value.nodeType > 0 && (elem = value)) {
                if (!elem) {
                    if (/^\.\/[^\\:*?"<>]*$/.test(value)) {
                        // tmpl="./some/file.html"
                        // If the template is not named, use "./some/file.html" as name.
                        if (tmpl = $templates[name = name || value]) {
                            value = tmpl;
                        } else {
                            // BROWSER-SPECIFIC CODE (not on Node.js):
                            // Look for server-generated script block with id "./some/file.html"
                            elem = document.getElementById(value);
                        }
                    } else if ($.fn && !$sub.rTmpl.test(value)) {
                        try {
                            elem = $(document).find(value)[0]; // if jQuery is loaded, test for selector returning elements, and get first element
                        } catch (e) { }
                    }// END BROWSER-SPECIFIC CODE
                } //BROWSER-SPECIFIC CODE
                if (elem) {
                    // Generally this is a script element.
                    // However we allow it to be any element, so you can for example take the content of a div,
                    // use it as a template, and replace it by the same content rendered against data.
                    // e.g. for linking the content of a div to a container, and using the initial content as template:
                    // $.link("#content", model, {tmpl: "#content"});
                    if (options) {
                        // We will compile a new template using the markup in the script element
                        value = elem.innerHTML;
                    } else {
                        // We will cache a single copy of the compiled template, and associate it with the name
                        // (renaming from a previous name if there was one).
                        currentName = elem.getAttribute(tmplAttr);
                        if (currentName) {
                            if (currentName !== jsvTmpl) {
                                value = $templates[currentName];
                                delete $templates[currentName];
                            } else if ($.fn) {
                                value = $.data(elem)[jsvTmpl];
                            }
                        } else {
                            name = name || ($.fn ? jsvTmpl : value);
                            value = compileTmpl(name, elem.innerHTML, parentTmpl, options);
                        }
                        value.tmplName = name = name || currentName;
                        if (name !== jsvTmpl) {
                            $templates[name] = value;
                        }
                        elem.setAttribute(tmplAttr, name);
                        if ($.fn) {
                            $.data(elem, jsvTmpl, value);
                        }
                    }
                } // END BROWSER-SPECIFIC CODE
                elem = undefined;
            } else if (!value.fn) {
                value = undefined;
                // If value is not a string. HTML element, or compiled template, return undefined
            }
            return value;
        }

        var elem, compiledTmpl,
            tmplOrMarkup = tmpl = tmpl || "";

        //==== Compile the template ====
        if (options === 0) {
            options = undefined;
            tmplOrMarkup = lookupTemplate(tmplOrMarkup); // Top-level compile so do a template lookup
        }

        // If options, then this was already compiled from a (script) element template declaration.
        // If not, then if tmpl is a template object, use it for options
        options = options || (tmpl.markup ? tmpl : {});
        options.tmplName = name;
        if (parentTmpl) {
            options._parentTmpl = parentTmpl;
        }
        // If tmpl is not a markup string or a selector string, then it must be a template object
        // In that case, get it from the markup property of the object
        if (!tmplOrMarkup && tmpl.markup && (tmplOrMarkup = lookupTemplate(tmpl.markup))) {
            if (tmplOrMarkup.fn) {
                // If the string references a compiled template object, need to recompile to merge any modified options
                tmplOrMarkup = tmplOrMarkup.markup;
            }
        }
        if (tmplOrMarkup !== undefined) {
            if (tmplOrMarkup.fn || tmpl.fn) {
                // tmpl is already compiled, so use it
                if (tmplOrMarkup.fn) {
                    compiledTmpl = tmplOrMarkup;
                }
            } else {
                // tmplOrMarkup is a markup string, not a compiled template
                // Create template object
                tmpl = tmplObject(tmplOrMarkup, options);
                // Compile to AST and then to compiled function
                tmplFn(tmplOrMarkup.replace(rEscapeQuotes, "\\$&"), tmpl);
            }
            if (!compiledTmpl) {
                compiledTmpl = $extend(function () {
                    return compiledTmpl.render.apply(compiledTmpl, arguments);
                }, tmpl);

                compileChildResources(compiledTmpl);
            }
            if (name && !parentTmpl && name !== jsvTmpl) {
                $render[name] = compiledTmpl;
            }
            return compiledTmpl;
        }
    }

    //==== /end of function compileTmpl ====

    //=================
    // compileViewModel
    //=================

    function getDefaultVal(defaultVal, data) {
        return $.isFunction(defaultVal)
            ? defaultVal.call(data)
            : defaultVal;
    }

    function unmapArray(modelArr) {
        var i, arr = [],
			l = modelArr.length;
        for (i = 0; i < l; i++) {
            arr.push(modelArr[i].unmap());
        }
        return arr;
    }

    function compileViewModel(name, type) {
        var i, constructor,
            viewModels = this,
            getters = type.getters,
            extend = type.extend,
            id = type.id,
            proto = $.extend({
                _is: name || "unnamed",
                unmap: unmap,
                merge: merge
            }, extend),
            args = "",
            body = "",
            l = getters ? getters.length : 0,
            $observable = $.observable,
            getterNames = {};

        function GetNew(args) {
            constructor.apply(this, args);
        }

        function vm() {
            return new GetNew(arguments);
        }

        function iterate(data, action) {
            var j, getterType, defaultVal, prop, ob,
                m = getters.length;
            for (j = 0; j < m; j++) {
                prop = getters[j];
                getterType = undefined;
                if (prop + "" !== prop) {
                    getterType = prop;
                    prop = getterType.getter;
                }
                if ((ob = data[prop]) === undefined && getterType && (defaultVal = getterType.defaultVal) !== undefined) {
                    ob = getDefaultVal(defaultVal, data);
                }
                action(ob, getterType && viewModels[getterType.type], prop);
            }
        }

        function map(data) {
            data = data + "" === data
                ? JSON.parse(data) // Accept JSON string
                : data;            // or object/array
            var i, j, l, m, prop,
                ob = data,
                arr = [];

            if ($isArray(data)) {
                data = data || [];
                l = data.length;
                for (i = 0; i < l; i++) {
                    arr.push(this.map(data[i]));
                }
                arr._is = name;
                arr.unmap = unmap;
                arr.merge = merge;
                return arr;
            }

            if (data) {
                iterate(data, function (ob, viewModel) {
                    if (viewModel) { // Iterate to build getters arg array (value, or mapped value)
                        ob = viewModel.map(ob);
                    }
                    arr.push(ob);
                });

                ob = this.apply(this, arr); // Insantiate this View Model, passing getters args array to constructor
                for (prop in data) { // Copy over any other properties. that are not get/set properties
                    if (prop !== $expando && !getterNames[prop]) {
                        ob[prop] = data[prop];
                    }
                }
            }
            return ob;
        }

        function merge(data) {
            data = data + "" === data
                ? JSON.parse(data) // Accept JSON string
                : data;            // or object/array
            var i, j, l, m, prop, mod, found, assigned, ob, newModArr,
                model = this;

            if ($isArray(model)) {
                assigned = {};
                newModArr = [];
                l = data.length;
                m = model.length;
                for (i = 0; i < l; i++) {
                    ob = data[i];
                    found = false;
                    for (j = 0; j < m && !found; j++) {
                        if (assigned[j]) {
                            continue;
                        }
                        mod = model[j];

                        if (id) {
                            assigned[j] = found = id + "" === id
                            ? (ob[id] && (getterNames[id] ? mod[id]() : mod[id]) === ob[id])
                            : id(mod, ob);
                        }
                    }
                    if (found) {
                        mod.merge(ob);
                        newModArr.push(mod);
                    } else {
                        newModArr.push(vm.map(ob));
                    }
                }
                if ($observable) {
                    $observable(model).refresh(newModArr, true);
                } else {
                    model.splice.apply(model, [0, model.length].concat(newModArr));
                }
                return;
            }
            iterate(data, function (ob, viewModel, getter) {
                if (viewModel) {
                    model[getter]().merge(ob); // Update typed property
                } else {
                    model[getter](ob); // Update non-typed property
                }
            });
            for (prop in data) {
                if (prop !== $expando && !getterNames[prop]) {
                    model[prop] = data[prop];
                }
            }
        }

        function unmap() {
            var ob, prop, i, l, getterType, arr, value,
                model = this;

            if ($isArray(model)) {
                return unmapArray(model);
            }
            ob = {};
            l = getters.length;
            for (i = 0; i < l; i++) {
                prop = getters[i];
                getterType = undefined;
                if (prop + "" !== prop) {
                    getterType = prop;
                    prop = getterType.getter;
                }
                value = model[prop]();
                ob[prop] = getterType && value && viewModels[getterType.type]
                    ? $isArray(value)
                        ? unmapArray(value)
                        : value.unmap()
                    : value;
            }
            for (prop in model) {
                if (prop !== "_is" && !getterNames[prop] && prop !== $expando && (prop.charAt(0) !== "_" || !getterNames[prop.slice(1)]) && !$.isFunction(model[prop])) {
                    ob[prop] = model[prop];
                }
            }
            return ob;
        }

        GetNew.prototype = proto;

        for (i = 0; i < l; i++) {
            (function (getter) {
                getter = getter.getter || getter;
                getterNames[getter] = i + 1;
                var privField = "_" + getter;

                args += (args ? "," : "") + getter;
                body += "this." + privField + " = " + getter + ";\n";
                proto[getter] = proto[getter] || function (val) {
                    if (!arguments.length) {
                        return this[privField]; // If there is no argument, use as a getter
                    }
                    if ($observable) {
                        $observable(this).setProperty(getter, val);
                    } else {
                        this[privField] = val;
                    }
                };

                if ($observable) {
                    proto[getter].set = proto[getter].set || function (val) {
                        this[privField] = val; // Setter called by observable property change
                    };
                }
            })(getters[i]);
        }

        constructor = new Function(args, body.slice(0, -1));
        constructor.prototype = proto;
        proto.constructor = constructor;

        vm.map = map;
        vm.getters = getters;
        vm.extend = extend;
        vm.id = id;
        return vm;
    }

    function tmplObject(markup, options) {
        // Template object constructor
        var htmlTag,
            wrapMap = $subSettingsAdvanced._wm || {}, // Only used in JsViews. Otherwise empty: {}
            tmpl = $extend(
                {
                    tmpls: [],
                    links: {}, // Compiled functions for link expressions
                    bnds: [],
                    _is: "template",
                    render: renderContent
                },
                options
            );

        tmpl.markup = markup;
        if (!options.htmlTag) {
            // Set tmpl.tag to the top-level HTML tag used in the template, if any...
            htmlTag = rFirstElem.exec(markup);
            tmpl.htmlTag = htmlTag ? htmlTag[1].toLowerCase() : "";
        }
        htmlTag = wrapMap[tmpl.htmlTag];
        if (htmlTag && htmlTag !== wrapMap.div) {
            // When using JsViews, we trim templates which are inserted into HTML contexts where text nodes are not rendered (i.e. not 'Phrasing Content').
            // Currently not trimmed for <li> tag. (Not worth adding perf cost)
            tmpl.markup = $.trim(tmpl.markup);
        }

        return tmpl;
    }

    //==============
    // registerStore
    //==============

    function registerStore(storeName, storeSettings) {

        function theStore(name, item, parentTmpl) {
            // The store is also the function used to add items to the store. e.g. $.templates, or $.views.tags

            // For store of name 'thing', Call as:
            //    $.views.things(items[, parentTmpl]),
            // or $.views.things(name, item[, parentTmpl])

            var onStore, compile, itemName, thisStore;
            if (name && typeof name === OBJECT && !name.nodeType && !name.markup && !name.getTgt && !(storeName === "viewModel" && name.getters || name.extend)) {
                // Call to $.views.things(items[, parentTmpl]),

                // Adding items to the store
                // If name is a hash, then item is parentTmpl. Iterate over hash and call store for key.
                for (itemName in name) {
                    theStore(itemName, name[itemName], item);
                }
                return item || $views;
            }
            // Adding a single unnamed item to the store
            if (item === undefined) {
                item = name;
                name = undefined;
            }
            if (name && "" + name !== name) { // name must be a string
                parentTmpl = item;
                item = name;
                name = undefined;
            }
            thisStore = parentTmpl
                ? storeName === "viewModel"
                    ? parentTmpl
                    : (parentTmpl[storeNames] = parentTmpl[storeNames] || {})
                : theStore;
            compile = storeSettings.compile;
            if (item === null) {
                // If item is null, delete this entry
                if (name) {
                    delete thisStore[name];
                }
            } else {
                item = compile ? compile.call(thisStore, name, item, parentTmpl, 0) : item;
                if (name) {
                    thisStore[name] = item;
                }
            }
            if (compile && item) {
                item._is = storeName; // Only do this for compiled objects (tags, templates...)
            }
            if (item && (onStore = $sub.onStore[storeName])) {
                // e.g. JsViews integration
                onStore(name, item, compile);
            }
            return item;
        }

        var storeNames = storeName + "s";

        $views[storeNames] = theStore;
    }

    function addSetting(st) {
        $viewsSettings[st] = function (value) {
            return arguments.length
                ? ($subSettings[st] = value, $viewsSettings)
                : $subSettings[st];
        };
    }

    //=========
    // dataMap
    //=========

    function dataMap(mapDef) {
        function Map(source, options) {
            this.tgt = mapDef.getTgt(source, options);
        }

        if ($isFunction(mapDef)) {
            // Simple map declared as function
            mapDef = {
                getTgt: mapDef
            };
        }

        if (mapDef.baseMap) {
            mapDef = $extend($extend({}, mapDef.baseMap), mapDef);
        }

        mapDef.map = function (source, options) {
            return new Map(source, options);
        };
        return mapDef;
    }

    //==============
    // renderContent
    //==============

    function renderContent(data, context, noIteration, parentView, key, onRender) {
        var i, l, tag, tmpl, tagCtx, isTopRenderCall, prevData, prevIndex,
            view = parentView,
            result = "";

        if (context === true) {
            noIteration = context; // passing boolean as second param - noIteration
            context = undefined;
        } else if (typeof context !== OBJECT) {
            context = undefined; // context must be a boolean (noIteration) or a plain object
        }

        if (tag = this.tag) {
            // This is a call from renderTag or tagCtx.render(...)
            tagCtx = this;
            view = view || tagCtx.view;
            tmpl = view.getTmpl(tag.template || tagCtx.tmpl);
            if (!arguments.length) {
                data = view;
            }
        } else {
            // This is a template.render(...) call
            tmpl = this;
        }

        if (tmpl) {
            if (!view && data && data._is === "view") {
                view = data; // When passing in a view to render or link (and not passing in a parent view) use the passed-in view as parentView
            }

            if (view) {
                if (data === view) {
                    // Inherit the data from the parent view.
                    // This may be the contents of an {{if}} block
                    data = view.data;
                }
            }

            isTopRenderCall = !view;
            isRenderCall = isRenderCall || isTopRenderCall;
            if (!view) {
                (context = context || {}).root = data; // Provide ~root as shortcut to top-level data.
            }
            if (!isRenderCall || $subSettingsAdvanced.useViews || tmpl.useViews || view && view !== topView) {
                result = renderWithViews(tmpl, data, context, noIteration, view, key, onRender, tag);
            } else {
                if (view) { // In a block
                    prevData = view.data;
                    prevIndex = view.index;
                    view.index = indexStr;
                } else {
                    view = topView;
                    view.data = data;
                    view.ctx = context;
                }
                if ($isArray(data) && !noIteration) {
                    // Create a view for the array, whose child views correspond to each data item. (Note: if key and parentView are passed in
                    // along with parent view, treat as insert -e.g. from view.addViews - so parentView is already the view item for array)
                    for (i = 0, l = data.length; i < l; i++) {
                        view.index = i;
                        view.data = data[i];
                        result += tmpl.fn(data[i], view, $sub);
                    }
                } else {
                    view.data = data;
                    result += tmpl.fn(data, view, $sub);
                }
                view.data = prevData;
                view.index = prevIndex;
            }
            if (isTopRenderCall) {
                isRenderCall = undefined;
            }
        }
        return result;
    }

    function renderWithViews(tmpl, data, context, noIteration, view, key, onRender, tag) {
        function setItemVar(item) {
            // When itemVar is specified, set modified ctx with user-named ~item
            newCtx = $extend({}, context);
            newCtx[itemVar] = item;
        }

        // Render template against data as a tree of subviews (nested rendered template instances), or as a string (top-level template).
        // If the data is the parent view, treat as noIteration, re-render with the same data context.
        var i, l, newView, childView, itemResult, swapContent, contentTmpl, outerOnRender, tmplName, itemVar, newCtx, tagCtx,
            result = "";

        if (tag) {
            // This is a call from renderTag or tagCtx.render(...)
            tmplName = tag.tagName;
            tagCtx = tag.tagCtx;
            context = context ? extendCtx(context, tag.ctx) : tag.ctx;

            if (tmpl === view.content) { // {{xxx tmpl=#content}}
                contentTmpl = tmpl !== view.ctx._wrp // We are rendering the #content
                    ? view.ctx._wrp // #content was the tagCtx.props.tmpl wrapper of the block content - so within this view, #content will now be the view.ctx._wrp block content
                    : undefined; // #content was the view.ctx._wrp block content - so within this view, there is no longer any #content to wrap.
            } else if (tmpl !== tagCtx.content) {
                if (tmpl === tag.template) { // Rendering {{tag}} tag.template, replacing block content.
                    contentTmpl = tagCtx.tmpl; // Set #content to block content (or wrapped block content if tagCtx.props.tmpl is set)
                    context._wrp = tagCtx.content; // Pass wrapped block content to nested views
                } else { // Rendering tagCtx.props.tmpl wrapper
                    contentTmpl = tagCtx.content || view.content; // Set #content to wrapped block content
                }
            } else {
                contentTmpl = view.content; // Nested views inherit same wrapped #content property
            }

            if (tagCtx.props.link === false) {
                // link=false setting on block tag
                // We will override inherited value of link by the explicit setting link=false taken from props
                // The child views of an unlinked view are also unlinked. So setting child back to true will not have any effect.
                context = context || {};
                context.link = false;
            }

            if (itemVar = tagCtx.props.itemVar) {
                if (itemVar.charAt(0) !== "~") {
                    syntaxError("Use itemVar='~myItem'");
                }
                itemVar = itemVar.slice(1);
            }
        }

        if (view) {
            onRender = onRender || view._.onRender;
            context = extendCtx(context, view.ctx);
        }

        if (key === true) {
            swapContent = true;
            key = 0;
        }

        // If link===false, do not call onRender, so no data-linking marker nodes
        if (onRender && (context && context.link === false || tag && tag._.noVws)) {
            onRender = undefined;
        }
        outerOnRender = onRender;
        if (onRender === true) {
            // Used by view.refresh(). Don't create a new wrapper view.
            outerOnRender = undefined;
            onRender = view._.onRender;
        }
        // Set additional context on views created here, (as modified context inherited from the parent, and to be inherited by child views)
        context = tmpl.helpers
            ? extendCtx(tmpl.helpers, context)
            : context;

        newCtx = context;
        if ($isArray(data) && !noIteration) {
            // Create a view for the array, whose child views correspond to each data item. (Note: if key and view are passed in
            // along with parent view, treat as insert -e.g. from view.addViews - so view is already the view item for array)
            newView = swapContent
                ? view
                : (key !== undefined && view)
                    || new View(context, "array", view, data, tmpl, key, onRender);
            if (view && view._.useKey) {
                // Parent is not an 'array view'
                newView._.bnd = !tag || tag._.bnd && tag; // For array views that are data bound for collection change events, set the
                // view._.bnd property to true for top-level link() or data-link="{for}", or to the tag instance for a data-bound tag, e.g. {^{for ...}}
            }
            if (itemVar) {
                newView.it = itemVar;
            }
            itemVar = newView.it;
            for (i = 0, l = data.length; i < l; i++) {
                // Create a view for each data item.
                if (itemVar) {
                    setItemVar(data[i]); // use modified ctx with user-named ~item
                }
                childView = new View(newCtx, "item", newView, data[i], tmpl, (key || 0) + i, onRender, contentTmpl);

                itemResult = tmpl.fn(data[i], childView, $sub);
                result += newView._.onRender ? newView._.onRender(itemResult, childView) : itemResult;
            }
        } else {
            // Create a view for singleton data object. The type of the view will be the tag name, e.g. "if" or "myTag" except for
            // "item", "array" and "data" views. A "data" view is from programmatic render(object) against a 'singleton'.
            if (itemVar) {
                setItemVar(data);
            }
            newView = swapContent ? view : new View(newCtx, tmplName || "data", view, data, tmpl, key, onRender, contentTmpl);
            if (tag && !tag.flow) {
                newView.tag = tag;
            }
            result += tmpl.fn(data, newView, $sub);
        }
        return outerOnRender ? outerOnRender(result, newView) : result;
    }

    //===========================
    // Build and compile template
    //===========================

    // Generate a reusable function that will serve to render a template against data
    // (Compile AST then build template function)

    function onRenderError(e, view, fallback) {
        var message = fallback !== undefined
            ? $isFunction(fallback)
                ? fallback.call(view.data, e, view)
                : fallback || ""
            : "{Error: " + e.message + "}";

        if ($subSettings.onError && (fallback = $subSettings.onError.call(view.data, e, fallback && message, view)) !== undefined) {
            message = fallback; // There is a settings.debugMode(handler) onError override. Call it, and use return value (if any) to replace message
        }

        return view && !view.linkCtx ? $converters.html(message) : message;
    }

    function error(message) {
        throw new $sub.Err(message);
    }

    function syntaxError(message) {
        error("Syntax error\n" + message);
    }

    function tmplFn(markup, tmpl, isLinkExpr, convertBack, hasElse) {
        // Compile markup to AST (abtract syntax tree) then build the template function code from the AST nodes
        // Used for compiling templates, and also by JsViews to build functions for data link expressions

        //==== nested functions ====
        function pushprecedingContent(shift) {
            shift -= loc;
            if (shift) {
                content.push(markup.substr(loc, shift).replace(rNewLine, "\\n"));
            }
        }

        function blockTagCheck(tagName, block) {
            if (tagName) {
                tagName += '}}';
                //			'{{include}} block has {{/for}} with no open {{for}}'
                syntaxError((
                    block
                        ? '{{' + block + '}} block has {{/' + tagName + ' without {{' + tagName
                        : 'Unmatched or missing {{/' + tagName) + ', in template:\n' + markup);
            }
        }

        function parseTag(all, bind, tagName, converter, colon, html, codeTag, params, slash, bind2, closeBlock, index) {
            /*
            
                 bind     tagName         cvt   cln html code    params            slash   bind2         closeBlk  comment
            /(?:{(\^)?{(?:(\w+(?=[\/\s}]))|(\w+)?(:)|(>)|(\*))\s*((?:[^}]|}(?!}))*?)(\/)?|{(\^)?{(?:(?:\/(\w+))\s*|!--[\s\S]*?--))}}/g
            
            (?:
              {(\^)?{            bind
              (?:
                (\w+             tagName
                  (?=[\/\s}])
                )
                |
                (\w+)?(:)        converter colon
                |
                (>)              html
                |
                (\*)             codeTag
              )
              \s*
              (                  params
                (?:[^}]|}(?!}))*?
              )
              (\/)?              slash
              |
              {(\^)?{            bind2
              (?:
                (?:\/(\w+))\s*   closeBlock
                |
                !--[\s\S]*?--    comment
              )
            )
            }}/g
            
            */
            if (codeTag && bind || slash && !tagName || params && params.slice(-1) === ":" || bind2) {
                syntaxError(all);
            }

            // Build abstract syntax tree (AST): [tagName, converter, params, content, hash, bindings, contentMarkup]
            if (html) {
                colon = ":";
                converter = HTML;
            }
            slash = slash || isLinkExpr && !hasElse;

            var pathBindings = (bind || isLinkExpr) && [[]],
                props = "",
                args = "",
                ctxProps = "",
                paramsArgs = "",
                paramsProps = "",
                paramsCtxProps = "",
                onError = "",
                useTrigger = "",
                // Block tag if not self-closing and not {{:}} or {{>}} (special case) and not a data-link expression
                block = !slash && !colon;

            //==== nested helper function ====
            tagName = tagName || (params = params || "#data", colon); // {{:}} is equivalent to {{:#data}}
            pushprecedingContent(index);
            loc = index + all.length; // location marker - parsed up to here
            if (codeTag) {
                if (allowCode) {
                    content.push(["*", "\n" + params.replace(/^:/, "ret+= ").replace(rUnescapeQuotes, "$1") + ";\n"]);
                }
            } else if (tagName) {
                if (tagName === "else") {
                    if (rTestElseIf.test(params)) {
                        syntaxError('for "{{else if expr}}" use "{{else expr}}"');
                    }
                    pathBindings = current[7] && [[]];
                    current[8] = markup.substring(current[8], index); // contentMarkup for block tag
                    current = stack.pop();
                    content = current[2];
                    block = true;
                }
                if (params) {
                    // remove newlines from the params string, to avoid compiled code errors for unterminated strings
                    parseParams(params.replace(rNewLine, " "), pathBindings, tmpl)
                        .replace(rBuildHash, function (all, onerror, isCtx, key, keyToken, keyValue, arg, param) {
                            key = "'" + keyToken + "':";
                            if (arg) {
                                args += keyValue + ",";
                                paramsArgs += "'" + param + "',";
                            } else if (isCtx) {
                                ctxProps += key + 'j._cp(' + keyValue + ',"' + param + '",view),';
                                // Compiled code for evaluating tagCtx on a tag will have: ctx:{'foo':j._cp(compiledExpr, "expr", view)}
                                paramsCtxProps += key + "'" + param + "',";
                            } else if (onerror) {
                                onError += keyValue;
                            } else {
                                if (keyToken === "trigger") {
                                    useTrigger += keyValue;
                                }
                                props += key + keyValue + ",";
                                paramsProps += key + "'" + param + "',";
                                hasHandlers = hasHandlers || rHasHandlers.test(keyToken);
                            }
                            return "";
                        }).slice(0, -1);
                }

                if (pathBindings && pathBindings[0]) {
                    pathBindings.pop(); // Remove the bindings that was prepared for next arg. (There is always an extra one ready).
                }

                newNode = [
                        tagName,
                        converter || !!convertBack || hasHandlers || "",
                        block && [],
                        parsedParam(paramsArgs || (tagName === ":" ? "'#data'," : ""), paramsProps, paramsCtxProps), // {{:}} equivalent to {{:#data}}
                        parsedParam(args || (tagName === ":" ? "data," : ""), props, ctxProps),
                        onError,
                        useTrigger,
                        pathBindings || 0
                ];
                content.push(newNode);
                if (block) {
                    stack.push(current);
                    current = newNode;
                    current[8] = loc; // Store current location of open tag, to be able to add contentMarkup when we reach closing tag
                }
            } else if (closeBlock) {
                blockTagCheck(closeBlock !== current[0] && current[0] !== "else" && closeBlock, current[0]);
                current[8] = markup.substring(current[8], index); // contentMarkup for block tag
                current = stack.pop();
            }
            blockTagCheck(!current && closeBlock);
            content = current[2];
        }
        //==== /end of nested functions ====

        var i, result, newNode, hasHandlers, bindings,
            allowCode = $subSettings.allowCode || tmpl && tmpl.allowCode
                || $viewsSettings.allowCode === true, // include direct setting of settings.allowCode true for backward compat only
            astTop = [],
            loc = 0,
            stack = [],
            content = astTop,
            current = [, , astTop];

        if (allowCode && tmpl._is) {
            tmpl.allowCode = allowCode;
        }

        //TODO	result = tmplFnsCache[markup]; // Only cache if template is not named and markup length < ...,
        //and there are no bindings or subtemplates?? Consider standard optimization for data-link="a.b.c"
        //		if (result) {
        //			tmpl.fn = result;
        //		} else {

        //		result = markup;
        if (isLinkExpr) {
            if (convertBack !== undefined) {
                markup = markup.slice(0, -convertBack.length - 2) + delimCloseChar0;
            }
            markup = delimOpenChar0 + markup + delimCloseChar1;
        }

        blockTagCheck(stack[0] && stack[0][2].pop()[0]);
        // Build the AST (abstract syntax tree) under astTop
        markup.replace(rTag, parseTag);

        pushprecedingContent(markup.length);

        if (loc = astTop[astTop.length - 1]) {
            blockTagCheck("" + loc !== loc && (+loc[8] === loc[8]) && loc[0]);
        }
        //			result = tmplFnsCache[markup] = buildCode(astTop, tmpl);
        //		}

        if (isLinkExpr) {
            result = buildCode(astTop, markup, isLinkExpr);
            bindings = [];
            i = astTop.length;
            while (i--) {
                bindings.unshift(astTop[i][7]);  // With data-link expressions, pathBindings array for tagCtx[i] is astTop[i][7]
            }
            setPaths(result, bindings);
        } else {
            result = buildCode(astTop, tmpl);
        }
        return result;
    }

    function setPaths(fn, pathsArr) {
        var key, paths,
            i = 0,
            l = pathsArr.length;
        fn.deps = [];
        for (; i < l; i++) {
            paths = pathsArr[i];
            for (key in paths) {
                if (key !== "_jsvto" && paths.hasOwnProperty(key) && paths[key].length) {
                    fn.deps = fn.deps.concat(paths[key]); // deps is the concatenation of the paths arrays for the different bindings
                }
            }
        }
        fn.paths = paths; // The array of paths arrays for the different bindings
    }

    function parsedParam(args, props, ctx) {
        return [args.slice(0, -1), props.slice(0, -1), ctx.slice(0, -1)];
    }

    function paramStructure(parts, type) {
        return '\n\t'
            + (type
                ? type + ':{'
                : '')
            + 'args:[' + parts[0] + ']'
            + (parts[1] || !type
                ? ',\n\tprops:{' + parts[1] + '}'
                : "")
            + (parts[2] ? ',\n\tctx:{' + parts[2] + '}' : "");
    }

    function parseParams(params, pathBindings, tmpl) {

        function parseTokens(all, lftPrn0, lftPrn, bound, path, operator, err, eq, path2, prn, comma, lftPrn2, apos, quot, rtPrn, rtPrnDot, prn2, space, index, full) {
            // /(\()(?=\s*\()|(?:([([])\s*)?(?:(\^?)(!*?[#~]?[\w$.^]+)?\s*((\+\+|--)|\+|-|&&|\|\||===|!==|==|!=|<=|>=|[<>%*:?\/]|(=))\s*|(!*?[#~]?[\w$.^]+)([([])?)|(,\s*)|(\(?)\\?(?:(')|("))|(?:\s*(([)\]])(?=\s*[.^]|\s*$|[^([])|[)\]])([([]?))|(\s+)/g,
            //   lftPrn0        lftPrn        bound            path    operator err                                                eq             path2       prn    comma   lftPrn2   apos quot      rtPrn rtPrnDot                        prn2  space
            // (left paren? followed by (path? followed by operator) or (path followed by paren?)) or comma or apos or quot or right paren or space
            function parsePath(allPath, not, object, helper, view, viewProperty, pathTokens, leafToken) {
                //rPath = /^(!*?)(?:null|true|false|\d[\d.]*|([\w$]+|\.|~([\w$]+)|#(view|([\w$]+))?)([\w$.^]*?)(?:[.[^]([\w$]+)\]?)?)$/g,
                //          not                               object     helper    view  viewProperty pathTokens      leafToken
                var subPath = object === ".";
                if (object) {
                    path = path.slice(not.length);
                    if (/^\.?constructor$/.test(leafToken || path)) {
                        syntaxError(allPath);
                    }
                    if (!subPath) {
                        allPath = (helper
                                ? 'view.hlp("' + helper + '")'
                                : view
                                    ? "view"
                                    : "data")
                            + (leafToken
                                ? (viewProperty
                                    ? "." + viewProperty
                                    : helper
                                        ? ""
                                        : (view ? "" : "." + object)
                                    ) + (pathTokens || "")
                                : (leafToken = helper ? "" : view ? viewProperty || "" : object, ""));

                        allPath = allPath + (leafToken ? "." + leafToken : "");

                        allPath = not + (allPath.slice(0, 9) === "view.data"
                            ? allPath.slice(5) // convert #view.data... to data...
                            : allPath);
                    }
                    if (bindings) {
                        binds = named === "linkTo" ? (bindto = pathBindings._jsvto = pathBindings._jsvto || []) : bndCtx.bd;
                        if (theOb = subPath && binds[binds.length - 1]) {
                            if (theOb._jsv) {
                                while (theOb.sb) {
                                    theOb = theOb.sb;
                                }
                                if (theOb.bnd) {
                                    path = "^" + path.slice(1);
                                }
                                theOb.sb = path;
                                theOb.bnd = theOb.bnd || path.charAt(0) === "^";
                            }
                        } else {
                            binds.push(path);
                        }
                        pathStart[parenDepth] = index + (subPath ? 1 : 0);
                    }
                }
                return allPath;
            }

            //bound = bindings && bound;
            if (bound && !eq) {
                path = bound + path; // e.g. some.fn(...)^some.path - so here path is "^some.path"
            }
            operator = operator || "";
            lftPrn = lftPrn || lftPrn0 || lftPrn2;
            path = path || path2;
            // Could do this - but not worth perf cost?? :-
            // if (!path.lastIndexOf("#data.", 0)) { path = path.slice(6); } // If path starts with "#data.", remove that.
            prn = prn || prn2 || "";

            var expr, exprFn, binds, theOb, newOb,
                rtSq = ")";

            if (prn === "[") {
                prn = "[j._sq(";
                rtSq = ")]";
            }

            if (err && !aposed && !quoted) {
                syntaxError(params);
            } else {
                if (bindings && rtPrnDot && !aposed && !quoted) {
                    // This is a binding to a path in which an object is returned by a helper/data function/expression, e.g. foo()^x.y or (a?b:c)^x.y
                    // We create a compiled function to get the object instance (which will be called when the dependent data of the subexpression changes, to return the new object, and trigger re-binding of the subsequent path)
                    if (!named || boundName || bindto) {
                        expr = pathStart[parenDepth - 1];
                        if (full.length - 1 > index - (expr || 0)) { // We need to compile a subexpression
                            expr = full.slice(expr, index + all.length);
                            if (exprFn !== true) { // If not reentrant call during compilation
                                binds = bindto || bndStack[parenDepth - 1].bd;
                                // Insert exprOb object, to be used during binding to return the computed object
                                theOb = binds[binds.length - 1];
                                if (theOb && theOb.prm) {
                                    while (theOb.sb && theOb.sb.prm) {
                                        theOb = theOb.sb;
                                    }
                                    newOb = theOb.sb = { path: theOb.sb, bnd: theOb.bnd };
                                } else {
                                    binds.push(newOb = { path: binds.pop() }); // Insert exprOb object, to be used during binding to return the computed object
                                }											 // (e.g. "some.object()" in "some.object().a.b" - to be used as context for binding the following tokens "a.b")
                            }
                            rtPrnDot = delimOpenChar1 + ":" + expr // The parameter or function subexpression
                                + " onerror=''" // set onerror='' in order to wrap generated code with a try catch - returning '' as object instance if there is an error/missing parent
                                + delimCloseChar0;
                            exprFn = tmplLinks[rtPrnDot];
                            if (!exprFn) {
                                tmplLinks[rtPrnDot] = true; // Flag that this exprFn (for rtPrnDot) is being compiled
                                tmplLinks[rtPrnDot] = exprFn = tmplFn(rtPrnDot, tmpl, true); // Compile the expression (or use cached copy already in tmpl.links)
                            }
                            if (exprFn !== true && newOb) {
                                // If not reentrant call during compilation
                                newOb._jsv = exprFn;
                                newOb.prm = bndCtx.bd;
                                newOb.bnd = newOb.bnd || newOb.path && newOb.path.indexOf("^") >= 0;
                            }
                        }
                    }
                }
                return (aposed
                    // within single-quoted string
                    ? (aposed = !apos, (aposed ? all : lftPrn2 + '"'))
                    : quoted
                    // within double-quoted string
                        ? (quoted = !quot, (quoted ? all : lftPrn2 + '"'))
                        :
                    (
                        (lftPrn
                            ? (pathStart[parenDepth] = index++, bndCtx = bndStack[++parenDepth] = { bd: [] }, lftPrn)
                            : "")
                        + (space
                            ? (parenDepth
                                ? ""
                    // New arg or prop - so insert backspace \b (\x08) as separator for named params, used subsequently by rBuildHash, and prepare new bindings array
                                : (paramIndex = full.slice(paramIndex, index), named
                                    ? (named = boundName = bindto = false, "\b")
                                    : "\b,") + paramIndex + (paramIndex = index + all.length, bindings && pathBindings.push(bndCtx.bd = []), "\b")
                            )
                            : eq
                    // named param. Remove bindings for arg and create instead bindings array for prop
                                ? (parenDepth && syntaxError(params), bindings && pathBindings.pop(), named = path, boundName = bound, paramIndex = index + all.length, bound && (bindings = bndCtx.bd = pathBindings[named] = []), path + ':')
                                : path
                    // path
                                    ? (path.split("^").join(".").replace(rPath, parsePath)
                                        + (prn
                    // some.fncall(
                                            ? (bndCtx = bndStack[++parenDepth] = { bd: [] }, fnCall[parenDepth] = rtSq, prn)
                                            : operator)
                                    )
                                    : operator
                    // operator
                                        ? operator
                                        : rtPrn
                    // function
                                            ? ((rtPrn = fnCall[parenDepth] || rtPrn, fnCall[parenDepth] = false, bndCtx = bndStack[--parenDepth], rtPrn)
                                                + (prn // rtPrn and prn, e.g )( in (a)() or a()(), or )[ in a()[]
                                                    ? (bndCtx = bndStack[++parenDepth], fnCall[parenDepth] = rtSq, prn)
                                                    : "")
                                            )
                                            : comma
                                                ? (fnCall[parenDepth] || syntaxError(params), ",") // We don't allow top-level literal arrays or objects
                                                : lftPrn0
                                                    ? ""
                                                    : (aposed = apos, quoted = quot, '"')
                    ))
                );
            }
        }

        var named, bindto, boundName,
            quoted, // boolean for string content in double quotes
            aposed, // or in single quotes
            bindings = pathBindings && pathBindings[0], // bindings array for the first arg
            bndCtx = { bd: bindings },
            bndStack = { 0: bndCtx },
            paramIndex = 0, // list,
            tmplLinks = (tmpl ? tmpl.links : bindings && (bindings.links = bindings.links || {})) || topView.tmpl.links,
            // The following are used for tracking path parsing including nested paths, such as "a.b(c^d + (e))^f", and chained computed paths such as
            // "a.b().c^d().e.f().g" - which has four chained paths, "a.b()", "^c.d()", ".e.f()" and ".g"
            parenDepth = 0,
            fnCall = {}, // We are in a function call
            pathStart = {}, // tracks the start of the current path such as c^d() in the above example
            result = (params + (tmpl ? " " : "")).replace(rParams, parseTokens);

        return !parenDepth && result || syntaxError(params); // Syntax error if unbalanced parens in params expression
    }

    function buildCode(ast, tmpl, isLinkExpr) {
        // Build the template function code from the AST nodes, and set as property on the passed-in template object
        // Used for compiling templates, and also by JsViews to build functions for data link expressions
        var i, node, tagName, converter, tagCtx, hasTag, hasEncoder, getsVal, hasCnvt, useCnvt, tmplBindings, pathBindings, params, boundOnErrStart, boundOnErrEnd,
            tagRender, nestedTmpls, tmplName, nestedTmpl, tagAndElses, content, markup, nextIsElse, oldCode, isElse, isGetVal, tagCtxFn, onError, tagStart, trigger,
            tmplBindingKey = 0,
            useViews = $subSettingsAdvanced.useViews || tmpl.useViews || tmpl.tags || tmpl.templates || tmpl.helpers || tmpl.converters,
            code = "",
            tmplOptions = {},
            l = ast.length;

        if ("" + tmpl === tmpl) {
            tmplName = isLinkExpr ? 'data-link="' + tmpl.replace(rNewLine, " ").slice(1, -1) + '"' : tmpl;
            tmpl = 0;
        } else {
            tmplName = tmpl.tmplName || "unnamed";
            if (tmpl.allowCode) {
                tmplOptions.allowCode = true;
            }
            if (tmpl.debug) {
                tmplOptions.debug = true;
            }
            tmplBindings = tmpl.bnds;
            nestedTmpls = tmpl.tmpls;
        }
        for (i = 0; i < l; i++) {
            // AST nodes: [0: tagName, 1: converter, 2: content, 3: params, 4: code, 5: onError, 6: trigger, 7:pathBindings, 8: contentMarkup]
            node = ast[i];

            // Add newline for each callout to t() c() etc. and each markup string
            if ("" + node === node) {
                // a markup string to be inserted
                code += '\n+"' + node + '"';
            } else {
                // a compiled tag expression to be inserted
                tagName = node[0];
                if (tagName === "*") {
                    // Code tag: {{* }}
                    code += ";\n" + node[1] + "\nret=ret";
                } else {
                    converter = node[1];
                    content = !isLinkExpr && node[2];
                    tagCtx = paramStructure(node[3], 'params') + '},' + paramStructure(params = node[4]);
                    onError = node[5];
                    trigger = node[6];
                    markup = node[8] && node[8].replace(rUnescapeQuotes, "$1");
                    if (isElse = tagName === "else") {
                        if (pathBindings) {
                            pathBindings.push(node[7]);
                        }
                    } else {
                        tmplBindingKey = 0;
                        if (tmplBindings && (pathBindings = node[7])) { // Array of paths, or false if not data-bound
                            pathBindings = [pathBindings];
                            tmplBindingKey = tmplBindings.push(1); // Add placeholder in tmplBindings for compiled function
                        }
                    }
                    useViews = useViews || params[1] || params[2] || pathBindings || /view.(?!index)/.test(params[0]);
                    // useViews is for perf optimization. For render() we only use views if necessary - for the more advanced scenarios.
                    // We use views if there are props, contextual properties or args with #... (other than #index) - but you can force
                    // using the full view infrastructure, (and pay a perf price) by opting in: Set useViews: true on the template, manually...
                    if (isGetVal = tagName === ":") {
                        if (converter) {
                            tagName = converter === HTML ? ">" : converter + tagName;
                        }
                    } else {
                        if (content) { // TODO optimize - if content.length === 0 or if there is a tmpl="..." specified - set content to null / don't run this compilation code - since content won't get used!!
                            // Create template object for nested template
                            nestedTmpl = tmplObject(markup, tmplOptions);
                            nestedTmpl.tmplName = tmplName + "/" + tagName;
                            // Compile to AST and then to compiled function
                            nestedTmpl.useViews = nestedTmpl.useViews || useViews;
                            buildCode(content, nestedTmpl);
                            useViews = nestedTmpl.useViews;
                            nestedTmpls.push(nestedTmpl);
                        }

                        if (!isElse) {
                            // This is not an else tag.
                            tagAndElses = tagName;
                            useViews = useViews || tagName && (!$tags[tagName] || !$tags[tagName].flow);
                            // Switch to a new code string for this bound tag (and its elses, if it has any) - for returning the tagCtxs array
                            oldCode = code;
                            code = "";
                        }
                        nextIsElse = ast[i + 1];
                        nextIsElse = nextIsElse && nextIsElse[0] === "else";
                    }
                    tagStart = onError ? ";\ntry{\nret+=" : "\n+";
                    boundOnErrStart = "";
                    boundOnErrEnd = "";

                    if (isGetVal && (pathBindings || trigger || converter && converter !== HTML)) {
                        // For convertVal we need a compiled function to return the new tagCtx(s)
                        tagCtxFn = new Function("data,view,j,u", " // " + tmplName + " " + tmplBindingKey + " " + tagName
                                            + "\nreturn {" + tagCtx + "};");
                        tagCtxFn._er = onError;
                        tagCtxFn._tag = tagName;

                        if (isLinkExpr) {
                            return tagCtxFn;
                        }

                        setPaths(tagCtxFn, pathBindings);
                        tagRender = 'c("' + converter + '",view,';
                        useCnvt = true;
                        boundOnErrStart = tagRender + tmplBindingKey + ",";
                        boundOnErrEnd = ")";
                    }
                    code += (isGetVal
                        ? (isLinkExpr ? (onError ? "try{\n" : "") + "return " : tagStart) + (useCnvt // Call _cnvt if there is a converter: {{cnvt: ... }} or {^{cnvt: ... }}
                            ? (useCnvt = undefined, useViews = hasCnvt = true, tagRender + (pathBindings
                                ? ((tmplBindings[tmplBindingKey - 1] = tagCtxFn), tmplBindingKey) // Store the compiled tagCtxFn in tmpl.bnds, and pass the key to convertVal()
                                : "{" + tagCtx + "}") + ")")
                            : tagName === ">"
                                ? (hasEncoder = true, "h(" + params[0] + ")")
                                : (getsVal = true, "((v=" + params[0] + ')!=null?v:' + (isLinkExpr ? 'null)' : '"")'))
                                // Non strict equality so data-link="title{:expr}" with expr=null/undefined removes title attribute
                        )
                        : (hasTag = true, "\n{view:view,tmpl:" // Add this tagCtx to the compiled code for the tagCtxs to be passed to renderTag()
                            + (content ? nestedTmpls.length : "0") + "," // For block tags, pass in the key (nestedTmpls.length) to the nested content template
                            + tagCtx + "},"));

                    if (tagAndElses && !nextIsElse) {
                        // This is a data-link expression or an inline tag without any elses, or the last {{else}} of an inline tag
                        // We complete the code for returning the tagCtxs array
                        code = "[" + code.slice(0, -1) + "]";
                        tagRender = 't("' + tagAndElses + '",view,this,';
                        if (isLinkExpr || pathBindings) {
                            // This is a bound tag (data-link expression or inline bound tag {^{tag ...}}) so we store a compiled tagCtxs function in tmp.bnds
                            code = new Function("data,view,j,u", " // " + tmplName + " " + tmplBindingKey + " " + tagAndElses + "\nreturn " + code + ";");
                            code._er = onError;
                            code._tag = tagAndElses;
                            if (pathBindings) {
                                setPaths(tmplBindings[tmplBindingKey - 1] = code, pathBindings);
                            }
                            if (isLinkExpr) {
                                return code; // For a data-link expression we return the compiled tagCtxs function
                            }
                            boundOnErrStart = tagRender + tmplBindingKey + ",undefined,";
                            boundOnErrEnd = ")";
                        }

                        // This is the last {{else}} for an inline tag.
                        // For a bound tag, pass the tagCtxs fn lookup key to renderTag.
                        // For an unbound tag, include the code directly for evaluating tagCtxs array
                        code = oldCode + tagStart + tagRender + (tmplBindingKey || code) + ")";
                        pathBindings = 0;
                        tagAndElses = 0;
                    }
                    if (onError) {
                        useViews = true;
                        code += ';\n}catch(e){ret' + (isLinkExpr ? "urn " : "+=") + boundOnErrStart + 'j._err(e,view,' + onError + ')' + boundOnErrEnd + ';}' + (isLinkExpr ? "" : 'ret=ret');
                    }
                }
            }
        }
        // Include only the var references that are needed in the code
        code = "// " + tmplName

            + "\nvar v"
            + (hasTag ? ",t=j._tag" : "")                // has tag
            + (hasCnvt ? ",c=j._cnvt" : "")              // converter
            + (hasEncoder ? ",h=j._html" : "")           // html converter
            + (isLinkExpr ? ";\n" : ',ret=""\n')
            + (tmplOptions.debug ? "debugger;" : "")
            + code
            + (isLinkExpr ? "\n" : ";\nreturn ret;");

        if ($subSettings.debugMode !== false) {
            code = "try {\n" + code + "\n}catch(e){\nreturn j._err(e, view);\n}";
        }

        try {
            code = new Function("data,view,j,u", code);
        } catch (e) {
            syntaxError("Compiled template code:\n\n" + code + '\n: "' + e.message + '"');
        }
        if (tmpl) {
            tmpl.fn = code;
            tmpl.useViews = !!useViews;
        }
        return code;
    }

    //==========
    // Utilities
    //==========

    // Merge objects, in particular contexts which inherit from parent contexts
    function extendCtx(context, parentContext) {
        // Return copy of parentContext, unless context is defined and is different, in which case return a new merged context
        // If neither context nor parentContext are defined, return undefined
        return context && context !== parentContext
            ? (parentContext
                ? $extend($extend({}, parentContext), context)
                : context)
            : parentContext && $extend({}, parentContext);
    }

    // Get character entity for HTML and Attribute encoding
    function getCharEntity(ch) {
        return charEntities[ch] || (charEntities[ch] = "&#" + ch.charCodeAt(0) + ";");
    }

    function getTargetProps(source) {
        // this pointer is theMap - which has tagCtx.props too
        // arguments: tagCtx.args.
        var key, prop,
            props = [];

        if (typeof source === OBJECT) {
            for (key in source) {
                prop = source[key];
                if (key !== $expando && source.hasOwnProperty(key) && !$isFunction(prop)) {
                    props.push({ key: key, prop: prop });
                }
            }
        }
        return props;
    }

    function $fnRender(data, context, noIteration) {
        var tmplElem = this.jquery && (this[0] || error('Unknown template: "' + this.selector + '"')),
            tmpl = tmplElem.getAttribute(tmplAttr);

        return renderContent.call(tmpl ? $.data(tmplElem)[jsvTmpl] : $templates(tmplElem), data, context, noIteration);
    }

    //========================== Register converters ==========================

    function htmlEncode(text) {
        // HTML encode: Replace < > & ' and " by corresponding entities.
        return text != undefined ? rIsHtml.test(text) && ("" + text).replace(rHtmlEncode, getCharEntity) || text : "";
    }

    //========================== Initialize ==========================

    $sub = $views.sub;
    $viewsSettings = $views.settings;

    if (!(jsr || $ && $.render)) {
        // JsRender not already loaded, or loaded without jQuery, and we are now moving from jsrender namespace to jQuery namepace
        for (jsvStoreName in jsvStores) {
            registerStore(jsvStoreName, jsvStores[jsvStoreName]);
        }

        $converters = $views.converters;
        $helpers = $views.helpers;
        $tags = $views.tags;

        $sub._tg.prototype = {
            baseApply: baseApply,
            cvtArgs: convertArgs
        };

        topView = $sub.topView = new View();

        //BROWSER-SPECIFIC CODE
        if ($) {

            ////////////////////////////////////////////////////////////////////////////////////////////////
            // jQuery (= $) is loaded

            $.fn.render = $fnRender;
            $expando = $.expando;
            if ($.observable) {
                $extend($sub, $.views.sub); // jquery.observable.js was loaded before jsrender.js
                $views.map = $.views.map;
            }

        } else {
            ////////////////////////////////////////////////////////////////////////////////////////////////
            // jQuery is not loaded.

            $ = {};

            if (setGlobals) {
                global.jsrender = $; // We are loading jsrender.js from a script element, not AMD or CommonJS, so set global
            }

            // Error warning if jsrender.js is used as template engine on Node.js (e.g. Express or Hapi...)
            // Use jsrender-node.js instead...
            $.renderFile = $.__express = $.compile = function () { throw "Node.js: use npm jsrender, or jsrender-node.js"; };

            //END BROWSER-SPECIFIC CODE
            $.isFunction = function (ob) {
                return typeof ob === "function";
            };

            $.isArray = Array.isArray || function (obj) {
                return ({}.toString).call(obj) === "[object Array]";
            };

            $sub._jq = function (jq) { // private method to move from JsRender APIs from jsrender namespace to jQuery namespace
                if (jq !== $) {
                    $extend(jq, $); // map over from jsrender namespace to jQuery namespace
                    $ = jq;
                    $.fn.render = $fnRender;
                    delete $.jsrender;
                    $expando = $.expando;
                }
            };

            $.jsrender = versionNumber;
        }
        $subSettings = $sub.settings;
        $subSettings.allowCode = false;
        $isFunction = $.isFunction;
        $.render = $render;
        $.views = $views;
        $.templates = $templates = $views.templates;

        for (setting in $subSettings) {
            addSetting(setting);
        }

        ($viewsSettings.debugMode = function (debugMode) {
            return debugMode === undefined
                ? $subSettings.debugMode
                : (
                    $subSettings.debugMode = debugMode,
                    $subSettings.onError = debugMode + "" === debugMode
                        ? new Function("", "return '" + debugMode + "';")
                        : $isFunction(debugMode)
                            ? debugMode
                            : undefined,
                    $viewsSettings);
        })(false); // jshint ignore:line

        $subSettingsAdvanced = $subSettings.advanced = {
            useViews: false,
            _jsv: false // For global access to JsViews store
        };

        //========================== Register tags ==========================

        $tags({
            "if": {
                render: function (val) {
                    // This function is called once for {{if}} and once for each {{else}}.
                    // We will use the tag.rendering object for carrying rendering state across the calls.
                    // If not done (a previous block has not been rendered), look at expression for this block and render the block if expression is truthy
                    // Otherwise return ""
                    var self = this,
                        tagCtx = self.tagCtx,
                        ret = (self.rendering.done || !val && (arguments.length || !tagCtx.index))
                            ? ""
                            : (self.rendering.done = true, self.selected = tagCtx.index,
                                // Test is satisfied, so render content on current context. We call tagCtx.render() rather than return undefined
                                // (which would also render the tmpl/content on the current context but would iterate if it is an array)
                                tagCtx.render(tagCtx.view, true)); // no arg, so renders against parentView.data
                    return ret;
                },
                flow: true
            },
            "for": {
                render: function (val) {
                    // This function is called once for {{for}} and once for each {{else}}.
                    // We will use the tag.rendering object for carrying rendering state across the calls.
                    var finalElse = !arguments.length,
                        value,
                        self = this,
                        tagCtx = self.tagCtx,
                        result = "",
                        done = 0;

                    if (!self.rendering.done) {
                        value = finalElse ? tagCtx.view.data : val; // For the final else, defaults to current data without iteration.
                        if (value !== undefined) {
                            result += tagCtx.render(value, finalElse); // Iterates except on final else, if data is an array. (Use {{include}} to compose templates without array iteration)
                            done += $isArray(value) ? value.length : 1;
                        }
                        if (self.rendering.done = done) {
                            self.selected = tagCtx.index;
                        }
                        // If nothing was rendered we will look at the next {{else}}. Otherwise, we are done.
                    }
                    return result;
                },
                flow: true
            },
            props: {
                baseTag: "for",
                dataMap: dataMap(getTargetProps),
                flow: true
            },
            include: {
                flow: true
            },
            "*": {
                // {{* code... }} - Ignored if template.allowCode and $.views.settings.allowCode are false. Otherwise include code in compiled template
                render: retVal,
                flow: true
            },
            ":*": {
                // {{:* returnedExpression }} - Ignored if template.allowCode and $.views.settings.allowCode are false. Otherwise include code in compiled template
                render: retVal,
                flow: true
            },
            dbg: $helpers.dbg = $converters.dbg = dbgBreak // Register {{dbg/}}, {{dbg:...}} and ~dbg() to throw and catch, as breakpoints for debugging.
        });

        $converters({
            html: htmlEncode,
            attr: htmlEncode, // Includes > encoding since rConvertMarkers in JsViews does not skip > characters in attribute strings
            url: function (text) {
                // URL encoding helper.
                return text != undefined ? encodeURI("" + text) : text === null ? text : ""; // null returns null, e.g. to remove attribute. undefined returns ""
            }
        });
    }
    //========================== Define default delimiters ==========================
    $subSettings = $sub.settings;
    $isArray = ($ || jsr).isArray;
    $viewsSettings.delimiters("{{", "}}", "^");

    if (jsrToJq) { // Moving from jsrender namespace to jQuery namepace - copy over the stored items (templates, converters, helpers...)
        jsr.views.sub._jq($);
    }

    //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< JsObservable >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    /* JsObservable:
     * See http://www.jsviews.com/#jsobservable and http://github.com/borismoore/jsviews
     * Copyright 2016, Boris Moore
     * Released under the MIT License.
     */

    //========================== Top-level vars ==========================

    $views = $.views;
    $sub = $views.sub;
    $isFunction = $.isFunction;
    $isArray = $.isArray;
    $expando = $.expando;
    if (!$.observe) {

        var $eventSpecial = $.event.special,
            slice = [].slice,
            splice = [].splice,
            concat = [].concat,
            PARSEINT = parseInt,
            rNotWhite = /\S+/g,
            propertyChangeStr = $sub.propChng = $sub.propChng || "propertyChange",// These two settings can be overridden on settings after loading
            arrayChangeStr = $sub.arrChng = $sub.arrChng || "arrayChange",        // jsRender, and prior to loading jquery.observable.js and/or JsViews
            cbBindingsStore = {},
            observeStr = propertyChangeStr + ".observe",
            observeObjKey = 1,
            observeCbKey = 1,
            observeInnerCbKey = 1,
            $hasData = $.hasData,
            $data = $.data,
            remove = {}, // flag for removeProperty

        //========================== Top-level functions ==========================

        getCbKey = function (cb) {
            return cb._cId = cb._cId || (".obs" + observeCbKey++);
        },

        ObjectObservable = function (ns, data) {
            this._data = data;
            this._ns = ns;
            return this;
        },

        ArrayObservable = function (ns, data) {
            this._data = data;
            this._ns = ns;
            return this;
        },

        wrapArray = function (data) {
            return $isArray(data)
                ? [data]
                : data;
        },

        resolvePathObjects = function (paths, root, callback) {
            paths = paths
                ? $isArray(paths)
                    ? paths
                    : [paths]
                : [];

            var i, path,
                object = root,
                nextObj = object,
                l = paths && paths.length,
                out = [];

            for (i = 0; i < l; i++) {
                path = paths[i];
                if ($isFunction(path)) {
                    out = out.concat(resolvePathObjects(path.call(root, root, callback), root));
                    continue;
                } else if ("" + path !== path) {
                    root = nextObj = path;
                    if (nextObj !== object) {
                        out.push(object = nextObj);
                    }
                    continue;
                }
                if (nextObj !== object) {
                    out.push(object = nextObj);
                }
                out.push(path);
            }
            return out;
        },

        removeCbBindings = function (cbBindings, cbBindingsId) {
            // If the cbBindings collection is empty we will remove it from the cbBindingsStore
            for (var cb in cbBindings) {
                return;
            }
            delete cbBindingsStore[cbBindingsId]; // This binding collection is empty, so remove from store
        },

        onObservableChange = function (ev, eventArgs) {
            function isOb(val) {
                return typeof val === OBJECT && (paths[0] || allowArray && $isArray(val));
            }

            if (!(ev.data && ev.data.off)) {
                // Skip if !!ev.data.off: - a handler that has already been removed (maybe was on handler collection at call time - then removed by another handler)
                var allPath, filter, parentObs,
                    oldValue = eventArgs.oldValue,
                    value = eventArgs.value,
                    ctx = ev.data,
                    observeAll = ctx.observeAll,
                    cb = ctx.cb,
                    allowArray = !cb.noArray,
                    paths = ctx.paths,
                    ns = ctx.ns;

                if (ev.type === arrayChangeStr) {
                    (cb.array || cb).call(ctx, ev, eventArgs); // If there is an arrayHandler expando on the regular handler, use it, otherwise use the regular handler for arrayChange events also - for example: $.observe(array, handler)
                    // or observeAll() with an array in the graph. Note that on data-link bindings we ensure always to have an array handler - $.noop if none is specified e.g. on the data-linked tag.
                } else if (ctx.prop === eventArgs.path || ctx.prop === "*") {
                    if (observeAll) {
                        allPath = observeAll._path + "." + eventArgs.path;
                        filter = observeAll.filter;
                        parentObs = [ev.target].concat(observeAll.parents());

                        if (isOb(oldValue)) {
                            observe_apply(allowArray, ns, [oldValue], paths, cb, true, filter, [parentObs], allPath); // unobserve
                        }
                        if (isOb(value)) {
                            observe_apply(allowArray, ns, [value], paths, cb, undefined, filter, [parentObs], allPath);
                        }
                    } else {
                        if (isOb(oldValue)) { // oldValue is an object, so unobserve
                            observe_apply(allowArray, ns, [oldValue], paths, cb, true); // unobserve
                        }
                        if (isOb(value)) { // value is an object, so observe
                            observe_apply(allowArray, ns, [value], paths, cb);
                        }
                    }
                    ctx.cb(ev, eventArgs);
                }
            }
        },

        observe_apply = function () {
            // $.observe(), but allowing you to include arrays within the arguments - which you want flattened.
            var args = concat.apply([], arguments); // Flatten the arguments
            return $observe.apply(args.shift(), args);
        },

        $observeAll = function (cb, filter, unobserve) {
            observeAll(this._ns, this._data, cb, filter, [], "root", unobserve);
        },

        $unobserveAll = function (cb, filter) {
            $observeAll.call(this, cb, filter, true);
        },

        observeAll = function (namespace, object, cb, filter, parentObs, allPath, unobserve, objMap) {
            function observeArrayItems(arr, unobs) {
                l = arr.length;
                newAllPath = allPath + "[]";
                while (l--) {
                    filterAndObserveAll(arr, l, unobs, 1);
                }
            }

            function filterAndObserveAll(obj, prop, unobs, nestedArray) {
                var newObject, newParentObs;
                if (prop !== $expando) {
                    if (newObject = $observable._fltr(newAllPath, obj[prop], nextParentObs, filter)) {
                        newParentObs = nextParentObs.slice();
                        if (nestedArray && updatedTgt && newParentObs[0] !== updatedTgt) {
                            newParentObs.unshift(updatedTgt); // For array change events when observing an array which is not the root, need to add updated array to parentObs
                        }
                        observeAll(namespace, newObject, cb, filter || (nestedArray ? undefined : 0), newParentObs, newAllPath, unobs, objMap);
                        // If nested array, need to observe the array too - so set filter to undefined
                    }
                }
            }

            function wrappedCb(ev, eventArgs) {
                // This object is changing.
                allPath = ev.data.observeAll._path;
                updatedTgt = ev.target;
                switch (eventArgs.change) { // observeAll/unobserveAll on added or removed objects
                    case "insert":
                        observeArrayItems(eventArgs.items);
                        break;
                    case "remove":
                        observeArrayItems(eventArgs.items, true); // unobserveAll on removed items
                        break;
                    case "set":
                        newAllPath = allPath + "." + eventArgs.path;
                        filterAndObserveAll(eventArgs, "oldValue", true); // unobserve old value
                        filterAndObserveAll(eventArgs, "value"); // observe new value
                }
                updatedTgt = undefined;
                cb.apply(this, arguments); // Observe this object (invoke the callback)
            }

            var l, isObject, newAllPath, nextParentObs, updatedTgt, obId,
                notRemoving = !objMap || objMap.un || !unobserve; // true unless it is an observeAll call (not unobserveAll) and we are removing a listener (not adding one)

            if (object && typeof object === OBJECT) {
                nextParentObs = [object].concat(parentObs); // The parentObs chain for the next depth of observeAll
                isObject = $isArray(object) ? "" : "*";
                if (objMap && notRemoving && $hasData(object) && objMap[obId = $data(object).obId]) {
                    objMap[obId]++;
                    return; // This object has already being observed/unobserved by this observeAll/unobserveAll call (must be a cyclic object graph) so skip, to avoid
                    // stack overflow/multiple instances of listener. See jsviews/pull/305
                    // NOTE - WE DO NOT support ObserveAll on data with cyclic graphs which include DUPLICATE REFERENCES TO ARRAY PROPERTIES - such as data.children = data.descendants = []
                }
                if (!objMap) {
                    objMap = { un: unobserve }; // Map object to register observed objects for this observeAll
                }

                if (cb) {
                    // Observe this object or array - and also listen for changes to object graph, to add or remove observers from the modified object graph
                    if (isObject || filter !== 0) {
                        // If an object, observe the object. If an array, only add arrayChange binding if has filter or if filter is undefined (!== 0) - which
                        // is the case for top-level calls or for nested array (array item of an array - e.g. member of 2-dimensional array).
                        // For array properties lower in the tree, with no filter, filter is set to 0 in filterAndObserveAll, so no arrayChange binding here,
                        // since they get arrayChange binding added during regular $.observe(array ...) binding.
                        wrappedCb._cId = getCbKey(cb); // Identify wrapped callback with unwrapped callback, so unobserveAll will
                        // remove previous observeAll wrapped callback, if inner callback was the same;
                        if (notRemoving) {
                            $observe(namespace, object, isObject, wrappedCb, unobserve, filter, nextParentObs, allPath);
                            obId = $data(object).obId;
                            objMap[obId] = (objMap[obId] || 0) + 1; // Register on map of objects observed/unobserved by this observeAll/unobserveAll call
                            //- or remove from map if we are removing this object from observeAll call. (Avoid dups, for cyclic graphs)
                        } else {
                            if (--objMap[$data(object).obId]) {
                                // Register on map of objects observed/unobserved by this observeAll/unobserveAll call
                                //- or remove from map if we are removing this object from observeAll call. (Avoid dups, for cyclic graphs)
                                return;
                            }
                            $observe(namespace, object, isObject, wrappedCb, unobserve, filter, nextParentObs, allPath);
                        }
                    }
                } else {
                    // No callback. Just unobserve if unobserve === true.
                    if (objMap) {
                        objMap[$data(object).obId] = 1; // Register on map of objects unobserved by this unobserveAll call. (Avoid dups, for cyclic graphs)
                    }
                    $observe(namespace, object, isObject, undefined, unobserve, filter, nextParentObs, allPath);
                }

                if (isObject) {
                    // Continue stepping through object graph, observing object and arrays
                    // To override filtering, pass in filter function, or replace $.observable._fltr
                    for (l in object) {
                        newAllPath = allPath + "." + l;
                        filterAndObserveAll(object, l, unobserve);
                    }
                } else { // Observe items in Array
                    observeArrayItems(object, unobserve);
                }
            }
        },

        shallowFilter = function (allPath /*, object, parentObs*/) {
            return allPath.indexOf(".") < 0 && allPath.indexOf("[") < 0;
        },

        $unobserve = function () {
            [].push.call(arguments, true); // Add true as additional final argument
            return $observe.apply(this, arguments);
        };

        $observe = function () {
            // $.observe([namespace, ]root, [1 or more objects, path or path Array params...], callback[, contextCallback][, unobserve])

            function innerObserve() {

                function observeOnOff(namespace, pathStr, isArrayBinding, off) {
                    var j, evData,
                        obIdExpando = $hasData(object),
                        boundObOrArr = wrapArray(object),
                        prntObs = parentObs,
                        allPth = allPath;

                    namespace = initialNs ? namespace + "." + initialNs : namespace;

                    if (!unobserve && (off || isArrayBinding)) {
                        events = obIdExpando && $._data(object);
                        events = events && events.events;
                        events = events && events[isArrayBinding ? arrayChangeStr : propertyChangeStr];
                        el = events && events.length;
                        while (el--) { // Skip duplicates
                            data = events[el] && events[el].data;
                            if (data && (off && data.ns !== initialNs
                                // When observing, don't unbind dups unless they have the same namespace
                                || !off && data.ns === initialNs && data.cb && data.cb._cId === callback._cId))
                                // When observing and doing array binding, don't bind dups if they have the same namespace (Dups can happen e.g. with {^{for people ~foo=people}})
                            {
                                return;
                            }
                        }
                    }
                    if (unobserve || off) {
                        $(boundObOrArr).off(namespace, onObservableChange);
                    } else {
                        evData = isArrayBinding ? {}
                            : {
                                fullPath: path,
                                paths: pathStr ? [pathStr] : [],
                                prop: prop
                            };
                        evData.ns = initialNs;
                        evData.cb = callback;

                        if (allPath) {
                            // This is an observeAll call
                            evData.observeAll = {
                                _path: allPth,
                                path: function () { // Step through path and parentObs parent chain, replacing '[]' by '[n]' based on current index of objects in parent arrays.
                                    j = prntObs.length;
                                    return allPth.replace(/[[.]/g, function (all) {
                                        j--;
                                        return all === "["
                                            ? "[" + $.inArray(prntObs[j - 1], prntObs[j])
                                            : ".";
                                    });
                                },
                                parents: function () {
                                    return prntObs; // The chain of parents between the modified object and the root object used in the observeAll() call
                                },
                                filter: filter
                            };
                        }
                        $(boundObOrArr).on(namespace, null, evData, onObservableChange);
                        if (cbBindings) {
                            // Add object to cbBindings
                            cbBindings[$data(object).obId || $data(object, "obId", observeObjKey++)] = object;
                        }
                    }
                }

                function getInnerCb(exprOb) {
                    // Returns the innerCb used for updating a computed in a compiled expression (setting the new instance as exprOb.ob, unobserving the previous object,
                    // and observing the new one), then calling the outerCB - i.e. the handler for the whole compiled expression.
                    // Initialized exprOb.ob to the current object.
                    // Uses the contextCb callback to execute the compiled exprOb template in the context of the view/data etc. to get the returned value, typically an object or array.
                    // If it is an array, registers array binding
                    var origRt = root;
                    // Note: For jsviews/issues/292 ctxCb will need var ctxCb = contextCb || function(exprOb, origRt) {return exprOb._jsv(origRt);};

                    exprOb.ob = contextCb(exprOb, origRt); // Initialize object

                    return exprOb.cb = function (ev, eventArgs) {
                        var obj = exprOb.ob, // The old object
                            sub = exprOb.sb,
                            newObj = contextCb(exprOb, origRt);

                        if (newObj !== obj) {
                            if (typeof obj === OBJECT) {
                                bindArray(obj, true);
                                if (sub || allowArray && $isArray(obj)) {
                                    innerObserve([obj], sub, callback, contextCb, true); // unobserve on the old object
                                }
                            }
                            exprOb.ob = newObj;
                            // Put the updated object instance onto the exprOb in the paths array, so subsequent string paths are relative to this object
                            if (typeof newObj === OBJECT) {
                                bindArray(newObj);
                                if (sub || allowArray && $isArray(newObj)) {
                                    // Register array binding
                                    innerObserve([newObj], sub, callback, contextCb);
                                }
                            }
                        }
                        // Call the outerCb - to execute the compiled expression that this computed is part of
                        callback(ev, eventArgs);
                    };
                }

                function bindArray(arr, unbind, isArray, relPath) {
                    if (allowArray) {
                        // This is a call to observe that does not come from observeAndBind (tag binding), so we allow arrayChange binding
                        var prevObj = object,
                            prevAllPath = allPath;

                        object = arr;
                        if (relPath) {
                            object = arr[relPath];
                            allPath += "." + relPath;
                        }
                        if (filter && object) {
                            object = $observable._fltr(allPath, object, relPath ? [arr].concat(parentObs) : parentObs, filter);
                        }
                        if (object && (isArray || $isArray(object))) {
                            observeOnOff(arrayChangeStr + ".observe" + (callback ? getCbKey(callback) : ""), undefined, true, unbind);
                        }
                        object = prevObj;
                        allPath = prevAllPath;
                    }
                }

                var i, p, skip, parts, prop, path, dep, unobserve, callback, cbId, inId, el, data, events, contextCb, items, cbBindings,
                    depth, innerCb, parentObs, allPath, filter, initNsArr, initNsArrLen,
                    ns = observeStr,
                    paths = this != 1 // Using != for IE<10 bug- see jsviews/issues/237
                        ? concat.apply([], arguments) // Flatten the arguments - this is a 'recursive call' with params using the 'wrapped array'
                                                        // style - such as innerObserve([object], path.path, [origRoot], path.prm, innerCb, ...);
                        : slice.call(arguments), // Don't flatten - this is the first 'top-level call, to innerObserve.apply(1, paths)
                    lastArg = paths.pop() || false,
                    root = paths.shift(),
                    object = root,
                    l = paths.length;

                if (lastArg + "" === lastArg) { // If last arg is a string then this observe call is part of an observeAll call,
                    allPath = lastArg;          // and the last three args are the parentObs array, the filter, and the allPath string.
                    parentObs = paths.pop();
                    filter = paths.pop();
                    lastArg = !!paths.pop(); // unobserve
                    l -= 3;
                }
                if (lastArg === !!lastArg) {
                    unobserve = lastArg;
                    lastArg = paths[l - 1];
                    lastArg = l && lastArg + "" !== lastArg && (!lastArg || $isFunction(lastArg)) ? (l--, paths.pop()) : undefined;
                    if (unobserve && !l && $isFunction(root)) {
                        lastArg = root;
                        root = undefined;
                    }
                }
                callback = lastArg;
                if (l && $isFunction(paths[l - 1])) {
                    contextCb = callback;
                    callback = paths.pop();
                    l--;
                }

                if (unobserve && callback && !callback._cId) {
                    return;
                }

                // Use a unique namespace (e.g. obs7) associated with each observe() callback to allow unobserve to remove handlers
                ns += callback
                    ? ((inId = callback._inId || ""), unobserve)
                        ? callback._cId + inId
                        : (cbId = getCbKey(callback)) + inId
                    : "";

                if (cbId && !unobserve) {
                    cbBindings = cbBindingsStore[cbId] = cbBindingsStore[cbId] || {};
                }

                initNsArr = initialNs && initialNs.match(rNotWhite) || [""];
                initNsArrLen = initNsArr.length;

                while (initNsArrLen--) {
                    initialNs = initNsArr[initNsArrLen];
                    if (root && (path = paths[0], !path || path + "" !== path)) {
                        if ($isArray(root)) {
                            bindArray(root, unobserve, true);
                        } else if (unobserve) {
                            // remove onObservableChange handlers that wrap that callback
                            observeOnOff(ns, "");
                        }
                    }
                    if (unobserve && !l && !root) { // unobserve() - unobserves all
                        for (p in cbBindingsStore) {
                            p = cbBindingsStore[p];
                            for (data in p) {
                                object = p[data];
                                if ($isArray(object)) {
                                    bindArray(object, unobserve, unobserve);
                                } else {
                                    // remove onObservableChange handlers that wrap that callback
                                    observeOnOff(ns, "");
                                }
                            }
                        }
                    }
                    depth = 0;
                    for (i = 0; i < l; i++) {
                        path = paths[i];
                        if (path === "") {
                            continue;
                        }
                        object = root;
                        if ("" + path === path) {
                            // Consider support for computed paths: jsviews/issues/292
                            //if (/[\(\[\+]/.test(path)) {
                            //	var b={links:{}}, t = $sub.tmplFn("{:"+path+"}", b, true), items = t.paths[0];
                            //	l += items.length - 1;
                            //	splice.apply(paths, [i--, 1].concat(items));
                            //	continue;
                            //}
                            parts = path.split("^");
                            if (parts[1]) {
                                // We bind the leaf, plus additional nodes based on depth.
                                // "a.b.c^d.e" is depth 2, so listens to changes of e, plus changes of d and of c
                                depth = parts[0].split(".").length;
                                path = parts.join(".");
                                depth = path.split(".").length - depth;
                                // if more than one ^ in the path, the first one determines depth
                            }
                            if (contextCb && (items = contextCb(path, root, depth))) {
                                // If the array of objects and paths returned by contextCb is non empty, insert them
                                // into the sequence, replacing the current item (path). Otherwise simply remove current item (path)
                                l += items.length - 1;
                                splice.apply(paths, [i--, 1].concat(items));
                                continue;
                            }
                            parts = path.split(".");
                        } else {
                            if (!$isFunction(path)) {
                                if (path && path._jsv) {
                                    // This is a compiled function for binding to an object returned by a helper/data function.
                                    // Set current object on exprOb.ob, and get innerCb for updating the object
                                    innerCb = unobserve ? path.cb : getInnerCb(path);
                                    innerCb.noArray = !allowArray;
                                    // innerCb._ctx = callback._ctx; Could pass context (e.g. linkCtx) for use in a depends = function() {} call, so depends is different for different linkCtx's
                                    innerCb._cId = callback._cId;
                                    // Set the same cbBindingsStore key as for callback, so when callback is disposed, disposal of innerCb happens too.
                                    innerCb._inId = innerCb._inId || ".obIn" + observeInnerCbKey++;
                                    if (path.bnd || path.prm && path.prm.length || !path.sb) {
                                        // If the exprOb is bound e.g. foo()^sub.path, or has parameters e.g. foo(bar) or is a leaf object (so no sub path) e.g. foo()
                                        // then observe changes on the object, or its parameters and sub-path
                                        innerObserve([object], path.path, [origRoot], path.prm, innerCb, contextCb, unobserve);
                                    }
                                    if (path.sb) { // subPath
                                        innerObserve([path.ob], path.sb, callback, contextCb, unobserve);
                                    }
                                    path = origRoot;
                                    object = undefined;
                                } else {
                                    object = path; // For top-level calls, objects in the paths array become the origRoot for subsequent paths.
                                }
                            }
                            parts = [root = path];
                        }
                        while (object && (prop = parts.shift()) !== undefined) {
                            if (typeof object === OBJECT) {
                                if ("" + prop === prop) {
                                    if (prop === "") {
                                        continue;
                                    }
                                    if ((parts.length < depth + 1) && !object.nodeType) {
                                        // Add observer for each token in path starting at depth, and on to the leaf
                                        if (!unobserve && (events = $hasData(object) && $._data(object))) {
                                            events = events.events;
                                            events = events && events[propertyChangeStr];
                                            el = events && events.length;
                                            skip = 0;
                                            while (el--) { // Skip duplicates
                                                data = events[el].data;
                                                if (data
                                                    && data.ns === initialNs
                                                    && data.cb._cId === callback._cId
                                                    && data.cb._inId === callback._inId
                                                    && (data.prop === prop || data.prop === "*" || data.prop === "**")) {
                                                    if (p = parts.join(".")) {
                                                        data.paths.push(p); // We will skip this binding, but if it is not a leaf binding,
                                                        // need to keep bindings for rest of path, ready for if the object gets swapped.
                                                    }
                                                    skip++;
                                                }
                                            }
                                            if (skip) {
                                                // Duplicate binding(s) found, so move on
                                                object = object[prop];
                                                continue;
                                            }
                                        }
                                        if (prop === "*" || prop === "**") { // "*" => all properties. "**" => all properties and sub-properties (i.e. deep observeAll behavior)
                                            if (!unobserve && events && events.length) {
                                                // Remove existing bindings, since they will be duplicates with "*" or "**"
                                                observeOnOff(ns, "", false, true);
                                            }
                                            if (prop === "*") {
                                                observeOnOff(ns, ""); // observe the object for any property change
                                                for (p in object) {
                                                    // observing "*": So (in addition to listening to prop change, above) listen to arraychange on props of type array
                                                    if (p !== $expando) {
                                                        bindArray(object, unobserve, undefined, p);
                                                    }
                                                }
                                            } else {
                                                $.observable(initialNs, object)[(unobserve ? "un" : "") + "observeAll"](callback); // observe or unobserve the object for any property change
                                            }
                                            break;
                                        } else if (prop) {
                                            observeOnOff(ns + ".p_" + prop, parts.join("^")); // By using "^" rather than "." we ensure that deep binding will be used on newly inserted object graphs
                                        }
                                    }
                                    if (allPath) {
                                        allPath += "." + prop;
                                    }
                                    prop = object[prop];
                                }
                                if ($isFunction(prop)) {
                                    if (dep = prop.depends) {
                                        // This is a computed observable. We will observe any declared dependencies
                                        innerObserve([object], resolvePathObjects(dep, object, callback), callback, contextCb, unobserve);
                                    }
                                    break;
                                }
                                object = prop;
                                if (unobserve && object === root && (i > l - 2 || paths[i + 1] + "" !== paths[i + 1])) {
                                    // unobserve all handlers of object, if not followed by string path.
                                    // e.g.$.unobserve(object1, object2, "path", object3) will unobserve all from object1 and object3, and just "path" listener from object2
                                    observeOnOff(ns, "");
                                }
                            }
                        }
                        bindArray(object, unobserve);
                    }
                }
                if (cbId) {
                    removeCbBindings(cbBindings, cbId);
                }

                // Return the cbBindings to the top-level caller, along with the cbId
                return { cbId: cbId, bnd: cbBindings };
            }

            var initialNs,
                allowArray = this != false, // If this === false, this is a call from observeAndBind - doing binding of datalink expressions. We don't bind
                // arrayChange events in this scenario. Instead, {^{for}} and similar do specific arrayChange binding to the tagCtx.args[0] value, in onAfterLink.
                // Note deliberately using this != false, rather than this !== false because of IE<10 bug- see jsviews/issues/237
                paths = slice.call(arguments),
                origRoot = paths[0];

            if (origRoot + "" === origRoot && allowArray) {
                initialNs = origRoot; // The first arg is a namespace, since it is a string, and this call is not from observeAndBind
                paths.shift();
                origRoot = paths[0];
            }

            return innerObserve.apply(1, paths);
        };

        $observable = function (ns, data) {
            if (arguments.length === 1) {
                data = ns;
                ns = "";
            }
            return $isArray(data)
                ? new ArrayObservable(ns, data)
                : new ObjectObservable(ns, data);
        };

        //========================== Initialize ==========================

        $sub.getDeps = function () {
            var args = arguments;
            return function () {
                var arg, dep,
                    deps = [],
                    l = args.length;
                while (l--) {
                    arg = args[l--];
                    dep = args[l];
                    if (dep) {
                        deps = deps.concat($isFunction(dep) ? dep(arg, arg) : dep);
                    }
                }
                return deps;
            };
        };

        $.observable = $observable;
        $observable._fltr = function (allPath, object, parentObs, filter) {
            if (filter && $isFunction(filter)
                ? filter(allPath, object, parentObs)
                : true // TODO Consider supporting filter being a string or strings to do RegEx filtering based on key and/or allPath
            ) {
                object = $isFunction(object)
                    ? object.set && object.call(parentObs[0]) // It is a getter/setter
                    : object;
                return typeof object === OBJECT && object;
            }
        };

        $observable.Object = ObjectObservable;
        $observable.Array = ArrayObservable;
        $.observe = $observable.observe = $observe;
        $.unobserve = $observable.unobserve = $unobserve;
        $observable._apply = observe_apply;

        ObjectObservable.prototype = {
            _data: null,

            observeAll: $observeAll,
            unobserveAll: $unobserveAll,

            data: function () {
                return this._data;
            },

            setProperty: function (path, value, nonStrict) {
                path = path || "";
                var key, pair, parts,
                    multi = path + "" !== path,
                    self = this,
                    object = self._data;

                if (object) {
                    if (multi) {
                        nonStrict = value;
                        if ($isArray(path)) {
                            // This is the array format generated by serializeArray. However, this has the problem that it coerces types to string,
                            // and does not provide simple support of convertTo and convertFrom functions.
                            key = path.length;
                            while (key--) {
                                pair = path[key];
                                self.setProperty(pair.name, pair.value, nonStrict === undefined || nonStrict); //If nonStrict not specified, default to true;
                            }
                        } else {
                            // Object representation where property name is path and property value is value.
                            for (key in path) {
                                self.setProperty(key, path[key], nonStrict);
                            }
                        }
                    } else if (path !== $expando) {
                        // Simple single property case.
                        parts = path.split(/[.^]/);
                        while (object && parts.length > 1) {
                            object = object[parts.shift()];
                        }
                        if (object) {
                            self._setProperty(object, parts[0], value, nonStrict);
                        }
                    }
                }
                return self;
            },

            removeProperty: function (path) {
                this.setProperty(path, remove);
                return this;
            },

            _setProperty: function (leaf, path, value, nonStrict) {
                var setter, getter, removeProp,
                    property = path ? leaf[path] : leaf;

                if ($isFunction(property)) {
                    if (property.set) {
                        // Case of property setter/getter - with convention that property is getter and property.set is setter
                        leaf = leaf._wrp  // Case of JsViews 2-way data-linking to a helper function as getter, with a setter.
                            // The view will be the this pointer for getter and setter. Note: this is the one scenario where path is "".
                            || leaf;
                        getter = property;
                        setter = getter.set === true ? getter : getter.set;
                        property = getter.call(leaf); // get - only treated as getter if also a setter. Otherwise it is simply a property of type function. See unit tests 'Can observe properties of type function'.
                    }
                }

                if (property !== value || nonStrict && property != value) { // Optional non-strict equality, since serializeArray, and form-based editors can map numbers to strings, etc.
                    // Date objects don't support != comparison. Treat as special case.
                    if (!(property instanceof Date) || property > value || property < value) {
                        if (setter) {
                            setter.call(leaf, value);   //set
                            value = getter.call(leaf);  //get updated value
                        } else if (removeProp = value === remove) {
                            if (property !== undefined) {
                                delete leaf[path];
                                value = undefined;
                            } else {
                                path = undefined; // If value was already undefined, don't trigger handler for removeProp
                            }
                        } else if (path) {
                            leaf[path] = value;
                        }
                        if (path) {
                            this._trigger(leaf, { change: "set", path: path, value: value, oldValue: property, remove: removeProp });
                        }
                    }
                }
            },

            _trigger: function (target, eventArgs) {
                $(target).triggerHandler(propertyChangeStr + (this._ns ? "." + /^\S+/.exec(this._ns)[0] : ""), eventArgs); // If white-space separated namespaces, use first one only
            }
        };

        ArrayObservable.prototype = {
            _data: null,

            observeAll: $observeAll,
            unobserveAll: $unobserveAll,

            data: function () {
                return this._data;
            },

            insert: function (index, data) {
                var _data = this._data;
                if (arguments.length === 1) {
                    data = index;
                    index = _data.length;
                }
                index = PARSEINT(index);
                if (index > -1) {
                    data = $isArray(data) ? data : [data];
                    // data can be a single item (including a null/undefined value) or an array of items.
                    // Note the provided items are inserted without being cloned, as direct references to the provided objects

                    if (data.length) {
                        this._insert(index, data);
                    }
                }
                return this;
            },

            _insert: function (index, data) {
                var _data = this._data,
                    oldLength = _data.length;
                if (index > oldLength) {
                    index = oldLength;
                }
                splice.apply(_data, [index, 0].concat(data));
                this._trigger({ change: "insert", index: index, items: data }, oldLength);
            },

            remove: function (index, numToRemove) {
                var items,
                    _data = this._data;

                if (index === undefined) {
                    index = _data.length - 1;
                }

                index = PARSEINT(index);
                numToRemove = numToRemove ? PARSEINT(numToRemove) : numToRemove === 0 ? 0 : 1; // if null or undefined: remove 1
                if (numToRemove > 0 && index > -1) {
                    items = _data.slice(index, index + numToRemove);
                    if (numToRemove = items.length) {
                        this._remove(index, numToRemove, items);
                    }
                }
                return this;
            },

            _remove: function (index, numToRemove, items) {
                var _data = this._data,
                    oldLength = _data.length;

                _data.splice(index, numToRemove);
                this._trigger({ change: "remove", index: index, items: items }, oldLength);
            },

            move: function (oldIndex, newIndex, numToMove) {
                numToMove = numToMove ? PARSEINT(numToMove) : numToMove === 0 ? 0 : 1; // if null or undefined: move 1
                oldIndex = PARSEINT(oldIndex);
                newIndex = PARSEINT(newIndex);

                if (numToMove > 0 && oldIndex > -1 && newIndex > -1 && oldIndex !== newIndex) {
                    this._move(oldIndex, newIndex, numToMove);
                }
                return this;
            },

            _move: function (oldIndex, newIndex, numToMove) {
                var items,
                    _data = this._data,
                    oldLength = _data.length,
                    excess = oldIndex + numToMove - oldLength;
                if (excess > 0) {
                    numToMove -= excess;
                }
                if (numToMove) {
                    items = _data.splice(oldIndex, numToMove); // remove
                    if (newIndex > _data.length) {
                        newIndex = _data.length;
                    }
                    splice.apply(_data, [newIndex, 0].concat(items)); //re-insert
                    this._trigger({ change: "move", oldIndex: oldIndex, index: newIndex, items: items }, oldLength);
                }
            },

            refresh: function (newItems, sort) {
                function insertAdded() {
                    if (k) {
                        self.insert(j - k, addedItems); // Not found in original array - so insert
                        dataLength += k;
                        i += k;
                        k = 0;
                        addedItems = [];
                    }
                }

                // For refresh operation we iteratively step through the target array and sort by move/add/remove operations on the source array until they match
                var i, j, k, newItem, num,
                    self = this,
                    addedItems = [],
                    data = self._data,
                    oldItems = data.slice(),
                    oldLength = data.length,
                    dataLength = oldLength,
                    newLength = newItems.length;
                self._srt = true; // Flag for sorting during refresh
                for (j = k = 0; j < newLength; j++) {
                    if ((newItem = newItems[j]) === data[j - k]) {
                        insertAdded();
                    } else {
                        for (i = j - k; i < dataLength; i++) {
                            if (newItem === data[i]) {
                                break;
                            }
                        }
                        if (i < dataLength) {
                            insertAdded();
                            num = 0;
                            while (num++ < newLength - i && newItems[j + num] === data[i + num]);
                            self.move(i, j, num); // Found newItem in original array - so move it to new position
                            j += num - 1;
                        } else {
                            k++;
                            addedItems.push(newItem); // Not found in original array - so insert
                        }
                    }
                }
                insertAdded();
                if (dataLength > j) {
                    self.remove(j, dataLength - j);
                }
                self._srt = undefined; // We have finished sort operations during refresh
                self._trigger({ change: "refresh", oldItems: oldItems }, oldLength);
                return self;
            },

            _trigger: function (eventArgs, oldLength) {
                var self = this,
                    _data = self._data,
                    length = _data.length,
                    $_data = $([_data]);
                if (self._srt) {
                    eventArgs.refresh = true; // We are sorting during refresh
                } else if (length !== oldLength) {  // We have finished sort operations during refresh
                    $_data.triggerHandler(propertyChangeStr, { change: "set", path: "length", value: length, oldValue: oldLength });
                }
                $_data.triggerHandler(arrayChangeStr + (self._ns ? "." + /^\S+/.exec(self._ns)[0] : ""), eventArgs); // If white-space separated namespaces, use first one only
            }
        };

        $eventSpecial[propertyChangeStr] = $eventSpecial[arrayChangeStr] = {
            // Register a jQuery special 'remove' event, to access the data associated with handlers being removed by jQuery.off().
            // We get data.cb._cId from the event handleObj and get the corresponding cbBindings hash from the cbBindingsStore,
            // then remove this object from that bindings hash - if the object does not have any other handlers associated with the same callback.
            remove: function (handleObj) {
                var cbBindings, found, events, l, data,
                    evData = handleObj.data;
                if ((evData) && (evData.off = true, evData = evData.cb)) { //Set off = true as marker for disposed event
                    // Get the cb._cId from handleObj.data.cb._cId
                    if (cbBindings = cbBindingsStore[evData._cId]) {
                        // There were bindings for this callback. If this was the last one, we'll remove it.
                        events = $._data(this).events[handleObj.type];
                        l = events.length;
                        while (l-- && !found) {
                            found = (data = events[l].data) && data.cb && data.cb._cId === evData._cId;
                            // Found another one with same callback (though may be a different innerCallback)
                        }
                        if (!found) {
                            // This was the last handler for this callback and object, so remove the binding entry
                            delete cbBindings[$data(this).obId];
                            removeCbBindings(cbBindings, evData._cId);
                        }
                    }
                }
            }
        };

        $views.map = function (mapDef) {
            function Map(source, options, target, unbound) {
                var changing,
                    map = this;
                if (this.src) {
                    this.unmap(); // We are re-mapping a new source
                }
                if (typeof source === OBJECT) {
                    map.src = source;
                    map.tgt = target || map.tgt || [];
                    map.options = options || map.options;
                    map.update();
                    if (!unbound) {
                        if (mapDef.obsSrc) {
                            $observable(map.src).observeAll(map.obs = function (ev, eventArgs) {
                                if (!changing) {
                                    changing = true;
                                    mapDef.obsSrc(map, ev, eventArgs);
                                    changing = undefined;
                                }
                            }, map.srcFlt);
                        }
                        if (mapDef.obsTgt) {
                            $observable(map.tgt).observeAll(map.obt = function (ev, eventArgs) {
                                if (!changing) {
                                    changing = true;
                                    mapDef.obsTgt(map, ev, eventArgs);
                                    changing = undefined;
                                }
                            }, map.tgtFlt);
                        }
                    }
                }
            }

            if ($isFunction(mapDef)) {
                // Simple map declared as function
                mapDef = {
                    getTgt: mapDef
                };
            }

            if (mapDef.baseMap) {
                mapDef = $.extend({}, mapDef.baseMap, mapDef);
            }

            mapDef.map = function (source, options, target, unbound) {
                return new Map(source, options, target, unbound);
            };

            (Map.prototype = {
                srcFlt: mapDef.srcFlt || shallowFilter, // default to shallowFilter
                tgtFlt: mapDef.tgtFlt || shallowFilter,
                update: function (options) {
                    var map = this;
                    $observable(map.tgt).refresh(mapDef.getTgt(map.src, map.options = options || map.options));
                },
                unmap: function () {
                    var map = this;
                    if (map.src) {
                        if (map.obs) {
                            $observable(map.src).unobserveAll(map.obs, map.srcFlt);
                        }
                        if (map.obt) {
                            $observable(map.tgt).unobserveAll(map.obt, map.tgtFlt);
                        }
                        map.src = undefined;
                    }
                },
                map: Map,
                _def: mapDef
            }).constructor = Map;

            return mapDef;
        };

        $sub.advSet = function () { // refresh advanced settings
            global._jsv = $subSettings.advanced._jsv
                ? { // create global _jsv, for accessing views, etc
                    cbBindings: cbBindingsStore
                }
                : undefined; // In IE8 cannot do delete global._jsv
        };
    }

    //<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< JsViews >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
    /* JsViews:
     * Interactive data-driven views using templates and data-linking.
     * See http://www.jsviews.com/#jsviews and http://github.com/BorisMoore/jsviews
     * Copyright 2016, Boris Moore
     * Released under the MIT License.
     */

    //========================== Top-level vars ==========================

    $viewsSettings = $views.settings;
    $subSettings = $sub.settings;
    $subSettingsAdvanced = $subSettings.advanced;
    $converters = $views.converters;
    $.templates = $templates = $views.templates;
    $tags = $views.tags;
    rFirstElem = /<(?!script)(\w+)[>\s]/;

    if ($.link) { return $; } // JsViews is already loaded

    $subSettings.trigger = true;
    var activeBody, rTagDatalink, $view, $viewsLinkAttr, linkViewsSel, wrapMap, viewStore, oldAdvSet,
        jsvAttrStr = "data-jsv",
        elementChangeStr = "change.jsv",
        onBeforeChangeStr = "onBeforeChange",
        onAfterChangeStr = "onAfterChange",
        onAfterCreateStr = "onAfterCreate",
        CHECKED = "checked",
        CHECKBOX = "checkbox",
        RADIO = "radio",
        RADIOINPUT = "input[type=radio]",
        NONE = "none",
        SCRIPT = "SCRIPT",
        TRUE = "true",
        closeScript = '"></script>',
        openScript = '<script type="jsv',
        deferAttr = jsvAttrStr + "-df",
        bindElsSel = "script,[" + jsvAttrStr + "]",
        fnSetters = {
            value: "val",
            input: "val",
            html: HTML,
            text: "text"
        },
        valueBinding = { from: "value", to: "value" },
        isCleanCall = 0,
        oldCleanData = $.cleanData,
        oldJsvDelimiters = $viewsSettings.delimiters,
        safeFragment = document.createDocumentFragment(),
        qsa = document.querySelector,

        // elContent maps tagNames which have only element content, so may not support script nodes.
        elContent = { ol: 1, ul: 1, table: 1, tbody: 1, thead: 1, tfoot: 1, tr: 1, colgroup: 1, dl: 1, select: 1, optgroup: 1, svg: 1, svg_ns: 1 },
        badParent = { tr: "table" },
        voidElems = {
            br: 1, img: 1, input: 1, hr: 1, area: 1, base: 1, col: 1, link: 1, meta: 1,
            command: 1, embed: 1, keygen: 1, param: 1, source: 1, track: 1, wbr: 1
        },
        displayStyles = {},
        bindingStore = {},
        bindingKey = 1,
        rViewPath = /^#(view\.?)?/,
        rConvertMarkers = /((\/>)|<\/(\w+)>|)(\s*)([#\/]\d+(?:_|(\^)))`(\s*)(<\w+(?=[\s\/>]))?|\s*(?:(<\w+(?=[\s\/>]))|<\/(\w+)>(\s*)|(\/>)\s*|(>)|$)/g,
        rOpenViewMarkers = /(#)()(\d+)(_)/g,
        rOpenMarkers = /(#)()(\d+)([_^])/g,
        rViewMarkers = /(?:(#)|(\/))(\d+)(_)/g,
        rOpenTagMarkers = /(#)()(\d+)(\^)/g,
        rMarkerTokens = /(?:(#)|(\/))(\d+)([_^])([-+@\d]+)?/g,
        rSplitBindings = /&(\d+)\+?/g,
        getComputedStyle = global.getComputedStyle;

    $observable = $.observable;

    if (!$observable) {
        // JsObservable is not loaded.
        throw requiresStr + "JsObservable"; // jquery.observable.js must be loaded before JsViews
    }

    $observe = $observable.observe;

    //========================== Top-level functions ==========================

    //===============
    // Event handlers
    //===============

    function elemChangeHandler(ev, params, sourceValue) {
        var setter, cancel, fromAttr, linkCtx, cvtBack, cnvtName, target, $source, view, binding, oldLinkCtx, onBeforeChange, onAfterChange, tag, to, eventArgs, exprOb,
            source = ev.target,
            bindings = source._jsvBnd;

        // _jsvBnd is a string with the syntax: "&bindingId1&bindingId2"
        if (bindings) {
            while (binding = rSplitBindings.exec(bindings)) {
                if (binding = bindingStore[binding[1]]) {
                    if (to = binding.to) {
                        // The binding has a 'to' field, which is of the form [[targetObject, toPath], cvtBack]
                        linkCtx = binding.linkCtx;
                        view = linkCtx.view;
                        tag = linkCtx.tag || view.tag;
                        $source = $(source);
                        onBeforeChange = view.hlp(onBeforeChangeStr); // TODO Can we optimize this and other instances of same?
                        onAfterChange = view.hlp(onAfterChangeStr); // TODO Can we optimize this and other instances of same
                        fromAttr = defaultAttr(source);
                        setter = fnSetters[fromAttr];
                        if (sourceValue === undefined) {
                            sourceValue = $isFunction(fromAttr)
                                ? fromAttr(source)
                                : setter
                                    ? $source[setter]()
                                    : $source.attr(fromAttr);
                        }
                        cnvtName = to[1];
                        to = to[0]; // [object, path]
                        to = to + "" === to ? [linkCtx.data, to] : to;
                        if (cnvtName) {
                            if ($isFunction(cnvtName)) {
                                cvtBack = cnvtName;
                            } else {
                                cvtBack = view.getRsc("converters", cnvtName);
                            }
                        }
                        if (linkCtx.elem.nodeName === "SELECT") {
                            linkCtx.elem._jsvSel = sourceValue = sourceValue || (linkCtx.elem.multiple ? [] : sourceValue);
                            // data-link <select> to string or (multiselect) array of strings
                        }
                        if (cvtBack) {
                            sourceValue = cvtBack.call(tag, sourceValue);
                        }

                        // Set linkCtx on view, dynamically, just during this handler call
                        oldLinkCtx = view.linkCtx;
                        view.linkCtx = linkCtx;
                        eventArgs = {
                            change: "change",
                            oldValue: linkCtx._val,
                            value: sourceValue
                        };
                        if ((!onBeforeChange || !(cancel = onBeforeChange.call(linkCtx, ev, eventArgs) === false)) &&
                                (!tag || !tag.onBeforeChange || !(cancel = tag.onBeforeChange(ev, eventArgs) === false)) &&
                                sourceValue !== undefined) {
                            target = to[0]; // [object, path]
                            if (sourceValue !== undefined && target) {
                                if (target._jsv) {
                                    exprOb = target;
                                    target = linkCtx.data;
                                    while (exprOb && exprOb.sb) {
                                        target = linkCtx._ctxCb(exprOb, target);
                                        exprOb = exprOb.sb;
                                    }
                                }
                                if (tag) {
                                    tag._.chging = true; // marker to prevent tag change event triggering its own refresh
                                }
                                $observable(target).setProperty(to[1], sourceValue); // 2way binding change event - observably updating bound object
                                if (onAfterChange) {
                                    onAfterChange.call(linkCtx, ev, eventArgs);
                                }
                                if (tag) {
                                    if (tag.onAfterChange) {
                                        tag.onAfterChange(ev, eventArgs);
                                    }
                                    tag._.chging = undefined; // clear the marker
                                }
                                linkCtx._val = sourceValue;
                            }
                        }
                        view.linkCtx = oldLinkCtx;
                    }
                }
            }
        }
    }

    function propertyChangeHandler(ev, eventArgs, linkFn) {
        var attr, sourceValue, noUpdate, forceUpdate, hasError, onError,
            linkCtx = this,
            tag = linkCtx.tag,
            source = linkCtx.data,
            target = linkCtx.elem,
            cvt = linkCtx.convert,
            parentElem = target.parentNode,
            view = linkCtx.view,
            oldLinkCtx = view.linkCtx,
            onEvent = view.hlp(onBeforeChangeStr);

        // Set linkCtx on view, dynamically, just during this handler call
        view.linkCtx = linkCtx;

        if (parentElem && (!onEvent || !(eventArgs && onEvent.call(linkCtx, ev, eventArgs) === false))
            // If data changed, the ev.data is set to be the path. Use that to filter the handler action...
                && !(eventArgs && ev.data.prop !== "*" && ev.data.prop !== eventArgs.path)) {

            if (eventArgs) {
                linkCtx.eventArgs = eventArgs;
            }
            if (eventArgs || linkCtx._toLk) {
                // If eventArgs are defined, this is a data update
                // Otherwise this is the initial data-link rendering call. Bind on this the first time it get called
                linkCtx._toLk = 0; // Remove flag to skip unneccessary rebinding next time
                if (linkFn._er) {
                    // data-link="exprUsingTagOrCvt with onerror=..." - e.g. {tag ... {cvt:... {:... convert='cvt'
                    try {
                        sourceValue = linkFn(source, view);
                    } catch (e) {
                        hasError = linkFn._er;
                        onError = onRenderError(e, view, (new Function("data,view", "return " + hasError + ";"))(source, view));
                        sourceValue = [{ props: {}, args: [onError] }];
                    }
                } else {
                    sourceValue = linkFn(source, view, $sub);
                }
                // Compiled link expression for linkTag: return value for data-link="{:xxx}" with no cvt or cvtBk, otherwise tagCtx or tagCtxs

                attr = getTargetVal(sourceValue, linkCtx, tag = linkCtx.tag,
                        linkCtx.attr || defaultAttr(target, true, cvt !== undefined)
                    );

                if (tag) {
                    // Existing tag instance
                    forceUpdate = hasError || tag._er;
                    // If the new tagCtxs hasError or the previous tagCtxs had error, then force update
                    sourceValue = sourceValue[0] ? sourceValue : [sourceValue];
                    noUpdate = !forceUpdate && eventArgs && tag.onUpdate && tag.onUpdate(ev, eventArgs, sourceValue) === false;

                    mergeCtxs(tag, sourceValue, forceUpdate);

                    if (noUpdate || attr === NONE) {
                        // onUpdate returned false, or attr === "none", or this is an update coming from the tag's own change event
                        // - so don't refresh the tag: we just use the new tagCtxs merged from the sourceValue,
                        // (which may optionally have been modifed in onUpdate()...) and then bind, and we are done
                        callAfterLink(tag, ev, eventArgs);
                        observeAndBind(linkCtx, source, target);
                        view.linkCtx = oldLinkCtx;
                        return;
                    }
                    if (tag._.chging) {
                        return;
                    }

                    if (tag.onUnbind) {
                        tag.onUnbind(tag.tagCtx, linkCtx, tag.ctx, ev, eventArgs);
                    }

                    sourceValue = tag.tagName === ":" // Call convertVal if it is a {{cvt:...}} - otherwise call renderTag
                        ? $sub._cnvt(tag.cvt, view, sourceValue[0])
                        : $sub._tag(tag, view, view.tmpl, sourceValue, true, onError);
                } else if (linkFn._tag) {
                    // For {{: ...}} without a convert or convertBack, we already have the sourceValue, and we are done
                    // For {{: ...}} with either cvt or cvtBack we call convertVal to get the sourceValue and instantiate the tag
                    // If cvt is undefined then this is a tag, and we call renderTag to get the rendered content and instantiate the tag
                    cvt = cvt === "" ? TRUE : cvt; // If there is a cvtBack but no cvt, set cvt to "true"
                    sourceValue = cvt // Call convertVal if it is a {{cvt:...}} - otherwise call renderTag
                        ? $sub._cnvt(cvt, view, sourceValue[0] || sourceValue) // convertVal
                        : $sub._tag(linkFn._tag, view, view.tmpl, sourceValue, true, onError); // renderTag

                    addLinkMethods(tag = linkCtx.tag, true); // In both convertVal and renderTag we have instantiated a tag
                    attr = linkCtx.attr || attr; // linkCtx.attr may have been set to tag.attr during tag instantiation in renderTag
                }

                if (updateContent(sourceValue, linkCtx, attr, tag)
                        && eventArgs
                        && (onEvent = view.hlp(onAfterChangeStr))) {
                    onEvent.call(linkCtx, ev, eventArgs);
                }
                linkCtx._noUpd = 0; // For data-link="^{...}" remove _noUpd flag so updates on subsequent calls

                if (tag) {
                    tag._er = hasError;
                    callAfterLink(tag, ev, eventArgs);
                }
            }

            observeAndBind(linkCtx, source, target);

            // Remove dynamically added linkCtx from view
            view.linkCtx = oldLinkCtx;
        }
    }

    function getTargetVal(sourceValue, linkCtx, tag, attr) {
        var currentValue, setter, css, $target,
            target = tag && tag.parentElem || linkCtx.elem;

        if (sourceValue !== undefined) {
            $target = $(target);
            attr = tag && tag.attr || attr;
            if ($isFunction(sourceValue)) {
                error(linkCtx.expr + ": missing parens");
            }

            if (css = /^css-/.test(attr) && attr.slice(4)) {
                currentValue = $.style(target, css);
                if (+sourceValue === sourceValue) {
                    // Optimization for perf on integer values - e.g. css-width{:width+'px'}
                    currentValue = parseInt(currentValue);
                }
            } else if (attr !== "link") { // attr === "link" is for tag controls which do data binding but have no rendered output or target
                if (attr === "value") {
                    if (target.type === CHECKBOX) {
                        currentValue = $target.prop(attr = CHECKED);
                    }
                } else if (attr === RADIO) {
                    if (target.value === ("" + sourceValue)) {
                        currentValue = $target.prop(CHECKED);
                    } else {
                        return attr;
                    }
                }

                if (currentValue === undefined) {
                    setter = fnSetters[attr];
                    currentValue = setter ? $target[setter]() : $target.attr(attr);
                }
            }
            linkCtx._val = currentValue;
        }
        return attr;
    }

    function setDefer(elem, value) {
        elem._df = value; // Use both an expando and an attribute to track defered tokens. Attribute is needed for querySelectorAll for getViewInfos (childTags)
        elem[(value ? "set" : "remove") + "Attribute"](deferAttr, "");
    }

    function updateContent(sourceValue, linkCtx, attr, tag) {
        // When called for a tag, either in tag.refresh() or propertyChangeHandler(), returns a promise (and supports async)
        // When called (in propertyChangeHandler) for target HTML returns true
        // When called (in propertyChangeHandler) for other targets returns boolean for "changed"
        var setter, prevNode, nextNode, promise, nodesToRemove, useProp, tokens, id, openIndex, closeIndex, testElem, nodeName, cStyle, jsvSel,
            renders = attr !== NONE && sourceValue !== undefined && !linkCtx._noUpd, // For data-link="^{...}", don't update the first time (no initial render) - e.g. to leave server rendered values.
            source = linkCtx.data,
            target = tag && tag.parentElem || linkCtx.elem,
            targetParent = target.parentNode,
            $target = $(target),
            view = linkCtx.view,
            targetVal = linkCtx._val,
            oldLinkCtx = view.linkCtx,
            // If not a tag we can use the ._val obtained from getTargetVal()
            // and only update when the new value (sourceValue) has changed from the previous one
            change = tag;

        if (tag) {
            // Initialize the tag with element references
            tag._.unlinked = true; // Set to unlinked, so initialization is triggered after re-rendering, e.g. for setting linkedElem, and calling onBind
            tag.parentElem = tag.parentElem || (linkCtx.expr || tag._elCnt) ? target : targetParent;
            prevNode = tag._prv;
            nextNode = tag._nxt;
        }
        if (!renders) {
            return;
        }

        if (attr === "visible") {
            attr = "css-display";
        }
        if (/^css-/.test(attr)) {
            if (linkCtx.attr === "visible") {
                // Get the current display style
                cStyle = (target.currentStyle || getComputedStyle.call(global, target, "")).display;

                if (sourceValue) {
                    // We are showing the element.
                    // Get the cached 'visible' display value from the -jsvd expando
                    sourceValue = target._jsvd
                        // Or, if not yet cached, get the current display value
                        || cStyle;
                    if (sourceValue === NONE && !(sourceValue = displayStyles[nodeName = target.nodeName])) {
                        // Currently display value is 'none', and the 'visible' style has not been cached.
                        // We create an element to find the correct 'visible' display style for this nodeName
                        testElem = document.createElement(nodeName);
                        document.body.appendChild(testElem);

                        // Get the default style for this HTML tag to use as 'visible' style
                        sourceValue
                            // and cache it as a hash against nodeName
                            = displayStyles[nodeName]
                            = (testElem.currentStyle || getComputedStyle.call(global, testElem, "")).display;
                        document.body.removeChild(testElem);
                    }
                } else {
                    // We are hiding the element.
                    // Cache the current display value as 'visible' style, on _jsvd expando, for when we show the element again
                    target._jsvd = cStyle;
                    sourceValue = NONE; // Hide the element
                }
            }
            if (change = change || targetVal !== sourceValue) {
                $.style(target, attr.slice(4), sourceValue);
            }
        } else if (attr !== "link") { // attr === "link" is for tag controls which do data binding but have no rendered output or target
            if (/^data-/.test(attr)) {
                $.data(target, attr.slice(5), sourceValue); // Support for binding to data attributes: data-foo{:expr}: data-foo attribute will be
                // expr.toString(), but $.data(element, "foo") and $(element).data("foo") will actually return value of expr, even if of type object
            }
            if (attr === CHECKED) {
                useProp = true;
                sourceValue = sourceValue && sourceValue !== "false";
                // The string value "false" can occur with data-link="checked{attr:expr}" - as a result of attr, and hence using convertVal()
                // We will set the "checked" property
                // We will compare this with the current value
            } else if (attr === RADIO) {
                // This is a special binding attribute for radio buttons, which corresponds to the default 'to' binding.
                // This allows binding both to value (for each input) and to the default checked radio button (for each input in named group,
                // e.g. binding to parent data).
                // Place value binding first: <input type="radio" data-link="value{:name} {:#get('data').data.currency:} " .../>
                // or (allowing any order for the binding expressions):
                // <input type="radio" value="{{:name}}" data-link="{:#get('data').data.currency:} value^{:name}" .../>

                if (target.value === ("" + sourceValue)) {
                    // If the data value corresponds to the value attribute of this radio button input, set the checked property to true
                    sourceValue = useProp = true;
                    attr = CHECKED;
                } else {
                    // Otherwise, go straight to observeAndBind, without updating.
                    // (The browser will remove the 'checked' attribute, when another radio button in the group is checked).
                    observeAndBind(linkCtx, source, target);
                    return;
                }
            } else if (attr === "selected" || attr === "disabled" || attr === "multiple" || attr === "readonly") {
                sourceValue = (sourceValue && sourceValue !== "false") ? attr : null;
                // Use attr, not prop, so when the options (for example) are changed dynamically, but include the previously selected value,
                // they will still be selected after the change
            } else if (attr === "value" && target.nodeName === "SELECT") {
                target._jsvSel = $isArray(sourceValue)
                    ? sourceValue
                    : "" + sourceValue; // If not array, coerce to string
            }

            if (setter = fnSetters[attr]) {
                if (attr === HTML) {
                    // Set linkCtx on view, dynamically, just during this handler call
                    view.linkCtx = linkCtx;
                    if (tag && tag._.inline) {
                        nodesToRemove = tag.nodes(true);
                        if (tag._elCnt) {
                            if (prevNode && prevNode !== nextNode) {
                                // This prevNode will be removed from the DOM, so transfer the view tokens on prevNode to nextNode of this 'viewToRefresh'
                                transferViewTokens(prevNode, nextNode, target, tag._tgId, "^", true);
                            } else if (tokens = target._df) { // This occurs when there is no nextNode, and so the target._df may include tokens referencing
                                // view and tag bindings contained within the open and close tokens of the updated tag control. They need to be processed (disposed)
                                id = tag._tgId + "^";
                                openIndex = tokens.indexOf("#" + id) + 1;
                                closeIndex = tokens.indexOf("/" + id);

                                if (openIndex && closeIndex > 0) {
                                    openIndex += id.length;
                                    if (closeIndex > openIndex) {
                                        setDefer(target, tokens.slice(0, openIndex) + tokens.slice(closeIndex));
                                        disposeTokens(tokens.slice(openIndex, closeIndex));
                                    }
                                }
                            }
                            prevNode = prevNode
                                ? prevNode.previousSibling
                                : nextNode
                                    ? nextNode.previousSibling
                                    : target.lastChild;
                        }
                        // Remove HTML nodes
                        $(nodesToRemove).remove(); // Note if !tag._elCnt removing the nodesToRemove will process and dispose view and tag bindings contained within the updated tag control

                        // Insert and link new content
                        promise = view.link(view.data, target, prevNode, nextNode, sourceValue, tag && { tag: tag._tgId, lazyLink: tag.tagCtx.props.lazyLink });
                    } else {
                        // data-linked value targeting innerHTML: data-link="html{:expr}" or contenteditable="true"
                        renders = renders && targetVal !== sourceValue;
                        if (renders) {
                            $target.empty();
                        }
                        if (renders) {
                            promise = view.link(source, target, prevNode, nextNode, sourceValue, tag && { tag: tag._tgId });
                        }
                    }
                    // Remove dynamically added linkCtx and ctx from view
                    view.linkCtx = oldLinkCtx;
                } else {
                    if (change = change || targetVal !== sourceValue) {
                        if (attr === "text" && target.children && !target.children[0]) {
                            // This code is faster then $target.text()
                            if (target.textContent !== undefined) {
                                target.textContent = sourceValue;
                            } else {
                                target.innerText = sourceValue === null ? "" : sourceValue;
                            }
                        } else {
                            $target[setter](sourceValue);
                        }
                    }
                    if ((jsvSel = targetParent._jsvSel)
                        // Setting value of <option> element
                        && (attr === "value" || !$target.attr("value"))) { // Setting value attribute, or setting textContent if attribute is null
                        // Set/unselect selection based on value set on parent <select>. Works for multiselect too
                        target.selected = $.inArray("" + sourceValue, $isArray(jsvSel) ? jsvSel : [jsvSel]) > -1;
                    }
                }
            } else if (change = change || targetVal !== sourceValue) {
                // Setting an attribute to undefined should remove the attribute
                $target[useProp ? "prop" : "attr"](attr, sourceValue === undefined && !useProp ? null : sourceValue);
            }
            linkCtx._val = sourceValue;
        }
        return promise || change;
    }

    function arrayChangeHandler(ev, eventArgs) {
        var self = this,
            onBeforeChange = self.hlp(onBeforeChangeStr),
            onAfterChange = self.hlp(onAfterChangeStr);
        if (!onBeforeChange || onBeforeChange.call(this, ev, eventArgs) !== false) {
            if (eventArgs) {
                // This is an observable action (not a trigger/handler call from pushValues, or similar, for which eventArgs will be null)
                var action = eventArgs.change,
                    index = eventArgs.index,
                    items = eventArgs.items;
                self._.srt = eventArgs.refresh; // true if part of a 'sort' on refresh
                switch (action) {
                    case "insert":
                        self.addViews(index, items);
                        break;
                    case "remove":
                        self.removeViews(index, items.length);
                        break;
                    case "move":
                        self.removeViews(eventArgs.oldIndex, items.length, undefined, true); // remove
                        self.addViews(index, items); // re-insert
                        break;
                    case "refresh":
                        self._.srt = undefined;
                        self.fixIndex(0);
                        // Other cases: (e.g.undefined, for setProperty on observable object) etc. do nothing
                }
            }
            if (onAfterChange) {
                onAfterChange.call(this, ev, eventArgs);
            }
        }
    }

    //=============================
    // Utilities for event handlers
    //=============================

    function setArrayChangeLink(view) {
        // Add/remove arrayChange handler on view
        var handler, arrayBinding,
            type = view.type, // undefined if view is being removed
            data = view.data,
            bound = view._.bnd; // true for top-level link() or data-link="{for}", or the for tag instance for {^{for}} (or for any custom tag that has an onArrayChange handler)

        if (!view._.useKey && bound) {
            // This is an array view. (view._.useKey not defined => data is array), and is data-bound to collection change events

            if (arrayBinding = view._.bndArr) {
                // First remove the current handler if there is one
                $([arrayBinding[1]]).off(arrayChangeStr, arrayBinding[0]);
                view._.bndArr = undefined;
            }
            if (bound !== !!bound) {
                // bound is not a boolean, so it is the data-linked tag that 'owns' this array binding - e.g. {^{for...}}
                if (type) {
                    bound._.arrVws[view._.id] = view;
                } else {
                    delete bound._.arrVws[view._.id]; // if view.type is undefined, view is being removed
                }
            } else if (type && data) {
                // If this view is not being removed, but the data array has been replaced, then bind to the new data array
                handler = function (ev) {
                    if (!(ev.data && ev.data.off)) {
                        // Skip if !!ev.data.off: - a handler that has already been removed (maybe was on handler collection at call time - then removed by another handler)
                        // If view.type is undefined, do nothing. (Corresponds to case where there is another handler on the same data whose
                        // effect was to remove this view, and which happened to precede this event in the trigger sequence. So although this
                        // event has been removed now, it is still called since already on the trigger sequence)
                        arrayChangeHandler.apply(view, arguments);
                    }
                };
                $([data]).on(arrayChangeStr, handler);
                view._.bndArr = [handler, data];
            }
        }
    }

    function defaultAttr(elem, to, linkGetVal) {
        // to: true - default attribute for setting data value on HTML element; false: default attribute for getting value from HTML element
        // Merge in the default attribute bindings for this target element
        var nodeName = elem.nodeName.toLowerCase(),
            attr =
                $subSettingsAdvanced._fe[nodeName] // get form element binding settings for input textarea select or optgroup
                || elem.contentEditable === TRUE && { to: HTML, from: HTML }; // Or if contentEditable set to "true" set attr to "html"
        return attr
            ? (to
                ? ((nodeName === "input" && elem.type === RADIO) // For radio buttons, bind from value, but bind to 'radio' - special value.
                    ? RADIO
                    : attr.to)
                : attr.from)
            : to
                ? linkGetVal ? "text" : HTML // Default innerText for data-link="a.b.c" or data-link="{:a.b.c}" (with or without converters)- otherwise innerHTML
                : ""; // Default is not to bind from
    }

    //==============================
    // Rendering and DOM insertion
    //==============================

    function renderAndLink(view, index, tmpl, views, data, context, refresh) {
        var html, linkToNode, prevView, nodesToRemove, bindId,
            parentNode = view.parentElem,
            prevNode = view._prv,
            nextNode = view._nxt,
            elCnt = view._elCnt;

        if (prevNode && prevNode.parentNode !== parentNode) {
            error("Missing parentNode");
            // Abandon, since node has already been removed, or wrapper element has been inserted between prevNode and parentNode
        }

        if (refresh) {
            nodesToRemove = view.nodes();
            if (elCnt && prevNode && prevNode !== nextNode) {
                // This prevNode will be removed from the DOM, so transfer the view tokens on prevNode to nextNode of this 'viewToRefresh'
                transferViewTokens(prevNode, nextNode, parentNode, view._.id, "_", true);
            }
            // Remove child views
            view.removeViews(undefined, undefined, true);
            linkToNode = nextNode;

            if (elCnt) {
                prevNode = prevNode
                    ? prevNode.previousSibling
                    : nextNode
                        ? nextNode.previousSibling
                        : parentNode.lastChild;
            }

            // Remove HTML nodes
            $(nodesToRemove).remove();

            for (bindId in view._.bnds) {
                // The view bindings may have already been removed above in: $(nodesToRemove).remove();
                // If not, remove them here:
                removeViewBinding(bindId);
            }
        } else {
            // addViews. Only called if view is of type "array"
            if (index) {
                // index is a number, so indexed view in view array
                prevView = views[index - 1];
                if (!prevView) {
                    return false; // If subview for provided index does not exist, do nothing
                }
                prevNode = prevView._nxt;
            }
            if (elCnt) {
                linkToNode = prevNode;
                prevNode = linkToNode
                    ? linkToNode.previousSibling         // There is a linkToNode, so insert after previousSibling, or at the beginning
                    : parentNode.lastChild;              // If no prevView and no prevNode, index is 0 and the container is empty,
                // so prevNode = linkToNode = null. But if prevView._nxt is null then we set prevNode to parentNode.lastChild
                // (which must be before the prevView) so we insert after that node - and only link the inserted nodes
            } else {
                linkToNode = prevNode.nextSibling;
            }
        }
        html = tmpl.render(data, context, view._.useKey && refresh, view, refresh || index, true);
        // Pass in view._.useKey as test for noIteration (which corresponds to when self._.useKey > 0 and self.data is an array)

        // Link the new HTML nodes to the data
        view.link(data, parentNode, prevNode, linkToNode, html, prevView);
        //}, 0);
    }

    //=====================
    // addBindingMarkers
    //=====================

    function addBindingMarkers(value, view, tag) {
        // Insert binding markers into the rendered template output, which will get converted to appropriate
        // data-jsv attributes (element-only content) or script marker nodes (phrasing or flow content), in convertMarkers,
        // within view.link, prior to inserting into the DOM. Linking will then bind based on these markers in the DOM.
        // Added view markers: #m_...VIEW.../m_
        // Added tag markers: #m^...TAG..../m^
        var id, end;
        if (tag) {
            // This is a binding marker for a data-linked tag {^{...}}
            end = "^`";
            addLinkMethods(tag, true); // This is {^{>...}} or {^{tag ...}}, {{cvt:...} or {^{:...}}, and tag was defined in convertVal or renderTag
            id = tag._tgId;
            if (!id) {
                bindingStore[id = bindingKey++] = tag; // Store the tag temporarily, ready for databinding.
                // During linking, in addDataBinding, the tag will be attached to the linkCtx,
                // and then in observeAndBind, bindingStore[bindId] will be replaced by binding info.
                tag._tgId = "" + id;
            }
        } else {
            // This is a binding marker for a view
            // Add the view to the store of current linked views
            end = "_`";
            addLinkMethods(viewStore[id = view._.id] = view);
        }
        // Example: "#23^TheValue/23^"
        return "#" + id + end
            + (value != undefined ? value : "") // For {^{:name}} this gives the equivalent semantics to compiled
                                                // (v=data.name)!=null?v:""; used in {{:name}} or data-link="name"
            + "/" + id + end;
    }

    //==============================
    // Data-linking and data binding
    //==============================

    //---------------
    // observeAndBind
    //---------------

    function observeAndBind(linkCtx, source, target) { //TODO? linkFnArgs) {;
        var binding, l, linkedElem, exprFnDeps, exprOb,
            tag = linkCtx.tag,
            cvtBk = linkCtx.convertBack,
            depends = [],
            bindId = linkCtx._bndId || "" + bindingKey++,
            handler = linkCtx._hdl;

        linkCtx._bndId = undefined;

        if (tag) {
            // Use the 'depends' paths set on linkCtx.tag - which may have been set on declaration
            // or in events: init, render, onAfterLink etc.
            depends = tag.depends || depends;
            depends = $isFunction(depends) ? tag.depends(tag) : depends;
            linkedElem = tag.linkedElem;
        }
        if (!linkCtx._depends || ("" + linkCtx._depends !== "" + depends)) {
            // Only bind the first time, or if the new depends (toString) has changed from when last bound
            if (linkCtx._depends) {
                // Unobserve previous binding
                $observable._apply(false, [source], linkCtx._depends, handler, true);
            }

            exprFnDeps = linkCtx.fn.deps.slice(); // Make a copy of the dependency paths for the compiled linkCtx expression - to pass to observe(). In getInnerCb(),
            // (and whenever the object is updated, in innerCb), we will set exprOb.ob to the current object returned by that computed expression, for this view.
            l = exprFnDeps.length;
            while (l--) {
                exprOb = exprFnDeps[l];
                if (exprOb._jsv) {
                    // This path is an 'exprOb', corresponding to a computed, returning an object. We replace the exprOb by
                    // a view-binding-specific exprOb instance. The current object will be stored as exprOb.ob.
                    exprFnDeps[l] = $extend({}, exprOb);
                }
            }

            binding = $observable._apply(
                false,
                [source],
                exprFnDeps, // flatten the paths - to gather all the dependencies across args and bound params
                depends,
                handler,
                linkCtx._ctxCb);
            // The binding returned by $observe has a bnd array with the source objects of the individual bindings.

            binding.elem = target; // The target of all the individual bindings
            binding.linkCtx = linkCtx;
            binding._tgId = bindId;

            // Add to the _jsvBnd on the target the view id and binding id - for unbinding when the target element is removed
            target._jsvBnd = target._jsvBnd || "";
            target._jsvBnd += "&" + bindId;
            linkCtx._depends = depends;
            // Store the binding key on the view, for disposal when the view is removed
            linkCtx.view._.bnds[bindId] = bindId;
            // Store the binding.
            bindingStore[bindId] = binding; // Note: If this corresponds to a data-linked tag, we are replacing the
            // temporarily stored tag by the stored binding. The tag will now be at binding.linkCtx.tag

            if (linkedElem) {
                binding.to = [[], cvtBk];
            }
            if (linkedElem || cvtBk !== undefined) {
                bindTo(binding, tag, linkedElem && linkedElem[0] || target, cvtBk);
            }
            if (tag) {
                if (!tag.flow && !tag._.inline) {
                    target.setAttribute(jsvAttrStr, (target.getAttribute(jsvAttrStr) || "") + "#" + bindId + "^/" + bindId + "^");
                    tag._tgId = "" + bindId;
                }
            }
        }
        if (linkedElem && linkedElem[0]) {
            l = linkedElem.length;
            while (l--) {
                linkedElem[l]._jsvBnd = linkedElem[l]._jsvBnd || (target._jsvBnd + "+");
                // Add a "+" for cloned binding - so removing elems with cloned bindings will not remove the 'parent' binding from the bindingStore.
                linkedElem[l]._jsvLkEl = tag;
            }
        }
    }

    //-------
    // $.link
    //-------

    function tmplLink(to, from, context, noIteration, parentView, prevNode, nextNode) {
        return $link(this, to, from, context, noIteration, parentView, prevNode, nextNode);
    }

    function $link(tmplOrLinkExpr, to, from, context, noIteration, parentView, prevNode, nextNode) {
        // When linking from a template, prevNode and nextNode parameters are ignored
        if (context === true) {
            noIteration = context; // passing boolean as third param - noIteration
            context = undefined;
        } else if (typeof context !== "object") {
            context = undefined; // context must be a boolean (noIteration) or a plain object
        } else {
            context = $extend({}, context);
        }
        if (tmplOrLinkExpr && to) {
            to = to.jquery ? to : $(to); // to is a jquery object or an element or selector

            if (!activeBody) {
                activeBody = document.body;
                $(activeBody)
                    .on(elementChangeStr, elemChangeHandler)
                    .on('blur', '[contenteditable]', elemChangeHandler);
            }

            var i, k, html, vwInfos, view, placeholderParent, targetEl, refresh, topLevelCall,
                onRender = addBindingMarkers,
                replaceMode = context && context.target === "replace",
                l = to.length;

            while (l--) {
                targetEl = to[l];

                parentView = parentView || $view(targetEl);

                if (topLevelCall = parentView === topView) {
                    topView.data = (topView.ctx = context || {}).root = from;
                }
                if ("" + tmplOrLinkExpr === tmplOrLinkExpr) {
                    // tmplOrLinkExpr is a string: treat as data-link expression.
                    addDataBinding(tmplOrLinkExpr, targetEl, parentView, undefined, true, from, context);
                } else {
                    if (tmplOrLinkExpr.markup !== undefined) {
                        // This is a call to template.link()
                        if (replaceMode) {
                            placeholderParent = targetEl.parentNode;
                        }

                        html = tmplOrLinkExpr.render(from, context, noIteration, parentView, undefined, onRender);
                        // TODO Consider finding a way to bind data (link) within template without html being different for each view, the HTML can
                        // be evaluated once outside the while (l--), and pushed into a document fragment, then cloned and inserted at each target.

                        if (placeholderParent) {
                            // This is target="replace" mode
                            prevNode = targetEl.previousSibling;
                            nextNode = targetEl.nextSibling;
                            $.cleanData([targetEl], true);
                            placeholderParent.removeChild(targetEl);

                            targetEl = placeholderParent;
                        } else {
                            prevNode = nextNode = undefined; // When linking from a template, prevNode and nextNode parameters are ignored
                            $(targetEl).empty();
                        }
                    } else if (tmplOrLinkExpr === true && parentView === topView) {
                        // $.link(true, selector, data, ctx) - where selector points to elem in top-level content. (If not top-level content, no-op)
                        refresh = { lnk: 1 };
                    } else {
                        break;
                    }

                    // TODO Consider deferred linking API feature on per-template basis - {@{ instead of {^{ which allows the user to see the rendered content
                    // before that content is linked, with better perceived perf. Have view.link return a deferred, and pass that to onAfterLink...
                    // or something along those lines.
                    // setTimeout(function() {

                    if (targetEl._df && !nextNode) {
                        // We are inserting new content and the target element has some deferred binding annotations,and there is no nextNode.
                        // Those views may be stale views (that will be recreated in this new linking action) so we will first remove them
                        // (if not already removed).
                        vwInfos = viewInfos(targetEl._df, true, rOpenViewMarkers);

                        for (i = 0, k = vwInfos.length; i < k; i++) {
                            view = vwInfos[i];
                            if ((view = viewStore[view.id]) && view.data !== undefined) {
                                // If this is the _prv (prevNode) for a view, remove the view
                                // - unless view.data is undefined, in which case it is already being removed
                                view.parent.removeViews(view._.key, undefined, true);
                            }
                        }
                        setDefer(targetEl); // remove defer tokens
                    }

                    // Link the content of the element, since this is a call to template.link(), or to $(el).link(true, ...),
                    parentView.link(from, targetEl, prevNode, nextNode, html, refresh, context);
                    //}, 0);
                }
                if (topLevelCall) {
                    topView.data = topView.ctx = undefined;
                }
            }
        }
        return to; // Allow chaining, to attach event handlers, etc.
    }

    //----------
    // view.link
    //----------

    function viewLink(outerData, parentNode, prevNode, nextNode, html, refresh, context, validateOnly) {
        // Optionally insert HTML into DOM using documentFragments (and wrapping HTML appropriately).
        // Data-link existing contents of parentNode, or the inserted HTML, if provided

        // Depending on the content model for the HTML elements, the standard data-linking markers inserted in the HTML by addBindingMarkers during
        // template rendering will be converted either to script marker nodes or, for element-only content sections, to data-jsv element annotations.

        // Data-linking will then add _prv and _nxt to views, where:
        //     _prv: References the previous node (script element of type "jsv123"), or (for elCnt=true), the first element node in the view (or if none, set _prv = _nxt)
        //     _nxt: References the last node (script element of type "jsv/123"), or (for elCnt=true), the next element node after the view.

        //==== nested functions ====
        function convertMarkers(all, preceding, selfClose, closeTag, spaceBefore, id, boundId, spaceAfter, tag1, tag2, closeTag2, spaceAfterClose, selfClose2, endOpenTag) {
            // rConvertMarkers = /(^|(\/>)|<\/(\w+)>|)(\s*)([#\/]\d+(?:_|(\^)))`(\s*)(<\w+(?=[\s\/>]))?|\s*(?:(<\w+(?=[\s\/>]))|<\/(\w+)>(\s*)|(\/>)\s*|(>))/g,
            //                 prec, slfCl, clsTag,  spBefore, id,      bndId  spAfter,tag1,                   tag2,               clTag2,sac  slfCl2, endOpenTag
            // Convert the markers that were included by addBindingMarkers in template output, to appropriate DOM annotations:
            // data-jsv attributes (for element-only content) or script marker nodes (within phrasing or flow content).

            // TODO consider detecting 'quoted' contexts (attribute strings) so that attribute encoding does not need to encode >
            // Currently rAttrEncode = /[><"'&]/g includes '>' encoding in order to avoid erroneous parsing of <span title="&lt;a/>"></span>">
            var errorMsg, bndId,
                endOfElCnt = "";
            if (endOpenTag) {
                inTag = 0;
                return all;
            }
            tag = tag1 || tag2 || "";
            closeTag = closeTag || closeTag2;
            selfClose = selfClose || selfClose2;
            if (isVoid && !selfClose && (!all || closeTag || tag || id && !inTag)) { // !all = end of string
                isVoid = undefined;
                parentTag = tagStack.shift(); // preceding tag was a void element, with no closing slash, such as <br>.
            }
            closeTag = closeTag || selfClose;
            if (closeTag) {
                inTag = 0;
                isVoid = undefined;
                // TODO: smart insertion of <tbody> - to be completed for robust insertion of deferred bindings etc.
                //if (closeTag === "table" && parentTag === "tbody") {
                //	preceding = "</tbody>" + preceding;
                //	parentTag = "table";
                //	tagStack.shift();
                //}
                if (validate) {
                    if (selfClose || selfClose2) {
                        if (!voidElems[parentTag] && !/;svg;|;math;/.test(";" + tagStack.join(";") + ";")) {
                            // Only self-closing elements must be legitimate void elements, such as <br/>, per HTML schema,
                            // or under svg or math foreign namespace elements.
                            errorMsg = "'<" + parentTag + ".../";
                        }
                    } else if (voidElems[closeTag]) {
                        errorMsg = "'</" + closeTag; // closing tag such as </input>
                    } else if (!tagStack.length || closeTag !== parentTag) {
                        errorMsg = "Mismatch: '</" + closeTag;
                    }
                    if (errorMsg) {
                        syntaxError(errorMsg + ">' in:\n" + html);
                    }
                }
                prevElCnt = elCnt;
                parentTag = tagStack.shift();
                elCnt = elContent[parentTag];
                closeTag2 = closeTag2 ? ("</" + closeTag2 + ">") : "";
                if (prevElCnt) {
                    // If there are ids (markers since the last tag), move them to the defer string
                    defer += ids;
                    ids = "";
                    if (!elCnt) {
                        endOfElCnt = closeTag2 + openScript + "@" + defer + closeScript + (spaceAfterClose || "");
                        defer = deferStack.shift();
                    } else {
                        defer += "-"; // Will be used for stepping back through deferred tokens
                    }
                }
            }
            if (elCnt) {
                // elContent maps tagNames which have only element content, so may not support script nodes.
                // We are in element-only content, can remove white space, and use data-jsv attributes on elements as markers
                // Example: <tr data-jsv="/2_#6_"> - close marker for view 2 and open marker for view 6

                if (id) {
                    // append marker for this id, to ids string
                    ids += id;
                } else {
                    preceding = (closeTag2 || selfClose2 || "");
                }
                if (tag) {
                    // TODO: smart insertion of <tbody> - to be completed for robust insertion of deferred bindings etc.
                    //if (tag === "<tr" && parentTag === "table") {
                    //	tagStack.unshift(parentTag);
                    //	parentTag = "tbody";
                    //	preceding += "<" + parentTag + ">";
                    //	if (defer) {
                    //		defer += "+"; // Will be used for stepping back through deferred tokens
                    //	}
                    //	// TODO: move this to design-time validation check
                    //	//	error('"' + parentTag + '" has incorrect parent tag');
                    //}
                    preceding += tag;
                    if (ids) {
                        preceding += ' ' + jsvAttrStr + '="' + ids + '"';
                        ids = "";
                    }
                }
            } else {
                // We are in phrasing or flow content, so use script marker nodes
                // Example: <script type="jsv3/"></script> - data-linked tag, close marker
                // We validate with inTag so no script markers are inserted in attribute context e.g. for:
                // "<table {{if ...}}...{{/if}}... >" or "<table {{if ...}}...> ...{{/if}}..."
                preceding = id
                    ? (preceding + endOfElCnt + spaceBefore + (inTag ? "" : openScript + id + closeScript) + spaceAfter + tag)
                    : endOfElCnt || all;
            }

            if (validate && boundId) {
                if (inTag) {
                    // JsViews data-linking tags are not allowed within element markup.
                    // See jsviews/issues/303
                    syntaxError('{^{ within elem markup (' + inTag + ' ). Use data-link="..."');
                }
                if (id.charAt(0) === "#") {
                    tagStack.unshift(id.slice(1));
                } else if (id.slice(1) !== (bndId = tagStack.shift())) {
                    // See jsviews/issues/213
                    syntaxError('Closing tag for {^{...}} under different elem: <' + bndId + '>');
                }
            }
            if (tag) {
                inTag = tag;
                // If there are ids (markers since the last tag), move them to the defer string
                tagStack.unshift(parentTag);
                parentTag = tag.slice(1);
                if (validate && tagStack[0] && tagStack[0] === badParent[parentTag]) {
                    // Missing <tbody>
                    // TODO: replace this by smart insertion of <tbody> tags
                    error('Parent of <tr> must be <tbody>');
                }
                isVoid = voidElems[parentTag];
                if ((elCnt = elContent[parentTag]) && !prevElCnt) {
                    deferStack.unshift(defer);
                    defer = "";
                }
                prevElCnt = elCnt;
                //TODO Consider providing validation which throws if you place <span> as child of <tr>, etc. - since if not caught,
                //this can cause errors subsequently which are difficult to debug.
                //				if (elContent[tagStack[0]]>2 && !elCnt) {
                //					error(parentTag + " in " + tagStack[0]);
                //				}
                if (defer && elCnt) {
                    defer += "+"; // Will be used for stepping back through deferred tokens
                }
            }
            return preceding;
        }

        function processViewInfos(vwInfos, targetParent) {
            // If targetParent, we are processing viewInfos (which may include navigation through '+-' paths) and hooking up to the right parentElem etc.
            // (and elem may also be defined - the next node)
            // If no targetParent, then we are processing viewInfos on newly inserted content
            var deferPath, deferChar, bindChar, parentElem, id, onAftCr, deep,
                addedBindEls = [];

            // In elCnt context (element-only content model), prevNode is the first node after the open, nextNode is the first node after the close.
            // If both are null/undefined, then open and close are at end of parent content, so the view is empty, and its placeholder is the
            // 'lastChild' of the parentNode. If there is a prevNode, then it is either the first node in the view, or the view is empty and
            // its placeholder is the 'previousSibling' of the prevNode, which is also the nextNode.
            if (vwInfos) {
                if (vwInfos._tkns.charAt(0) === "@") {
                    // We are processing newly inserted content. This is a special script element that was created in convertMarkers() to process deferred bindings,
                    // and inserted following the target parent element - because no element tags (outside elCnt) were encountered to carry those binding tokens.
                    // We will step back from the preceding sibling of this element, looking at targetParent elements until we find the one that the current binding
                    // token belongs to. Set elem to null (the special script element), and remove it from the DOM.
                    targetParent = elem.previousSibling;
                    elem.parentNode.removeChild(elem);
                    elem = undefined;
                }
                len = vwInfos.length;
                while (len--) {
                    vwInfo = vwInfos[len];
                    //if (prevIds.indexOf(vwInfo.token) < 0) { // This token is a newly created view or tag binding
                    bindChar = vwInfo.ch;
                    if (deferPath = vwInfo.path) {
                        // We have a 'deferred path'
                        j = deferPath.length - 1;
                        while (deferChar = deferPath.charAt(j--)) {
                            // Use the "+" and"-" characters to navigate the path back to the original parent node where the deferred bindings ocurred
                            if (deferChar === "+") {
                                if (deferPath.charAt(j) === "-") {
                                    j--;
                                    targetParent = targetParent.previousSibling;
                                } else {
                                    targetParent = targetParent.parentNode;
                                }
                            } else {
                                targetParent = targetParent.lastChild;
                            }
                            // Note: Can use previousSibling and lastChild, not previousElementSibling and lastElementChild,
                            // since we have removed white space within elCnt. Hence support IE < 9
                        }
                    }
                    if (bindChar === "^") {
                        if (tag = bindingStore[id = vwInfo.id]) {
                            // The binding may have been deleted, for example in a different handler to an array collectionChange event
                            // This is a tag binding
                            deep = targetParent && (!elem || elem.parentNode !== targetParent); // We are stepping back looking for the right targetParent,
                            // or we are linking existing content and this element is in elCnt, not an immediate child of the targetParent.
                            if (!elem || deep) {
                                tag.parentElem = targetParent;
                            }
                            if (vwInfo.elCnt && deep) {
                                // With element only content, if there is no following element, or if the binding is deeper than the following element
                                // then we need to set the open or close token as a deferred binding annotation on the parent
                                setDefer(targetParent, (vwInfo.open ? "#" : "/") + id + bindChar + (targetParent._df || ""));
                            }
                            // This is an open or close marker for a data-linked tag {^{...}}. Add it to bindEls.
                            addedBindEls.push([deep ? null : elem, vwInfo]);
                        }
                    } else if (view = viewStore[id = vwInfo.id]) {
                        // The view may have been deleted, for example in a different handler to an array collectionChange event
                        if (!view.parentElem) {
                            // If view is not already extended for JsViews, extend and initialize the view object created in JsRender, as a JsViews view
                            view.parentElem = targetParent || elem && elem.parentNode || parentNode;
                            view._.onRender = addBindingMarkers;
                            view._.onArrayChange = arrayChangeHandler;
                            setArrayChangeLink(view);
                        }
                        parentElem = view.parentElem;
                        if (vwInfo.open) {
                            // This is an 'open view' node (preceding script marker node,
                            // or if elCnt, the first element in the view, with a data-jsv annotation) for binding
                            view._elCnt = vwInfo.elCnt;
                            if (targetParent && !elem) {
                                setDefer(targetParent, "#" + id + bindChar + (targetParent._df || ""));
                            } else {
                                // No targetParent, so there is a ._nxt elem (and this is processing tokens on the elem)
                                if (!view._prv) {
                                    setDefer(parentElem, removeSubStr(parentElem._df, "#" + id + bindChar));
                                }
                                view._prv = elem;
                            }
                        } else {
                            // This is a 'close view' marker node for binding
                            if (targetParent && (!elem || elem.parentNode !== targetParent)) {
                                // There is no ._nxt so add token to _df. It is deferred.
                                setDefer(targetParent, "/" + id + bindChar + (targetParent._df || ""));
                                view._nxt = undefined;
                            } else if (elem) {
                                // This view did not have a ._nxt, but has one now, so token may be in _df, and must be removed. (No longer deferred)
                                if (!view._nxt) {
                                    setDefer(parentElem, removeSubStr(parentElem._df, "/" + id + bindChar));
                                }
                                view._nxt = elem;
                            }
                            linkCtx = view.linkCtx;
                            if (onAftCr = view.ctx && view.ctx.onAfterCreate || onAfterCreate) {
                                onAftCr.call(linkCtx, view);
                            }
                        }
                        //}
                    }
                }
                len = addedBindEls.length;
                while (len--) {
                    // These were added in reverse order to addedBindEls. We push them in BindEls in the correct order.
                    bindEls.push(addedBindEls[len]);
                }
            }
            return !vwInfos || vwInfos.elCnt;
        }

        function getViewInfos(vwInfos) {
            // Used by view.childTags() and tag.childTags()
            // Similar to processViewInfos in how it steps through bindings to find tags. Only finds data-linked tags.
            var level, parentTag, named;

            if (vwInfos) {
                len = vwInfos.length;
                for (j = 0; j < len; j++) {
                    vwInfo = vwInfos[j];
                    // This is an open marker for a data-linked tag {^{...}}, within the content of the tag whose id is get.id. Add it to bindEls.
                    // Note - if bindingStore[vwInfo.id]._is === "tag" then getViewInfos is being called too soon - during first linking pass
                    parentTag = tag = bindingStore[vwInfo.id].linkCtx.tag;
                    named = tag.tagName === tagName;
                    if (!tag.flow || named) {
                        if (!deep) {
                            level = 1;
                            while (parentTag = parentTag.parent) {
                                level++;
                            }
                            tagDepth = tagDepth || level; // The level of the first tag encountered.
                        }
                        if ((deep || level === tagDepth) && (!tagName || named)) {
                            // Filter on top-level or tagName as appropriate
                            tags.push(tag);
                        }
                    }
                }
            }
        }

        function dataLink() {
            //================ Data-link and fixup of data-jsv annotations ================
            var j, index,
                tokens = "",
                wrap = {},
                selector = linkViewsSel + (get ? ",[" + deferAttr + "]" : "");
            // If a childTags() call, get = ",[" + deferAttr + "]" - since we need to include elements that have a ._df expando for deferred tokens

            elems = qsa ? parentNode.querySelectorAll(selector) : $(selector, parentNode).get();
            l = elems.length;

            // The prevNode will be in the returned query, since we called markPrevOrNextNode() on it.
            // But it may have contained nodes that satisfy the selector also.
            if (prevNode && prevNode.innerHTML) {
                // Find the last contained node of prevNode, to use as the prevNode - so we only link subsequent elems in the query
                prevNodes = qsa ? prevNode.querySelectorAll(selector) : $(selector, prevNode).get();
                prevNode = prevNodes.length ? prevNodes[prevNodes.length - 1] : prevNode;
            }

            tagDepth = 0;
            for (i = 0; i < l; i++) {
                elem = elems[i];
                if (prevNode && !found) {
                    // If prevNode is set, not false, skip linking. If this element is the prevNode, set to false so subsequent elements will link.
                    found = (elem === prevNode);
                } else if (nextNode && elem === nextNode) {
                    // If nextNode is set then break when we get to nextNode
                    if (get) {
                        tokens += markerNodeInfo(elem);
                    }
                    break;
                } else if (elem.parentNode) {
                    // elem has not been removed from DOM
                    if (get) {
                        tokens += markerNodeInfo(elem);
                        if (elem._df) {
                            j = i + 1;
                            while (j < l && elem.contains(elems[j])) {
                                j++;
                            }
                            // Add defered tokens after any tokens on descendant elements of this one
                            wrap[j - 1] = elem._df;
                        }
                        if (wrap[i]) {
                            tokens += wrap[i] || "";
                        }
                    } else {
                        if (isLink && (vwInfo = viewInfos(elem, undefined, rViewMarkers)) && (vwInfo = vwInfo[0])) {
                            // If this is a link(trueOrString ...) call we will avoid re-binding to elems that are within template-rendered views
                            skip = skip ? (vwInfo.id !== skip && skip) : vwInfo.open && vwInfo.id;
                        }
                        if (!skip && processInfos(viewInfos(elem))
                            // If a link() call, processViewInfos() adds bindings to bindEls, and returns true for non-script nodes, for adding data-link bindings
                            // If a childTags() call, getViewInfos returns array of tag bindings.
                                && elem.getAttribute($viewsLinkAttr)) {
                            bindEls.push([elem]); // A data-linked element so add to bindEls too
                        }
                    }
                }
            }

            if (get) {
                tokens += parentNode._df || "";
                if (index = tokens.indexOf("#" + get.id) + 1) {
                    // We are looking for view.childTags() or tag.childTags() - so start after the open token of the parent view or tag.
                    tokens = tokens.slice(index + get.id.length);
                }
                index = tokens.indexOf("/" + get.id);
                if (index + 1) {
                    // We are looking for view.childTags() or tag.childTags() - so don't look beyond the close token of the parent view or tag.
                    tokens = tokens.slice(0, index);
                }
                // Call getViewInfos to add the found childTags to the tags array
                getViewInfos(viewInfos(tokens, undefined, rOpenTagMarkers));
            }

            if (html === undefined && parentNode.getAttribute($viewsLinkAttr)) {
                bindEls.push([parentNode]); // Support data-linking top-level element directly (not within a data-linked container)
            }

            // Remove temporary marker script nodes they were added by markPrevOrNextNode
            unmarkPrevOrNextNode(prevNode, elCnt);
            unmarkPrevOrNextNode(nextNode, elCnt);

            if (get) {
                if (lazyLink) {
                    lazyLink.resolve();
                }
                return; // We have added childTags to the tags array, so we are done
            }

            if (elCnt && defer + ids) {
                // There are some views with elCnt, for which the open or close did not precede any HTML tag - so they have not been processed yet
                elem = nextNode;
                if (defer) {
                    if (nextNode) {
                        processViewInfos(viewInfos(defer + "+", true), nextNode);
                    } else {
                        processViewInfos(viewInfos(defer, true), parentNode);
                    }
                }
                processViewInfos(viewInfos(ids, true), parentNode);
                // If there were any tokens on nextNode which have now been associated with inserted HTML tags, remove them from nextNode
                if (nextNode) {
                    tokens = nextNode.getAttribute(jsvAttrStr);
                    if (l = tokens.indexOf(prevIds) + 1) {
                        tokens = tokens.slice(l + prevIds.length - 1);
                    }
                    nextNode.setAttribute(jsvAttrStr, ids + tokens);
                }
            }

            //================ Bind the data-linked elements and tags ================
            l = bindEls.length;
            for (i = 0; i < l; i++) {
                elem = bindEls[i];
                linkInfo = elem[1];
                elem = elem[0];
                if (linkInfo) {
                    if (tag = bindingStore[linkInfo.id]) {
                        if (linkCtx = tag.linkCtx) {
                            // The tag may have been stored temporarily on the bindingStore - or may have already been replaced by the actual binding
                            tag = linkCtx.tag;
                            tag.linkCtx = linkCtx;
                        }
                        if (linkInfo.open) {
                            // This is an 'open linked tag' binding annotation for a data-linked tag {^{...}}
                            if (elem) {
                                tag.parentElem = elem.parentNode;
                                tag._prv = elem;
                            }
                            tag._elCnt = linkInfo.elCnt;
                            // We data-link depth-first ("on the way in"), which is better for perf - and allows setting parent tags etc.
                            view = tag.tagCtx.view;
                            addDataBinding(undefined, tag._prv, view, linkInfo.id);
                        } else {
                            tag._nxt = elem;
                            if (tag._.unlinked) {
                                // This is a 'close linked tag' binding annotation
                                // Add data binding
                                tagCtx = tag.tagCtx;
                                view = tagCtx.view;
                                callAfterLink(tag);
                            }
                        }
                    }
                } else {
                    // Add data binding for a data-linked element (with data-link attribute)
                    addDataBinding(elem.getAttribute($viewsLinkAttr), elem, $view(elem), undefined, isLink, outerData, context);
                }
            }
            if (lazyLink) {
                lazyLink.resolve();
            }
        }
        //==== /end of nested functions ====

        var inTag, linkCtx, tag, i, l, j, len, elems, elem, view, vwInfo, linkInfo, prevNodes, token, prevView, nextView,
            node, tags, deep, tagName, tagCtx, validate, tagDepth, depth, fragment, copiedNode, firstTag, parentTag,
            isVoid, wrapper, div, tokens, elCnt, prevElCnt, htmlTag, ids, prevIds, found, skip, lazyLink, isLink, get,
            self = this,
            thisId = self._.id + "_",
            defer = "",
            // The marker ids for which no tag was encountered (empty views or final closing markers) which we carry over to container tag
            bindEls = [],
            tagStack = [],
            deferStack = [],
            onAfterCreate = self.hlp(onAfterCreateStr),
            processInfos = processViewInfos;

        if (refresh) {
            lazyLink = refresh.lazyLink && $.Deferred();
            if (refresh.tmpl) {
                // refresh is the prevView, passed in from addViews()
                prevView = "/" + refresh._.id + "_";
            } else {
                isLink = refresh.lnk; // Top-level linking
                if (refresh.tag) {
                    thisId = refresh.tag + "^";
                    refresh = true;
                }
                if (get = refresh.get) {
                    processInfos = getViewInfos;
                    tags = get.tags;
                    deep = get.deep;
                    tagName = get.name;
                }
            }
            refresh = refresh === true;
        }

        parentNode = parentNode
            ? ("" + parentNode === parentNode
                ? $(parentNode)[0]  // It is a string, so treat as selector
                : parentNode.jquery
                    ? parentNode[0] // A jQuery object - take first element.
                    : parentNode)
            : (self.parentElem      // view.link()
                || document.body);  // link(null, data) to link the whole document

        validate = !$subSettingsAdvanced.noValidate && parentNode.contentEditable !== TRUE;
        parentTag = parentNode.tagName.toLowerCase();
        elCnt = !!elContent[parentTag];

        prevNode = prevNode && markPrevOrNextNode(prevNode, elCnt);
        nextNode = nextNode && markPrevOrNextNode(nextNode, elCnt) || null;

        if (html != undefined) {
            //================ Insert html into DOM using documentFragments (and wrapping HTML appropriately). ================
            // Also convert markers to DOM annotations, based on content model.
            // Corresponds to nextNode ? $(nextNode).before(html) : $(parentNode).html(html);
            // but allows insertion to wrap correctly even with inserted script nodes. jQuery version will fail e.g. under tbody or select.
            // This version should also be slightly faster
            div = document.createElement("div");
            wrapper = div;
            prevIds = ids = "";
            htmlTag = parentNode.namespaceURI === "http://www.w3.org/2000/svg" ? "svg_ns" : (firstTag = rFirstElem.exec(html)) && firstTag[1] || "";
            if (elCnt) {
                // Now look for following view, and find its tokens, or if not found, get the parentNode._df tokens
                node = nextNode;
                while (node && !(nextView = viewInfos(node))) {
                    node = node.nextSibling;
                }
                if (tokens = nextView ? nextView._tkns : parentNode._df) {
                    token = prevView || "";
                    if (refresh || !prevView) {
                        token += "#" + thisId;
                    }
                    j = tokens.indexOf(token);
                    if (j + 1) {
                        j += token.length;
                        // Transfer the initial tokens to inserted nodes, by setting them as the ids variable, picked up in convertMarkers
                        prevIds = ids = tokens.slice(0, j);
                        tokens = tokens.slice(j);
                        if (nextView) {
                            node.setAttribute(jsvAttrStr, tokens);
                        } else {
                            setDefer(parentNode, tokens);
                        }
                    }
                }
            }

            //================ Convert the markers to DOM annotations, based on content model. ================
            //			oldElCnt = elCnt;
            isVoid = undefined;
            html = ("" + html).replace(rConvertMarkers, convertMarkers);
            //			if (!!oldElCnt !== !!elCnt) {
            //				error("Parse: " + html); // Parse error. Content not well-formed?
            //			}
            if (validate && tagStack.length) {
                syntaxError("Mismatched '<" + parentTag + "...>' in:\n" + html); // Unmatched tag
            }
            if (validateOnly) {
                return;
            }
            // Append wrapper element to doc fragment
            safeFragment.appendChild(div);

            // Go to html and back, then peel off extra wrappers
            // Corresponds to jQuery $(nextNode).before(html) or $(parentNode).html(html);
            // but supports svg elements, and other features missing from jQuery version (and this version should also be slightly faster)
            htmlTag = wrapMap[htmlTag] || wrapMap.div;
            depth = htmlTag[0];
            wrapper.innerHTML = htmlTag[1] + html + htmlTag[2];
            while (depth--) {
                wrapper = wrapper.lastChild;
            }
            safeFragment.removeChild(div);
            fragment = document.createDocumentFragment();
            while (copiedNode = wrapper.firstChild) {
                fragment.appendChild(copiedNode);
            }
            // Insert into the DOM
            parentNode.insertBefore(fragment, nextNode);
        }

        if (lazyLink) {
            setTimeout(dataLink, 0);
        } else {
            dataLink();
        }

        return lazyLink && lazyLink.promise();
    }

    function addDataBinding(linkMarkup, node, currentView, boundTagId, isLink, data, context) {
        // Add data binding for data-linked elements or {^{...}} data-linked tags
        var tmpl, tokens, attr, convertBack, tagExpr, linkFn, linkCtx, tag, rTagIndex, hasElse, lastIndex,
            linkExpressions = [];

        if (boundTagId) {
            // boundTagId is a string for {^{...}} data-linked tag. So only one linkTag in linkMarkup
            // data and context parameters are undefined
            tag = bindingStore[boundTagId];
            tag = tag.linkCtx ? tag.linkCtx.tag : tag;

            linkCtx = tag.linkCtx || {
                type: "inline",
                data: currentView.data,                   // source
                elem: tag._elCnt ? tag.parentElem : node, // target
                view: currentView,
                ctx: currentView.ctx,
                attr: HTML, // Script marker nodes are associated with {^{ and always target HTML.
                fn: tag._.bnd,
                tag: tag,
                // Pass the boundTagId in the linkCtx, so that it can be picked up in observeAndBind
                _bndId: boundTagId
            };
            bindDataLinkTarget(linkCtx, linkCtx.fn);
        } else if (linkMarkup && node) {
            // If isLink then this is a top-level linking: .link(expression, target, data, ....) or
            // .link(true, target, data, ....) scenario - and data and context are passed in separately from the view
            data = isLink ? data : currentView.data;

            // Compiled linkFn expressions could be stored in the tmpl.links array of the template
            // TODO - consider also caching globally so that if {{:foo}} or data-link="foo" occurs in different places,
            // the compiled template for this is cached and only compiled once...
            //links = currentView.links || currentView.tmpl.links;

            tmpl = currentView.tmpl;

            //			if (!(linkTags = links[linkMarkup])) {
            // This is the first time this view template has been linked, so we compile the data-link expressions, and store them on the template.

            linkMarkup = normalizeLinkTag(linkMarkup, defaultAttr(node));
            lastIndex = rTagDatalink.lastIndex = 0;
            while (tokens = rTagDatalink.exec(linkMarkup)) { // TODO require } to be followed by whitespace or $, and remove the \}(!\}) option.
                linkExpressions.push(tokens);
                lastIndex = rTagDatalink.lastIndex;
            }
            if (lastIndex < linkMarkup.length) {
                syntaxError(linkMarkup);
            }
            while (tokens = linkExpressions.shift()) {
                // Iterate over the data-link expressions, for different target attrs,
                // e.g. <input data-link="{:firstName:} title{>~description(firstName, lastName)}"
                // tokens: [all, attr, bindOnly, tagExpr, tagName, converter, colon, html, comment, code, params]
                rTagIndex = rTagDatalink.lastIndex;
                attr = tokens[1];
                tagExpr = tokens[3];
                while (linkExpressions[0] && linkExpressions[0][4] === "else") { // If this is {someTag...} and is followed by an {else...} add to tagExpr
                    tagExpr += delimCloseChar1 + delimOpenChar0 + linkExpressions.shift()[3];
                    hasElse = true;
                }
                if (hasElse) { // If an {else} has been added, need also to add closing {{/someTag}}
                    tagExpr += delimCloseChar1 + delimOpenChar0 + delimOpenChar1 + "/" + tokens[4] + delimCloseChar0;
                }
                linkCtx = {
                    type: isLink ? "top" : "link",
                    data: data, // source
                    elem: node, // target
                    view: currentView,
                    ctx: context,
                    attr: attr,
                    isLk: isLink, // top-level linking?
                    _toLk: 1, // Flag to data-link on initial data-link call rendering call
                    _noUpd: tokens[2] // Flag for data-link="^{...}" so on initial data-link call will bind, but not render)
                };

                convertBack = undefined;
                if (tokens[6]) {
                    convertBack = tokens[10] || undefined;
                    linkCtx.convert = tokens[5] || "";
                    if (!attr && convertBack !== undefined && defaultAttr(node)) {
                        // Default target, so allow 2 way binding
                        linkCtx.convertBack = convertBack = convertBack.slice(1);
                    }
                }
                // Compile the linkFn expression which evaluates and binds a data-link expression
                // TODO - optimize for the case of simple data path with no conversion, helpers, etc.:
                //     i.e. data-link="a.b.c". Avoid creating new instances of Function every time. Can use a default function for all of these...

                linkCtx.expr = attr + tagExpr;
                linkFn = tmpl.links[tagExpr];
                if (!linkFn) {
                    tmpl.links[tagExpr] = linkFn = $sub.tmplFn(tagExpr, tmpl, true, convertBack, hasElse);
                }
                linkCtx.fn = linkFn;
                bindDataLinkTarget(linkCtx, linkFn);
                // We store rTagIndex in local scope, since this addDataBinding method can sometimes be called recursively,
                // and each is using the same rTagDatalink instance.
                rTagDatalink.lastIndex = rTagIndex;
            }
            //		}
        }
    }

    function bindDataLinkTarget(linkCtx, linkFn) {
        // Add data link bindings for a link expression in data-link attribute markup
        function handler(ev, eventArgs) {
            propertyChangeHandler.call(linkCtx, ev, eventArgs, linkFn);
            // If the link expression uses a custom tag, the propertyChangeHandler call will call renderTag, which will set tagCtx on linkCtx
        }
        handler.noArray = true;
        if (linkCtx.isLk) {
            // Top-level linking: .link(expressionOrTrue, data, context) - so we need to create a view for the linking, with the data and ctx
            // which may be different than the current context of the target. Note that this view is not a standard data-linked view, so it will
            // be disposed only when its parent view is disposed.
            addLinkMethods(linkCtx.view = new $sub.View(
                $sub.extendCtx(linkCtx.ctx, linkCtx.view.ctx),
                "link", linkCtx.view, linkCtx.data, linkCtx.expr, undefined, addBindingMarkers));
        }
        linkCtx._ctxCb = getContextCb(linkCtx.view); // _ctxCb is for filtering/appending to dependency paths: function(path, object) { return [(object|path)*]}
        linkCtx._hdl = handler;
        // handler._ctx = linkCtx; Could pass linkCtx for use in a depends = function() {} call, so depends is different for different linkCtx's
        handler(true);
    }

    //=====================
    // Data-linking helpers
    //=====================

    function removeSubStr(str, substr) {
        var k;
        return str
            ? (k = str.indexOf(substr),
                (k + 1
                    ? str.slice(0, k) + str.slice(k + substr.length)
                    : str))
            : "";
    }

    function markerNodeInfo(node) {
        return node &&
            ("" + node === node
                ? node
                : node.tagName === SCRIPT
                    ? node.type.slice(3)
                    : node.nodeType === 1 && node.getAttribute(jsvAttrStr) || "");
    }

    function viewInfos(node, isVal, rBinding) {
        // Test whether node is a script marker node, and if so, return metadata
        function getInfos(all, open, close, id, ch, elPath) {
            infos.push({
                elCnt: elCnt,
                id: id,
                ch: ch,
                open: open,
                close: close,
                path: elPath,
                token: all
            });
        }
        var elCnt, tokens,
            infos = [];
        if (tokens = isVal ? node : markerNodeInfo(node)) {
            elCnt = infos.elCnt = node.tagName !== SCRIPT;
            elCnt = tokens.charAt(0) === "@" || elCnt;
            infos._tkns = tokens;
            // rMarkerTokens = /(?:(#)|(\/))(\d+)([_^])([-+@\d]+)?/g;
            tokens.replace(rBinding || rMarkerTokens, getInfos);
            return infos;
        }
    }

    function unmarkPrevOrNextNode(node, elCnt) {
        if (node) {
            if (node.type === "jsv") {
                node.parentNode.removeChild(node);
            } else if (elCnt && node.getAttribute($viewsLinkAttr) === "") {
                node.removeAttribute($viewsLinkAttr);
            }
        }
    }

    function markPrevOrNextNode(node, elCnt) {
        var marker = node;
        while (elCnt && marker && marker.nodeType !== 1) {
            marker = marker.previousSibling;
        }
        if (marker) {
            if (marker.nodeType !== 1) {
                // For text nodes, we will add a script node before
                marker = document.createElement(SCRIPT);
                marker.type = "jsv";
                node.parentNode.insertBefore(marker, node);
            } else if (!markerNodeInfo(marker) && !marker.getAttribute($viewsLinkAttr)) {
                // For element nodes, we will add a data-link attribute (unless there is already one)
                // so that this node gets included in the node linking process.
                marker.setAttribute($viewsLinkAttr, "");
            }
        }
        return marker;
    }

    function normalizeLinkTag(linkMarkup, twoway) {
        linkMarkup = $.trim(linkMarkup).replace(rEscapeQuotes, "\\$&");
        return linkMarkup.slice(-1) !== delimCloseChar0
        // If simplified syntax is used: data-link="expression", convert to data-link="{:expression}",
        // or for inputs, data-link="{:expression:}" for (default) two-way binding
            ? linkMarkup = delimOpenChar1 + ":" + linkMarkup + (twoway ? ":" : "") + delimCloseChar0
            : linkMarkup;
    }

    //===========================
    // Methods for views and tags
    //===========================

    function callAfterLink(tag, ev, eventArgs) {
        var $linkedElem, linkedElem, radioButtons, val, l, linkedTag, oldTrig, newTrig, tagProps, propsExpr, linkedElemView, prop, propDef,
            tagCtx = tag.tagCtx,
            view = tagCtx.view,
            props = tagCtx.props,
            linkCtx = tag.linkCtx;

        if (tag._.unlinked) { // First call to onAfterLink, or first call after onUpdate: updateContent. Initialize and call onBind and set properties
            if (tag.linkedElement !== undefined) {
                // linkedElement: - selector for identifying linked element in template/rendered content
                tag.linkedElem = tag._.inline ? tag.contents(true, tag.linkedElement || "*").first() : $(linkCtx.elem);
            }
            if (tag.onBind) {
                tag.onBind(tagCtx, linkCtx, tag.ctx, ev, eventArgs);
            }
        }

        if (tag.onAfterLink) {
            tag.onAfterLink(tagCtx, linkCtx, tag.ctx, ev, eventArgs);
        }

        tag._.unlinked = undefined;
        $linkedElem = tag.targetTag ? tag.targetTag.linkedElem : tag.linkedElem;
        if (linkedElem = $linkedElem && $linkedElem[0]) {
            if (!tag.noVal) {
                if (!tag._.chging) {
                    val = tag.cvtArgs()[0];

                    if (linkedElem !== linkCtx.elem) {
                        l = $linkedElem.length;
                        while (l--) {
                            linkedElem = $linkedElem[l];
                            linkedTag = linkedElem._jsvLkEl;
                            if (tag._.inline && (!linkedTag || linkedTag !== tag && linkedTag.targetTag !== tag)) {
                                // For data-linked tags, identify the linkedElem with the tag, for "to" binding
                                // (For data-linked elements, if not yet bound, we identify later when the linkCtx.elem is bound)
                                linkedElem._jsvLkEl = tag;
                                bindTo(bindingStore[tag._tgId], tag, linkedElem);
                                linkedElem._jsvBnd = "&" + tag._tgId + "+"; // Add a "+" for cloned binding - so removing
                                // elems with cloned bindings will not remove the 'parent' binding from the bindingStore.
                            }
                        }
                        linkCtx._val = val;
                    }
                    if (val !== undefined) {
                        if (linkedElem.value !== undefined) {
                            if (linkedElem.type === CHECKBOX) {
                                linkedElem[CHECKED] = val && val !== "false";
                            } else if (linkedElem.type === "text") {
                                linkedElem.value = val;
                            }
                        } else if (linkedElem.contentEditable === TRUE) {
                            linkedElem.innerHTML = val;
                        }
                    }
                }
            }
            if (tag.setSize) {
                if (props.height) {
                    $linkedElem.height(props.height);
                }
                if (props.width) {
                    $linkedElem.width(props.width);
                }
            }
            if (props.title !== undefined) {
                $linkedElem.attr("title", props.title);
            }
            if (props["class"]) {
                // This code supports dynamic binding to class - where it adds the class if absent, and removes/adds if a previous value is present
                if (eventArgs && $linkedElem.hasClass(eventArgs.oldValue)) {
                    $linkedElem.removeClass(eventArgs.oldValue);
                }
                $linkedElem.addClass(props["class"]);
            }
            if (props.id) {
                $linkedElem[0].id = props.id;
            }
            if (props.name) {
                $linkedElem.attr("name", props.name);
            }
        }
    }

    function asyncElemChangeHandler(ev) {
        setTimeout(function () {
            elemChangeHandler(ev);
        }, 0);
    }

    function bindElChange($elem, trig, onoff) {
        if (trig) {
            trig = "" + trig === trig ? trig : "keydown"; // Set trigger to (true || truey non-string (e.g. 1) || 'keydown'): Get 'keydown' with async
            $elem[onoff](trig, trig === "keydown" ? asyncElemChangeHandler : elemChangeHandler);
        }
    }

    function bindTo(binding, tag, linkedElem, cvtBk) {
        // Two-way binding.
        // We set the binding.to[1] to be the cvtBack, and binding.to[0] to be either the path to the target, or [object, path] where the target is the path on the provided object.
        // So for a computed path with an object call: a.b.getObject().d.e, then we set to[0] to be [exprOb, "d.e"], and we bind to the path on the returned object, exprOb.ob, as target
        // Otherwise our target is the first path, paths[0], which we will convert with contextCb() for paths like ~a.b.c or #x.y.z

        var bindto, pathIndex, path, lastPath, bindtoOb, $linkedElem, newTrig, oldTrig, to, l, totry,
            linkCtx = binding.linkCtx,
            source = linkCtx.data,
            paths = linkCtx.fn.paths;

        tag = tag || linkedElem._jsvLkEl;

        if (binding && paths) {
            oldTrig = linkedElem._jsvTr || false;
            if (tag) {
                cvtBk = tag.convertBack || cvtBk;
                newTrig = tag.tagCtx.props.trigger;
            }
            newTrig = newTrig === undefined ? $subSettings.trigger : newTrig;
            if (oldTrig !== newTrig) {
                $linkedElem = $(linkedElem);
                bindElChange($linkedElem, oldTrig, "off");
                bindElChange(
                    $linkedElem,
                    linkedElem._jsvTr
                        // Trigger is noop except for text box, textarea, contenteditable...
                        = (linkedElem.tagName === "INPUT" && linkedElem.type !== CHECKBOX && linkedElem.type !== RADIO || linkedElem.type === "textarea" || linkedElem.contentEditable === TRUE) && newTrig,
                    "on"
                );
            }

            paths = (bindto = paths._jsvto) || paths[0];
            pathIndex = paths && paths.length;
            if (pathIndex && (!tag || tag.tagCtx.args.length)) {
                lastPath = paths[pathIndex - 1];
                if (lastPath._jsv) {
                    bindtoOb = lastPath;
                    while (lastPath.sb && lastPath.sb._jsv) {
                        path = lastPath = lastPath.sb;
                    }
                    path = lastPath.sb || path && path.path;
                    lastPath = path ? path.slice(1) : bindtoOb.path;
                }
                if (path) {
                    to = [
                            bindtoOb, // 'exprOb' for this expression and view-binding. So bindtoOb.ob is current object returned by expression.
                            lastPath
                    ];
                } else {
                    while ((totry = linkCtx._ctxCb(path = lastPath.split("^").join("."), source)) && (l = totry.length)) {
                        // Recursively dereference any ~foo or #bar tokens in the path. (Recursive because ~foo may be a contextual param which has
                        // its own dependencies on other ~foo #bar components)
                        to = totry;
                        if (to._cp) { // Two-way binding to a contextual parameter reference, ~foo (declared as ~foo=expr on a parent tag)
                            to = [to[l - 3], to[l - 2]];
                            lastPath = to[1];
                            if (lastPath._jsv) {
                                bindtoOb = lastPath;
                                while (lastPath.sb && lastPath.sb._jsv) {
                                    path = lastPath = lastPath.sb;
                                }
                                path = lastPath.sb || path && path.path;
                                lastPath = path ? path.slice(1) : bindtoOb.path;
                                to = [
                                    bindtoOb, // 'exprOb' for this expression and view-binding. So bindtoOb.ob is current object returned by expression.
                                    lastPath
                                ];
                            }
                        } else { // Two-way binding to a helper - e.g. ~address.street, or computed, e.g. ~fullName(), or view property e.g. #data.foo
                            to = l > 2
                                ? [to[l - 3], to[l - 2]] // With path: [object, path]
                                : [to[l - 2]];         // No path, (e.g. [function] for computed with setter)
                        }
                        source = to[0];
                        lastPath = to[1];
                    }
                    to = to || [source, path]; // Two way binding to an object (neither ~foo nor #bar)
                }
            } else {
                to = [];
            }
            binding.to = [
                to,
                cvtBk
            ];
        }
    }

    function mergeCtxs(tag, newCtxs, replace) { // Merge updated tagCtxs into tag.tagCtxs
        var tagCtx, newTagCtx,
            view = tag.tagCtx.view,
            tagCtxs = tag.tagCtxs || [tag.tagCtx],
            l = tagCtxs.length,
            refresh = !newCtxs;

        newCtxs = newCtxs || tag._.bnd.call(view.tmpl, (tag.linkCtx || view).data, view, $sub);

        if (replace) {
            // Replace previous tagCtxs by new ones, rather than merging
            tagCtxs = tag.tagCtxs = newCtxs;
            tag.tagCtx = tagCtxs[0];
        } else {
            while (l--) {
                tagCtx = tagCtxs[l];
                newTagCtx = newCtxs[l];
                $observable(tagCtx.props).setProperty(newTagCtx.props);
                $extend(tagCtx.ctx, newTagCtx.ctx); // We don't support propagating ctx variables, ~foo, observably, to nested views. So extend, not setProperty...
                tagCtx.args = newTagCtx.args;
                if (refresh) {
                    tagCtx.tmpl = newTagCtx.tmpl;
                }
            }
        }
        $sub._ths(tag, tagCtxs[0]); // tagHandlersFromProps
        return tagCtxs;
    }

    //=========
    // Disposal
    //=========

    function clean(elems) {
        // Remove data-link bindings, or contained views
        var l, elem, bindings,
            elemArray = [],
            len = elems.length,
            i = len;
        while (i--) {
            // Copy into an array, so that deletion of nodes from DOM will not cause our 'i' counter to get shifted
            // (Note: This seems as fast or faster than elemArray = [].slice.call(elems); ...)
            elemArray.push(elems[i]);
        }
        i = len;
        while (i--) {
            elem = elemArray[i];
            if (elem.parentNode) {
                // Has not already been removed from the DOM
                if (bindings = elem._jsvBnd) {
                    // Get propertyChange bindings for this element
                    // This may be an element with data-link, or the opening script marker node for a data-linked tag {^{...}}
                    // bindings is a string with the syntax: "(&bindingId)*"
                    bindings = bindings.slice(1).split("&");
                    elem._jsvBnd = "";
                    l = bindings.length;
                    while (l--) {
                        // Remove associated bindings
                        removeViewBinding(bindings[l], elem._jsvLkEl, elem); // unbind bindings with this bindingId on this view
                    }
                }
                disposeTokens(markerNodeInfo(elem) + (elem._df || ""));
            }
        }
    }

    function removeViewBinding(bindId, linkedElemTag, elem) {
        // Unbind
        var objId, linkCtx, tag, object, obsId, tagCtxs, l, map, $linkedElem, linkedElem, trigger, view,
            binding = bindingStore[bindId];

        if (linkedElemTag) {
            if (elem === linkedElemTag.linkedElem[0]) {
                elem._jsvLkEl = undefined;
                linkedElemTag.linkedElem = undefined;
            }
        } else if (binding) {
            delete bindingStore[bindId]; // Delete already, so call to onDispose handler below cannot trigger recursive deletion (through recursive call to jQuery cleanData)
            for (objId in binding.bnd) {
                object = binding.bnd[objId];
                obsId = binding.cbId;
                if ($isArray(object)) {
                    $([object]).off(arrayChangeStr + obsId).off(propertyChangeStr + obsId); // There may be either or both of arrayChange and propertyChange
                } else {
                    $(object).off(propertyChangeStr + obsId);
                }
                delete binding.bnd[objId];
            }

            if (linkCtx = binding.linkCtx) {
                if (tag = linkCtx.tag) {
                    if (tagCtxs = tag.tagCtxs) {
                        l = tagCtxs.length;
                        while (l--) {
                            if (map = tagCtxs[l].map) {
                                map.unmap(); //unobserve
                            }
                        }
                    }
                    $linkedElem = tag.linkedElem;

                    if (tag.onUnbind) {
                        tag.onUnbind(tag.tagCtx, linkCtx, tag.ctx, true);
                    }
                    if (tag.onDispose) {
                        tag.onDispose();
                    }

                    if (!tag._elCnt) {
                        if (tag._prv) {
                            tag._prv.parentNode.removeChild(tag._prv);
                        }
                        if (tag._nxt) {
                            tag._nxt.parentNode.removeChild(tag._nxt);
                        }
                    }
                }
                linkedElem = $linkedElem && $linkedElem[0] || linkCtx.elem;

                if (trigger = linkedElem && linkedElem._jsvTr) {
                    bindElChange($linkedElem || $(linkedElem), trigger, "off");
                    linkedElem._jsvTr = undefined;
                }
                view = linkCtx.view;
                if (view.type === "link") {
                    view.parent.removeViews(view._.key, undefined, true); // A "link" view is associated with the binding, so should be disposed with binding.
                } else {
                    delete view._.bnds[bindId];
                }
            }
            delete cbBindingsStore[binding.cbId];
        }
    }

    function $unlink(to) {
        if (to) {
            to = to.jquery ? to : $(to);
            to.each(function () {
                var innerView;
                //TODO fix this for better perf. Rather that calling inner view multiple times which does querySelectorAll each time, consider a single querySelectorAll
                // or simply call view.removeViews() on the top-level views under the target 'to' node, then clean(...)
                while ((innerView = $view(this, true)) && innerView.parent) {
                    innerView.parent.removeViews(innerView._.key, undefined, true);
                }
                clean(this.getElementsByTagName("*"));
            });
            clean(to);
        } else {
            // Call to $.unlink() is equivalent to $.unlink(true, "body")
            if (activeBody) {
                $(activeBody)
                    .off(elementChangeStr, elemChangeHandler)
                    .off('blur', '[contenteditable]', elemChangeHandler);
                activeBody = undefined;
            }
            topView.removeViews();
            clean(document.body.getElementsByTagName("*"));
        }
    }

    //========
    // Helpers
    //========

    function getContextCb(view) { // Return a callback for accessing the context of a template/data-link expression - and converting ~foo, #foo etc.
        // TODO Consider exposing or allowing override, as public API
        return function (path, object, depth) {
            // TODO consider only calling the contextCb on the initial token in path '~a.b.c' and not calling again on
            // the individual tokens, 'a', 'b', 'c'... Currently it is called multiple times
            var tokens, tag, items, helper, last, nextPath, l;
            if (view && path) {
                if (path._jsv) {
                    return path._jsv.call(view.tmpl, object, view, $sub);
                }
                if (path.charAt(0) === "~") {
                    // We return new items to insert into the sequence, replacing the "~a.b.c" string:
                    // [helperObject 'a', "a.b.c" currentDataItem] so currentDataItem becomes the object for subsequent paths.
                    if (path.slice(0, 4) === "~tag") {
                        tag = view.ctx;
                        if (path.charAt(4) === ".") {
                            // "~tag.xxx"
                            tokens = path.slice(5).split(".");
                            tag = tag.tag;
                        }
                        if (tokens) {
                            return tag ? [tag, tokens.join("."), object] : [];
                        }
                    }
                    path = path.slice(1).split(".");
                    if (helper = view.hlp(last = path.shift(), true)) {
                        if (helper._cp) {  // helper for (contextual parameter ~foo=...) is an array - [data, ctxPrmDependencies ...]
                            if (path.length) {
                                nextPath = "." + path.join(".");
                                last = helper[l = helper.length - 1];
                                if (last._jsv) {
                                    last.sb = nextPath;
                                    last.bnd = !!depth;
                                } else {
                                    helper[l] = (last + nextPath).replace("#data.", "");
                                    if (last.slice(0, 5) === "#view") {
                                        helper[l] = helper[l].slice(6);
                                        helper.splice(l, 0, view);
                                    }
                                }
                            }
                            helper.push(object);
                            items = helper;
                        } else if (path.length || $isFunction(helper)) {
                            items = [helper, path.join("."), object]; // 2way bindng on ~foo.helperLeafProperty or ~computed() or ~contextualParam
                        }
                    }
                    return items || [];
                }
                if (path.charAt(0) === "#") {
                    // We return new items to insert into the sequence, replacing the "#a.b.c" string: [view, "a.b.c" currentDataItem]
                    // so currentDataItem becomes the object for subsequent paths. The 'true' flag makes the paths bind only to leaf changes.
                    return path === "#data" ? [] : [view, path.replace(rViewPath, ""), object];
                }
            }
        };
    }

    function inputAttrib(elem) {
        return elem.type === CHECKBOX ? elem[CHECKED] : elem.value;
    }

    //========================== Initialize ==========================

    //=====================
    // JsRender integration
    //=====================

    $sub.onStore.template = function (name, item) {
        item.link = tmplLink;
        if (name) {
            $.link[name] = function () {
                return tmplLink.apply(item, arguments);
            };
        }
    };

    $sub.viewInfos = viewInfos; // Expose viewInfos() as public helper method

    // Define JsViews version of delimiters(), and initialize
    ($viewsSettings.delimiters = function () {
        // Run delimiters initialization in context of jsrender.js
        var ret = oldJsvDelimiters.apply(0, arguments);

        if (oldJsvDelimiters !== $viewsDelimiters) {
            // If JsRender was loaded before JsViews, then need also to initialize and set globals in that JsRender instance
            ret = $viewsDelimiters.apply(0, arguments);
        }

        // Data-linking must use new delimiters
        rTagDatalink = new RegExp("(?:^|\\s*)([\\w-]*)(\\" + linkChar + ")?(\\" + delimOpenChar1 + $sub.rTag + "(:\\w*)?\\" + delimCloseChar0 + ")", "g");
        return ret;
    })(); // jshint ignore:line

    $sub.addSetting("trigger");

    //====================================
    // Additional members for linked views
    //====================================

    function transferViewTokens(prevNode, nextNode, parentElem, id, viewOrTagChar, refresh) {
        // Transfer tokens on prevNode of viewToRemove/viewToRefresh to nextNode or parentElem._df
        var i, l, vwInfos, vwInfo, viewOrTag, viewId, tokens,
            precedingLength = 0,
            emptyView = prevNode === nextNode;

        if (prevNode) {
            // prevNode is either the first node in the viewOrTag, or has been replaced by the vwInfos tokens string
            vwInfos = viewInfos(prevNode) || [];
            for (i = 0, l = vwInfos.length; i < l; i++) {
                // Step through views or tags on the prevNode
                vwInfo = vwInfos[i];
                viewId = vwInfo.id;
                if (viewId === id && vwInfo.ch === viewOrTagChar) {
                    if (refresh) {
                        // This is viewOrTagToRefresh, this is the last viewOrTag to process...
                        l = 0;
                    } else {
                        // This is viewOrTagToRemove, so we are done...
                        break;
                    }
                }
                if (!emptyView) {
                    viewOrTag = vwInfo.ch === "_"
                        ? viewStore[viewId]
                        : bindingStore[viewId].linkCtx.tag;
                    if (vwInfo.open) {
                        // A "#m" token
                        viewOrTag._prv = nextNode;
                    } else if (vwInfo.close) {
                        // A "/m" token
                        viewOrTag._nxt = nextNode;
                    }
                }
                precedingLength += viewId.length + 2;
            }

            if (precedingLength) {
                prevNode.setAttribute(jsvAttrStr, prevNode.getAttribute(jsvAttrStr).slice(precedingLength));
            }
            tokens = nextNode ? nextNode.getAttribute(jsvAttrStr) : parentElem._df;
            if (l = tokens.indexOf("/" + id + viewOrTagChar) + 1) {
                tokens = vwInfos._tkns.slice(0, precedingLength) + tokens.slice(l + (refresh ? -1 : id.length + 1));
            }
            if (tokens) {
                if (nextNode) {
                    // If viewOrTagToRemove was an empty viewOrTag, we will remove both #n and /n
                    // (and any intervening tokens) from the nextNode (=== prevNode)
                    // If viewOrTagToRemove was not empty, we will take tokens preceding #n from prevNode,
                    // and concatenate with tokens following /n on nextNode
                    nextNode.setAttribute(jsvAttrStr, tokens);
                } else {
                    setDefer(parentElem, tokens);
                }
            }
        } else {
            // !prevNode, so there may be a deferred nodes token on the parentElem. Remove it.
            setDefer(parentElem, removeSubStr(parentElem._df, "#" + id + viewOrTagChar));
            if (!refresh && !nextNode) {
                // If this viewOrTag is being removed, and there was no .nxt, remove closing token from deferred tokens
                setDefer(parentElem, removeSubStr(parentElem._df, "/" + id + viewOrTagChar));
            }
        }
    }

    function disposeTokens(tokens) {
        var i, l, vwItem, vwInfos;
        if (vwInfos = viewInfos(tokens, true, rOpenMarkers)) {
            for (i = 0, l = vwInfos.length; i < l; i++) {
                vwItem = vwInfos[i];
                if (vwItem.ch === "_") {
                    if ((vwItem = viewStore[vwItem.id]) && vwItem.type) {
                        // If this is the _prv (prevNode) for a view, remove the view
                        // - unless view.type is undefined, in which case it is already being removed
                        vwItem.parent.removeViews(vwItem._.key, undefined, true);
                    }
                } else {
                    removeViewBinding(vwItem.id); // unbind bindings with this bindingId on this view
                }
            }
        }
    }

    //====================================
    // Add link methods to data-linked view or tag
    //====================================
    function addLinkMethods(tagOrView, isTag) {

        tagOrView.contents = function (deep, select) {
            // For a view or a tag, return jQuery object with the content nodes,
            if (deep !== !!deep) {
                // deep not boolean, so this is contents(selector)
                select = deep;
                deep = undefined;
            }
            var filtered,
                nodes = $(this.nodes());
            if (nodes[0]) {
                filtered = select ? nodes.filter(select) : nodes;
                nodes = deep && select ? filtered.add(nodes.find(select)) : filtered;
            }
            return nodes;
        };

        tagOrView.nodes = function (withMarkers, prevNode, nextNode) {
            // For a view or a tag, return top-level nodes
            // Do not return any script marker nodes, unless withMarkers is true
            // Optionally limit range, by passing in prevNode or nextNode parameters

            var node,
                self = this,
                elCnt = self._elCnt,
                prevIsFirstNode = !prevNode && elCnt,
                nodes = [];

            prevNode = prevNode || self._prv;
            nextNode = nextNode || self._nxt;

            node = prevIsFirstNode
                ? (prevNode === self._nxt
                    ? self.parentElem.lastSibling
                    : prevNode)
                : (self._.inline === false
                    ? prevNode || self.linkCtx.elem.firstChild
                    : prevNode && prevNode.nextSibling);

            while (node && (!nextNode || node !== nextNode)) {
                if (withMarkers || elCnt || node.tagName !== SCRIPT) {
                    // All the top-level nodes in the view
                    // (except script marker nodes, unless withMarkers = true)
                    // (Note: If a script marker node, viewInfo.elCnt undefined)
                    nodes.push(node);
                }
                node = node.nextSibling;
            }
            return nodes;
        };

        tagOrView.childTags = function (deep, tagName) {
            // For a view or a tag, return child tags - at any depth, or as immediate children only.
            if (deep !== !!deep) {
                // deep not boolean, so this is childTags(tagName) - which looks for top-level tags of given tagName
                tagName = deep;
                deep = undefined;
            }

            var self = this,
                view = self.link ? self : self.tagCtx.view, // this may be a view or a tag. If a tag, get the view from tag.view.tagCtx
                prevNode = self._prv,
                elCnt = self._elCnt,
                tags = [];

            view.link(
                undefined,
                self.parentElem,
                elCnt ? prevNode && prevNode.previousSibling : prevNode,
                self._nxt,
                undefined,
                {
                    get: {
                        tags: tags,
                        deep: deep,
                        name: tagName,
                        id: self.link ? self._.id + "_" : self._tgId + "^"
                    }
                }
            );
            return tags;
        };

        tagOrView.refresh = function (sourceValue) {
            var promise, attr,
                tag = this,
                linkCtx = tag.linkCtx,
                view = tag.tagCtx.view;

            if (tag.disposed) { error("Removed tag"); }
            if (sourceValue === undefined) {
                sourceValue = $sub._tag(tag, view, view.tmpl, mergeCtxs(tag), true); // Get rendered HTML for tag, based on refreshed tagCtxs
            }
            if (sourceValue + "" === sourceValue) {
                // If no rendered content, sourceValue will not be a string (can be 0 or undefined)
                attr = tag._.inline ? HTML : (linkCtx.attr || defaultAttr(tag.parentElem, true));
                promise = updateContent(sourceValue, linkCtx, attr, tag);
            }

            callAfterLink(tag);
            return promise || tag;
        };

        tagOrView.update = function (value) {
            var linkedElem = this.linkedElem;
            if (linkedElem) {
                elemChangeHandler({
                    target: linkedElem[0]
                }, undefined, value);
            }
        };

        if (isTag) {
            // This is a TAG
            tagOrView.domChange = function () { // domChange notification support
                var elem = this.parentElem,
                    hasListener = $.hasData(elem) && $._data(elem).events,
                    domChangeNotification = "jsv-domchange";

                if (hasListener && hasListener[domChangeNotification]) {
                    // Only trigger handler if there is a handler listening for this event. (Note using triggerHandler - so no event bubbling.)
                    $(elem).triggerHandler(domChangeNotification, arguments);
                }
            };
        } else {
            // This is a VIEW
            // Note: a linked view will also, after linking have nodes[], _prv (prevNode), _nxt (nextNode) ...
            tagOrView.addViews = function (index, dataItems) {
                // if view is not an array view, do nothing
                var i, viewsCount,
                    self = this,
                    itemsCount = dataItems.length,
                    views = self.views;

                if (!self._.useKey && itemsCount) {
                    // view is of type "array"
                    viewsCount = views.length + itemsCount;

                    if (viewsCount === self.data.length // If views not already synced to array (e.g. triggered by array.length propertyChange - jsviews/issues/301)
                            && renderAndLink(self, index, self.tmpl, views, dataItems, self.ctx) !== false) {
                        if (!self._.srt) { // Not part of a 'sort' on refresh
                            self.fixIndex(index + itemsCount);
                        }
                    }
                }
            };

            tagOrView.removeViews = function (index, itemsCount, keepNodes, isMove) {
                // view.removeViews() removes all the child views
                // view.removeViews(index) removes the child view with specified index or key
                // view.removeViews(index, count) removes the specified nummber of child views, starting with the specified index
                function removeView(index) {
                    var id, bindId, parentElem, prevNode, nextNode, nodesToRemove,
                        viewToRemove = views[index];

                    if (viewToRemove && viewToRemove.link) {
                        id = viewToRemove._.id;
                        if (!keepNodes) {
                            // Remove the HTML nodes from the DOM, unless they have already been removed, including nodes of child views
                            nodesToRemove = viewToRemove.nodes();
                        }

                        // Remove child views, without removing nodes
                        viewToRemove.removeViews(undefined, undefined, true);

                        viewToRemove.type = undefined; // Set type to undefined: used as a flag that this view is being removed
                        prevNode = viewToRemove._prv;
                        nextNode = viewToRemove._nxt;
                        parentElem = viewToRemove.parentElem;
                        // If prevNode and nextNode are the same, the view is empty
                        if (!keepNodes) {
                            // Remove the HTML nodes from the DOM, unless they have already been removed, including nodes of child views
                            if (viewToRemove._elCnt) {
                                // if keepNodes is false (and transferring of tokens has not already been done at a higher level)
                                // then transfer tokens from prevNode which is being removed, to nextNode.
                                transferViewTokens(prevNode, nextNode, parentElem, id, "_");
                            }
                            $(nodesToRemove).remove();
                        }
                        if (!viewToRemove._elCnt) {
                            try {
                                prevNode.parentNode.removeChild(prevNode); // (prevNode.parentNode is parentElem, except if jQuery Mobile or similar has inserted an intermediate wrapper
                                nextNode.parentNode.removeChild(nextNode);
                            } catch (e) { }
                        }
                        setArrayChangeLink(viewToRemove);
                        for (bindId in viewToRemove._.bnds) {
                            removeViewBinding(bindId);
                        }
                        delete viewStore[id];
                    }
                }

                var current, view, viewsCount,
                    self = this,
                    isArray = !self._.useKey,
                    views = self.views;

                if (isArray) {
                    viewsCount = views.length;
                }
                if (index === undefined) {
                    // Remove all child views
                    if (isArray) {
                        // views and data are arrays
                        current = viewsCount;
                        while (current--) {
                            removeView(current);
                        }
                        self.views = [];
                    } else {
                        // views and data are objects
                        for (view in views) {
                            // Remove by key
                            removeView(view);
                        }
                        self.views = {};
                    }
                } else {
                    if (itemsCount === undefined) {
                        if (isArray) {
                            // The parentView is data array view.
                            // Set itemsCount to 1, to remove this item
                            itemsCount = 1;
                        } else {
                            // Remove child view with key 'index'
                            removeView(index);
                            delete views[index];
                        }
                    }
                    if (isArray && itemsCount
                        && (isMove || viewsCount - itemsCount === self.data.length)) { // If views not already synced to array (e.g. triggered by array.length propertyChange - jsviews/issues/301)
                        current = index + itemsCount;
                        // Remove indexed items (parentView is data array view);
                        while (current-- > index) {
                            removeView(current);
                        }
                        views.splice(index, itemsCount);
                        if (!self._.sort) {
                            self.fixIndex(index);
                        }
                    }
                }
            };

            tagOrView.refresh = function () {
                var self = this,
                    parent = self.parent;

                if (parent) {
                    renderAndLink(self, self.index, self.tmpl, parent.views, self.data, undefined, true);
                    setArrayChangeLink(self);
                }
            };

            tagOrView.fixIndex = function (fromIndex) {
                // Fixup index on following view items...
                var views = this.views,
                    index = views.length;
                while (fromIndex < index--) {
                    if (views[index].index !== index) {
                        $observable(views[index]).setProperty("index", index);
                        // This is fixing up index, but not key, and not index on child views. From child views, use view.getIndex()
                    }
                }
            };

            tagOrView.link = viewLink;
        }
    }

    //========================
    // JsViews-specific converters
    //========================

    $converters.merge = function (val) {
        // Special converter used in data-linking to space-separated lists, such as className:
        // Currently only supports toggle semantics - and has no effect if toggle string is not specified
        // data-link="class{merge:boolExpr toggle=className}"
        var regularExpression,
            currentValue = this.linkCtx._val || "",
            toggle = this.tagCtx.props.toggle;

        if (toggle) {
            // We are toggling the class specified by the toggle property,
            // and the boolean val binding is driving the insert/remove toggle

            regularExpression = toggle.replace(/[\\^$.|?*+()[{]/g, "\\$&");
            // Escape any regular expression special characters (metacharacters) within the toggle string
            regularExpression = "(\\s(?=" + regularExpression + "$)|(\\s)|^)(" + regularExpression + "(\\s|$))";
            // Example: /(\s(?=myclass$)|(\s)|^)?(myclass(\s|$))/ - so matches (" myclass" or " " or ^ ) followed by ("myclass " or "myclass$") where ^/$ are beginning/end of string
            currentValue = currentValue.replace(new RegExp(regularExpression), "$2");
            val = currentValue + (val ? (currentValue && " ") + toggle : "");
        }
        return val;
    };

    //========================
    // JsViews-specific tags
    //========================

    $tags("on", {
        attr: NONE,
        noVal: true, // This tag control does not bind to arg[0] - no default binding to current #data context
        init: function (tagCtx) {
            var content,
                tag = this,
                i = 0,
                args = tagCtx.args, // [events,] [selector,] handler
                l = args.length;

            for (; i < l && !$isFunction(args[i]) ; i++); // Handler is first arg of type function
            tag._hi = l > i && i + 1; // handler index
            if (tag._.inline) {
                if (!$sub.rTmpl.exec(content = tagCtx.tmpl.markup)) {
                    // Inline {^{on}} tag with no content (or external template content) or with content containing
                    // no HTML or JsRender tags: We will wrap the (text) content, or the operation name in a <button> element
                    // (Otherwise we will attach the handler to the element content after data-linking)
                    tag.template = "<button>" + ($.trim(content) || tagCtx.params.args[i] || "noop") + "</button>";
                }
                tag.attr = HTML;
            }
        },
        render: function () {
            var tagCtx = this.tagCtx;
            return this._.inline && tagCtx.render(tagCtx.view, true); // no arg, so renders against parentView.data
        },
        onAfterLink: function (tagCtx, linkCtx) {
            var handler, params, find, activeElem,
                tag = this,
                i = tag._hi,
                args = tagCtx.args, // [events,] [selector,] handler
                l = args.length,
                props = tagCtx.props,
                data = props.data,
                view = tagCtx.view,
                contextOb = props.context; // Context ('this' pointer) for attached handler

            if (i) { // There is a handler
                handler = args[i - 1];
                params = args.slice(i); // Subsequent args are params
                args = args.slice(0, i - 1); // Preceding args (if any) are events and selector
                tag._sel = args[1]; // Selector for descendant elements - for delegated events on those elements, delegating to the activeElem

                activeElem = tag.activeElem = tag.activeElem || $(tag._.inline
                    ? (tag._sel = args[1] || "*", tag.parentElem)
                    // If inline, attach to child elements of tag parent element (filtered by selector argument if provided.
                    // (In handler we'll filter out events from sibling elements preceding or following tag.)
                    // This allows us to use the delegated pattern where the attached event works even for added elements satisfying the selector
                    : linkCtx.elem);

                if (!contextOb) {
                    // Get the path for the preceding object (context object) of handler (which is the last arg), compile function
                    // to return that context object, and run compiled function against data
                    contextOb = /^(.*)[\.^][\w$]+$/.exec(tagCtx.params.args.slice(-params.length - 1)[0]);
                    contextOb = contextOb && $sub.tmplFn(delimOpenChar1 + ":" + contextOb[1] + delimCloseChar0, view.tmpl, true)(linkCtx.data, view);
                }

                if (tag._evs) {
                    tag.onUnbind();
                }

                activeElem.on(
                    tag._evs = args[0] || "click", // events defaults to "click"
                    tag._sel,
                    data == undefined ? null : data,
                    tag._hlr = function hndlr(ev) {
                        var nodes, length,
                            found = !tag._.inline;

                        if (!found) { // If inline, filter out events from sibling elements preceding or following tag.
                            nodes = tag.contents("*");
                            l = nodes.length;
                            while (!found && l--) {
                                if (nodes[l].contains(ev.target)) {
                                    found = true;
                                }
                            }
                        }
                        if (found) { // target elem is indeed within the tag, so call the {on} handler
                            return handler.apply(contextOb || linkCtx.data, [].concat(
                                params, // e.g. par1, par2
                                ev,
                                { change: ev.type, view: view, linkCtx: linkCtx },
                                params.slice.call(arguments, 1) // If triggering event (e.g. jsv-domchange) has additional arguments after ev, pass them too
                            ));
                            // for {on 'click' handler par1 par2} use handler(par1, par2, ev, domchangeEventArgs)
                            // for {on 'jsv-domchange' handler par1 par2} use handler(par1, par2, ev, domchangeEventArgs, tagCtx, linkCtx, observableEventArgs)
                        }
                    }
                );
            }
        },
        onUpdate: function () {
            return false;
        },
        onUnbind: function () {
            var self = this;
            if (self.activeElem) {
                self.activeElem.off(self._evs, self._sel, self._hlr);
            }
        },
        flow: true,
        dataBoundOnly: true
    });

    $extend($tags["for"], {
        //onUpdate: function(ev, eventArgs, newTagCtxs) {
        //Consider adding filtering for perf optimization. However the below prevents update on some scenarios which _should_ update - namely when there is another array on which for also depends.
        //var i, l, tci, prevArg;
        //for (tci = 0; (prevArg = this.tagCtxs[tci]) && prevArg.args.length; tci++) {
        //	if (prevArg.args[0] !== newTagCtxs[tci].args[0]) {
        //		return true;
        //	}
        //}
        //return false;
        //},
        onArrayChange: function (ev, eventArgs, tagCtx, linkCtx) {
            var arrayView,
                target = ev.target,
                targetLength = target.length,
                tag = this,
                change = eventArgs.change;
            if (tag._.noVws // Child views not supported because target is not html - e.g. data-link="title{for ...}"
                || tag.tagCtxs[1] && ( // There is an {{else}}
                    change === "insert" && targetLength === eventArgs.items.length // inserting, and new length is same as inserted length, so going from 0 to n
                    || change === "remove" && !targetLength // removing , and new length 0, so going from n to 0
                )) {
                tag.refresh();
            } else {
                for (arrayView in tag._.arrVws) {
                    arrayView = tag._.arrVws[arrayView];
                    if (arrayView.data === target) {
                        arrayView._.onArrayChange.apply(arrayView, arguments);
                    }
                }
            }
            tag.domChange(tagCtx, linkCtx, eventArgs);
            ev.done = true;
        },
        onAfterLink: function (tagCtx, linkCtx) {
            var i, arrHandler, arrBinding, data,
                tag = this,
                arrayBindings = tag._ars || {},
                tagCtxs = tag.tagCtxs,
                l = tagCtxs.length,
                selected = tag.selected || 0;

            for (i = 0; i <= selected; i++) {
                tagCtx = tagCtxs[i];        // loop through tagCtxs up to selected
                data = tagCtx.map
                    ? tagCtx.map.tgt        // 'data' is mapped data
                    : tagCtx.args.length
                        ? tagCtx.args[0]    // or args[0]
                        : tagCtx.view.data; // or defaults to current data.

                if ((arrBinding = arrayBindings[i]) && data !== arrBinding[0]) { // Is there previous array data on this tagCtx, different from new data
                    $observe(arrBinding[0], arrBinding[1], true); //unobserve previous array
                    delete arrayBindings[i];
                }
                if (!arrayBindings[i] && $isArray(data)) {
                    $observe(data, arrHandler = function (ev, eventArgs) {
                        var tagCt = tagCtx;
                        tag.onArrayChange(ev, eventArgs, tagCt, linkCtx);
                    });
                    arrayBindings[i] = [data, arrHandler]; // Store array data and arrayChangeHandler on tag._ars[i]
                }
            }
            for (i = selected + 1; i < l; i++) { // If there were previous bindings on later tagCtxs, remove them
                if (arrBinding = arrayBindings[i]) {
                    $observe(arrBinding[0], arrBinding[1], true); //unobserve previous binding
                    delete arrayBindings[i];
                }
            }
            tag._ars = arrayBindings;
        },
        onDispose: function () {
            var l, tag = this;
            for (l in tag._ars) {
                $observe(tag._ars[l][0], tag._ars[l][1], true); //unobserve
            }
        }
    });

    $extend($tags["if"], {
        onUpdate: function (ev, eventArgs, newTagCtxs) {
            var tci, prevArg, different;
            for (tci = 0; (prevArg = this.tagCtxs[tci]) ; tci++) {
                different = prevArg.props.tmpl !== newTagCtxs[tci].props.tmpl || prevArg.args.length && !(prevArg = prevArg.args[0]) !== !newTagCtxs[tci].args[0];
                if ((!this.convert && !!prevArg) || different) {
                    return different;
                    // If there is not a change of template, and there is no converter, and newArg and prevArg are both truthy, return false to cancel update.
                    // (Even if values on later elses are different, we still don't want to update, since rendered output would be unchanged)
                    // If newArg and prevArg are different, return true, to update
                    // If newArg and prevArg are both falsey, move to the next {{else ...}}
                }
            }
            // Boolean value of all args are unchanged (falsey), so return false to cancel update
            return false;
        },
        onAfterLink: function (tagCtx, linkCtx, ctx, ev, eventArgs) {
            if (eventArgs) {
                this.domChange(tagCtx, linkCtx, eventArgs);
            }
        }
    });

    function observeProps(map, ev, eventArgs) {
        if (eventArgs.change === "set") {
            var target = map.tgt,
                l = target.length;
            while (l--) {
                if (target[l].key === eventArgs.path) {
                    break;
                }
            }
            if (l === -1) {
                if (eventArgs.path && !eventArgs.remove) {
                    $observable(target).insert({ key: eventArgs.path, prop: eventArgs.value });
                }
            } else if (eventArgs.remove) {
                $observable(target).remove(l);
            } else {
                $observable(target[l]).setProperty("prop", eventArgs.value);
            }
        }
    }

    function observeMappedProps(map, ev, eventArgs) {
        var item,
            source = map.src,
            change = eventArgs.change;

        if (change === "set") {
            if (eventArgs.path === "prop") {
                $observable(source).setProperty(ev.target.key, eventArgs.value);
            } else { // path === "key"
                $observable(source).removeProperty(eventArgs.oldValue); // When key is modified observably, remove old one and set new one
                $observable(source).setProperty(eventArgs.value, ev.target.prop);
            }
        } else if (change === "remove") {
            item = eventArgs.items[0];
            $observable(source).removeProperty(item.key);
            delete source[item.key];
        } else if (change === "insert") {
            item = eventArgs.items[0];
            if (item.key) {
                $observable(source).setProperty(item.key, item.prop);
            }
        }
    }

    function shallowArrayFilter(allPath /*, object, parentObs*/) { // Filter used by {{props}} for the mappedProps target array
        return allPath.indexOf(".") < 0;
    }

    $tags("props", {
        baseTag: "for",
        dataMap: $views.map({
            getTgt: $tags.props.dataMap.getTgt,
            obsSrc: observeProps,
            obsTgt: observeMappedProps,
            tgtFlt: shallowArrayFilter
        }),
        flow: true
    });

    //========================
    // Extend jQuery namespace
    //========================

    $extend($, {

        //=======================
        // jQuery $.view() plugin
        //=======================

        view: $view = function (node, inner, type) {
            // $.view() returns top view
            // $.view(node) returns view that contains node
            // $.view(selector) returns view that contains first selected element
            // $.view(nodeOrSelector, type) returns nearest containing view of given type
            // $.view(nodeOrSelector, "root") returns root containing view (child of top view)
            // $.view(nodeOrSelector, true, type) returns nearest inner (contained) view of given type

            function getInnerView(nd, isVl) {
                if (nd) {
                    vwInfos = viewInfos(nd, isVl, rOpenViewMarkers);
                    for (j = 0, k = vwInfos.length; j < k; j++) {
                        if ((view = viewStore[vwInfos[j].id]) && (view = view && type ? view.get(true, type) : view)) {
                            break;
                        }
                    }
                }
            }

            if (inner !== !!inner) {
                // inner not boolean, so this is view(nodeOrSelector, type)
                type = inner;
                inner = undefined;
            }
            var view, vwInfos, i, j, k, l, elems,
                level = 0,
                body = document.body;

            if (node && node !== body && topView._.useKey > 1) {
                // Perf optimization for common cases

                node = "" + node === node
                    ? $(node)[0]
                    : node.jquery
                        ? node[0]
                        : node;

                if (node) {
                    if (inner) {
                        getInnerView(node._df, true);
                        if (!view) {
                            // Treat supplied node as a container element and return the first view encountered.
                            elems = qsa ? node.querySelectorAll(bindElsSel) : $(bindElsSel, node).get();
                            l = elems.length;
                            for (i = 0; !view && i < l; i++) {
                                getInnerView(elems[i]);
                            }
                        }
                        return view;
                    }
                    while (node) {
                        // Move back through siblings and up through parents to find preceding node which is a _prv (prevNode)
                        // script marker node for a non-element-content view, or a _prv (first node) for an elCnt view
                        if (vwInfos = viewInfos(node, undefined, rViewMarkers)) {
                            l = vwInfos.length;
                            while (l--) {
                                view = vwInfos[l];
                                if (view.open) {
                                    if (level < 1) {
                                        view = viewStore[view.id];
                                        return view && type ? view.get(type) : view || topView;
                                    }
                                    level--;
                                } else {
                                    // level starts at zero. If we hit a view.close, then we move level to 1, and we don't return a view until
                                    // we are back at level zero (or a parent view with level < 0)
                                    level++;
                                }
                            }
                        }
                        node = node.previousSibling || node.parentNode;
                    }
                }
            }
            return topView;
        },

        link: $link,
        unlink: $unlink,

        //=====================
        // override $.cleanData
        //=====================
        cleanData: function (elems) {
            if (elems.length && isCleanCall) {
                // Remove JsViews bindings. Also, remove from the DOM any corresponding script marker nodes
                clean(elems);
            }
            oldCleanData.apply($, arguments);
        }
    });

    // Possible future addition - e.g. for ckeditor tag control
    //$views.utility = {
    //	validate: function(html) {
    //		try {
    //			topView.link(undefined, document.createElement("div"), undefined, undefined, html, undefined, undefined, 1);
    //		}
    //		catch (e) {
    //			return e.message;
    //		}
    //	}
    //};

    //===============================
    // Extend jQuery instance plugins
    //===============================

    $extend($.fn, {
        link: function (expr, from, context, noIteration, parentView, prevNode, nextNode) {
            return $link(expr, this, from, context, noIteration, parentView, prevNode, nextNode);
        },
        unlink: function () {
            return $unlink(this);
        },
        view: function (inner, type) {
            return $view(this[0], inner, type);
        }
    });

    //==============================================================================
    // Override jQuery methods that call our overridden cleanData, for disposal etc.
    //==============================================================================

    $.each([HTML, "replaceWith", "empty", "remove"], function (i, name) {
        var oldFn = $.fn[name];
        $.fn[name] = function () {
            var result;
            isCleanCall = 1; // Make sure cleanData does disposal only when coming from these calls.
            try {
                result = oldFn.apply(this, arguments);
            }
            finally {
                isCleanCall = 0;
            }
            return result;
        };
    });

    //===============
    // Extend topView
    //===============

    addLinkMethods($extend(topView = $sub.topView, { tmpl: { links: {} } }));

    viewStore = { 0: topView }; // Top-level view
    //===============
    // Extend $.views
    //===============

    $views.getCtx = function (param) { // Return value of ctx.foo, including for compiled contextual parameters, ~foo=expr
        if (param && param._cp) { // If this helper resource is a contextual parameter, ~foo=expr
            param = param[1](param[0].data, param[0], $sub);
        }
        return param;
    };

    //===================
    // Extend $.views.sub
    //===================

    $sub._cp = function (paramVal, params, view) { // Get compiled contextual parameters (or properties) ~foo=expr.
        if (view.linked) { // In JsViews, returns [view, linkFn] where linkFn is compiled function for expression
            params = delimOpenChar1 + ":" + params + delimCloseChar0;
            var tmpl = view.tmpl,
                links = topView.tmpl.links, // Use topView links, as for compiled top-level linking expressions. To do - should this ever get disposed?
                linkFn = links[params];
            if (!linkFn) {
                links[params] = linkFn = $sub.tmplFn(params, tmpl, true);
            }
            paramVal = [view, linkFn];
            paramVal._cp = true; // Flag that this is a contextual parameter
        }
        return paramVal; // In JsRender returns evaluated expression
    };

    $sub._ceo = function cloneExprObjects(obs) {  // Clone exprObs so that each referenced contextual parameter ~foo uses its own exprOb instances
        var ob,
            clones = obs,
            l = obs.length;
        if (l) {
            clones = [];
            while (l--) {
                ob = obs[l];
                if (ob._jsv) {
                    ob = $extend({}, ob);              // If an exprOb, clone it. If a string, keep as is
                    ob.prm = cloneExprObjects(ob.prm); // Recursively clone exprObs in parameters, too
                }
                clones.unshift(ob);
            }
        }
        return clones;
    };

    //=========================
    // Extend $.views.settings
    //=========================

    oldAdvSet = $sub.advSet;

    $sub.advSet = function () { // refresh advanced settings
        oldAdvSet();
        global._jsv = $subSettingsAdvanced._jsv
            ? $extend(global._jsv || {}, { // create global _jsv, for accessing views, etc
                views: viewStore,
                bindings: bindingStore
            })
            : undefined; // In IE8 cannot do delete global._jsv
        $viewsLinkAttr = $subSettingsAdvanced.linkAttr;
        linkViewsSel = bindElsSel + ",[" + $viewsLinkAttr + "]";
        wrapMap = $subSettingsAdvanced._wm;
        wrapMap.optgroup = wrapMap.option;
        wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
        wrapMap.th = wrapMap.td;
    };

    $viewsSettings.advanced({
        linkAttr: "data-link",
        useViews: false,
        noValidate: false,
        // wrapMap provide appropriate wrappers for inserting innerHTML, used in insertBefore
        // We have to close these tags to support XHTML (#13200)
        // TODO investigate whether more recent jQuery implementation using wrapMap in domManip/$().html() etc. is better optimized now...
        _wm: {
            option: [1, "<select multiple='multiple'>", "</select>"],
            legend: [1, "<fieldset>", "</fieldset>"],
            area: [1, "<map>", "</map>"],
            param: [1, "<object>", "</object>"],
            thead: [1, "<table>", "</table>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
            col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
            svg_ns: [1, "<svg>", "</svg>"],
            // IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
            // unless wrapped in a div with non-breaking characters in front of it.
            div: $.support.htmlSerialize ? [0, "", ""] : [1, "X<div>", "</div>"]
        },
        _fe: {
            input: {
                from: inputAttrib, to: "value"
            },
            textarea: valueBinding,
            select: valueBinding,
            optgroup: {
                to: "label"
            }
        }
    });

    return $;
}, window));
//#region jsTree

// NOTE: Three customizations were made to jsTree - these must be re-applied when updating the library. Look for '[Roger]'

/*globals jQuery, define, module, exports, require, window, document, postMessage */
(function (factory) {
    "use strict";
    if (typeof define === 'function' && define.amd) {
        define(['jquery'], factory);
    }
    else if (typeof module !== 'undefined' && module.exports) {
        module.exports = factory(require('jquery'));
    }
    else {
        factory(jQuery);
    }
}(function ($, undefined) {
    "use strict";
    /*!
     * jsTree 3.3.3
     * http://jstree.com/
     *
     * Copyright (c) 2014 Ivan Bozhanov (http://vakata.com)
     *
     * Licensed same as jquery - under the terms of the MIT License
     *   http://www.opensource.org/licenses/mit-license.php
     */
    /*!
     * if using jslint please allow for the jQuery global and use following options:
     * jslint: loopfunc: true, browser: true, ass: true, bitwise: true, continue: true, nomen: true, plusplus: true, regexp: true, unparam: true, todo: true, white: true
     */
    /*jshint -W083 */

    // prevent another load? maybe there is a better way?
    if ($.jstree) {
        return;
    }

    /**
     * ### jsTree core functionality
     */

    // internal variables
    var instance_counter = 0,
        ccp_node = false,
        ccp_mode = false,
        ccp_inst = false,
        themes_loaded = [],
        src = $('script:last').attr('src'),
        document = window.document; // local variable is always faster to access then a global

    /**
     * holds all jstree related functions and variables, including the actual class and methods to create, access and manipulate instances.
     * @name $.jstree
     */
    $.jstree = {
        /**
         * specifies the jstree version in use
         * @name $.jstree.version
         */
        version: '3.3.3',
        /**
         * holds all the default options used when creating new instances
         * @name $.jstree.defaults
         */
        defaults: {
            /**
             * configure which plugins will be active on an instance. Should be an array of strings, where each element is a plugin name. The default is `[]`
             * @name $.jstree.defaults.plugins
             */
            plugins: []
        },
        /**
         * stores all loaded jstree plugins (used internally)
         * @name $.jstree.plugins
         */
        plugins: {},
        path: src && src.indexOf('/') !== -1 ? src.replace(/\/[^\/]+$/, '') : '',
        idregex: /[\\:&!^|()\[\]<>@*'+~#";.,=\- \/${}%?`]/g,
        root: '#'
    };

    /**
     * creates a jstree instance
     * @name $.jstree.create(el [, options])
     * @param {DOMElement|jQuery|String} el the element to create the instance on, can be jQuery extended or a selector
     * @param {Object} options options for this instance (extends `$.jstree.defaults`)
     * @return {jsTree} the new instance
     */
    $.jstree.create = function (el, options) {
        var tmp = new $.jstree.core(++instance_counter),
            opt = options;
        options = $.extend(true, {}, $.jstree.defaults, options);
        if (opt && opt.plugins) {
            options.plugins = opt.plugins;
        }
        $.each(options.plugins, function (i, k) {
            if (i !== 'core') {
                tmp = tmp.plugin(k, options[k]);
            }
        });
        $(el).data('jstree', tmp);
        tmp.init(el, options);
        return tmp;
    };
    /**
     * remove all traces of jstree from the DOM and destroy all instances
     * @name $.jstree.destroy()
     */
    $.jstree.destroy = function () {
        $('.jstree:jstree').jstree('destroy');
        $(document).off('.jstree');
    };
    /**
     * the jstree class constructor, used only internally
     * @private
     * @name $.jstree.core(id)
     * @param {Number} id this instance's index
     */
    $.jstree.core = function (id) {
        this._id = id;
        this._cnt = 0;
        this._wrk = null;
        this._data = {
            core: {
                themes: {
                    name: false,
                    dots: false,
                    icons: false,
                    ellipsis: false
                },
                selected: [],
                last_error: {},
                working: false,
                worker_queue: [],
                focused: null
            }
        };
    };
    /**
     * get a reference to an existing instance
     *
     * __Examples__
     *
     *	// provided a container with an ID of "tree", and a nested node with an ID of "branch"
     *	// all of there will return the same instance
     *	$.jstree.reference('tree');
     *	$.jstree.reference('#tree');
     *	$.jstree.reference($('#tree'));
     *	$.jstree.reference(document.getElementByID('tree'));
     *	$.jstree.reference('branch');
     *	$.jstree.reference('#branch');
     *	$.jstree.reference($('#branch'));
     *	$.jstree.reference(document.getElementByID('branch'));
     *
     * @name $.jstree.reference(needle)
     * @param {DOMElement|jQuery|String} needle
     * @return {jsTree|null} the instance or `null` if not found
     */
    $.jstree.reference = function (needle) {
        var tmp = null,
            obj = null;
        if (needle && needle.id && (!needle.tagName || !needle.nodeType)) { needle = needle.id; }

        if (!obj || !obj.length) {
            try { obj = $(needle); } catch (ignore) { }
        }
        if (!obj || !obj.length) {
            try { obj = $('#' + needle.replace($.jstree.idregex, '\\$&')); } catch (ignore) { }
        }
        if (obj && obj.length && (obj = obj.closest('.jstree')).length && (obj = obj.data('jstree'))) {
            tmp = obj;
        }
        else {
            $('.jstree').each(function () {
                var inst = $(this).data('jstree');
                if (inst && inst._model.data[needle]) {
                    tmp = inst;
                    return false;
                }
            });
        }
        return tmp;
    };
    /**
     * Create an instance, get an instance or invoke a command on a instance.
     *
     * If there is no instance associated with the current node a new one is created and `arg` is used to extend `$.jstree.defaults` for this new instance. There would be no return value (chaining is not broken).
     *
     * If there is an existing instance and `arg` is a string the command specified by `arg` is executed on the instance, with any additional arguments passed to the function. If the function returns a value it will be returned (chaining could break depending on function).
     *
     * If there is an existing instance and `arg` is not a string the instance itself is returned (similar to `$.jstree.reference`).
     *
     * In any other case - nothing is returned and chaining is not broken.
     *
     * __Examples__
     *
     *	$('#tree1').jstree(); // creates an instance
     *	$('#tree2').jstree({ plugins : [] }); // create an instance with some options
     *	$('#tree1').jstree('open_node', '#branch_1'); // call a method on an existing instance, passing additional arguments
     *	$('#tree2').jstree(); // get an existing instance (or create an instance)
     *	$('#tree2').jstree(true); // get an existing instance (will not create new instance)
     *	$('#branch_1').jstree().select_node('#branch_1'); // get an instance (using a nested element and call a method)
     *
     * @name $().jstree([arg])
     * @param {String|Object} arg
     * @return {Mixed}
     */
    $.fn.jstree = function (arg) {
        // check for string argument
        var is_method = (typeof arg === 'string'),
            args = Array.prototype.slice.call(arguments, 1),
            result = null;
        if (arg === true && !this.length) { return false; }
        this.each(function () {
            // get the instance (if there is one) and method (if it exists)
            var instance = $.jstree.reference(this),
                method = is_method && instance ? instance[arg] : null;
            // if calling a method, and method is available - execute on the instance
            result = is_method && method ?
                method.apply(instance, args) :
                null;
            // if there is no instance and no method is being called - create one
            if (!instance && !is_method && (arg === undefined || $.isPlainObject(arg))) {
                $.jstree.create(this, arg);
            }
            // if there is an instance and no method is called - return the instance
            if ((instance && !is_method) || arg === true) {
                result = instance || false;
            }
            // if there was a method call which returned a result - break and return the value
            if (result !== null && result !== undefined) {
                return false;
            }
        });
        // if there was a method call with a valid return value - return that, otherwise continue the chain
        return result !== null && result !== undefined ?
            result : this;
    };
    /**
     * used to find elements containing an instance
     *
     * __Examples__
     *
     *	$('div:jstree').each(function () {
     *		$(this).jstree('destroy');
     *	});
     *
     * @name $(':jstree')
     * @return {jQuery}
     */
    $.expr.pseudos.jstree = $.expr.createPseudo(function (search) {
        return function (a) {
            return $(a).hasClass('jstree') &&
                $(a).data('jstree') !== undefined;
        };
    });

    /**
     * stores all defaults for the core
     * @name $.jstree.defaults.core
     */
    $.jstree.defaults.core = {
        /**
         * data configuration
         *
         * If left as `false` the HTML inside the jstree container element is used to populate the tree (that should be an unordered list with list items).
         *
         * You can also pass in a HTML string or a JSON array here.
         *
         * It is possible to pass in a standard jQuery-like AJAX config and jstree will automatically determine if the response is JSON or HTML and use that to populate the tree.
         * In addition to the standard jQuery ajax options here you can suppy functions for `data` and `url`, the functions will be run in the current instance's scope and a param will be passed indicating which node is being loaded, the return value of those functions will be used.
         *
         * The last option is to specify a function, that function will receive the node being loaded as argument and a second param which is a function which should be called with the result.
         *
         * __Examples__
         *
         *	// AJAX
         *	$('#tree').jstree({
         *		'core' : {
         *			'data' : {
         *				'url' : '/get/children/',
         *				'data' : function (node) {
         *					return { 'id' : node.id };
         *				}
         *			}
         *		});
         *
         *	// direct data
         *	$('#tree').jstree({
         *		'core' : {
         *			'data' : [
         *				'Simple root node',
         *				{
         *					'id' : 'node_2',
         *					'text' : 'Root node with options',
         *					'state' : { 'opened' : true, 'selected' : true },
         *					'children' : [ { 'text' : 'Child 1' }, 'Child 2']
         *				}
         *			]
         *		}
         *	});
         *
         *	// function
         *	$('#tree').jstree({
         *		'core' : {
         *			'data' : function (obj, callback) {
         *				callback.call(this, ['Root 1', 'Root 2']);
         *			}
         *		});
         *
         * @name $.jstree.defaults.core.data
         */
        data: false,
        /**
         * configure the various strings used throughout the tree
         *
         * You can use an object where the key is the string you need to replace and the value is your replacement.
         * Another option is to specify a function which will be called with an argument of the needed string and should return the replacement.
         * If left as `false` no replacement is made.
         *
         * __Examples__
         *
         *	$('#tree').jstree({
         *		'core' : {
         *			'strings' : {
         *				'Loading ...' : 'Please wait ...'
         *			}
         *		}
         *	});
         *
         * @name $.jstree.defaults.core.strings
         */
        strings: false,
        /**
         * determines what happens when a user tries to modify the structure of the tree
         * If left as `false` all operations like create, rename, delete, move or copy are prevented.
         * You can set this to `true` to allow all interactions or use a function to have better control.
         *
         * __Examples__
         *
         *	$('#tree').jstree({
         *		'core' : {
         *			'check_callback' : function (operation, node, node_parent, node_position, more) {
         *				// operation can be 'create_node', 'rename_node', 'delete_node', 'move_node' or 'copy_node'
         *				// in case of 'rename_node' node_position is filled with the new node name
         *				return operation === 'rename_node' ? true : false;
         *			}
         *		}
         *	});
         *
         * @name $.jstree.defaults.core.check_callback
         */
        check_callback: false,
        /**
         * a callback called with a single object parameter in the instance's scope when something goes wrong (operation prevented, ajax failed, etc)
         * @name $.jstree.defaults.core.error
         */
        error: $.noop,
        /**
         * the open / close animation duration in milliseconds - set this to `false` to disable the animation (default is `200`)
         * @name $.jstree.defaults.core.animation
         */
        animation: 200,
        /**
         * a boolean indicating if multiple nodes can be selected
         * @name $.jstree.defaults.core.multiple
         */
        multiple: true,
        /**
         * theme configuration object
         * @name $.jstree.defaults.core.themes
         */
        themes: {
            /**
             * the name of the theme to use (if left as `false` the default theme is used)
             * @name $.jstree.defaults.core.themes.name
             */
            name: false,
            /**
             * the URL of the theme's CSS file, leave this as `false` if you have manually included the theme CSS (recommended). You can set this to `true` too which will try to autoload the theme.
             * @name $.jstree.defaults.core.themes.url
             */
            url: false,
            /**
             * the location of all jstree themes - only used if `url` is set to `true`
             * @name $.jstree.defaults.core.themes.dir
             */
            dir: false,
            /**
             * a boolean indicating if connecting dots are shown
             * @name $.jstree.defaults.core.themes.dots
             */
            dots: true,
            /**
             * a boolean indicating if node icons are shown
             * @name $.jstree.defaults.core.themes.icons
             */
            icons: true,
            /**
             * a boolean indicating if node ellipsis should be shown - this only works with a fixed with on the container
             * @name $.jstree.defaults.core.themes.ellipsis
             */
            ellipsis: false,
            /**
             * a boolean indicating if the tree background is striped
             * @name $.jstree.defaults.core.themes.stripes
             */
            stripes: false,
            /**
             * a string (or boolean `false`) specifying the theme variant to use (if the theme supports variants)
             * @name $.jstree.defaults.core.themes.variant
             */
            variant: false,
            /**
             * a boolean specifying if a reponsive version of the theme should kick in on smaller screens (if the theme supports it). Defaults to `false`.
             * @name $.jstree.defaults.core.themes.responsive
             */
            responsive: false
        },
        /**
         * if left as `true` all parents of all selected nodes will be opened once the tree loads (so that all selected nodes are visible to the user)
         * @name $.jstree.defaults.core.expand_selected_onload
         */
        expand_selected_onload: true,
        /**
         * if left as `true` web workers will be used to parse incoming JSON data where possible, so that the UI will not be blocked by large requests. Workers are however about 30% slower. Defaults to `true`
         * @name $.jstree.defaults.core.worker
         */
        worker: true,
        /**
         * Force node text to plain text (and escape HTML). Defaults to `false`
         * @name $.jstree.defaults.core.force_text
         */
        force_text: false,
        /**
         * Should the node should be toggled if the text is double clicked . Defaults to `true`
         * @name $.jstree.defaults.core.dblclick_toggle
         */
        dblclick_toggle: true
    };
    $.jstree.core.prototype = {
        /**
         * used to decorate an instance with a plugin. Used internally.
         * @private
         * @name plugin(deco [, opts])
         * @param  {String} deco the plugin to decorate with
         * @param  {Object} opts options for the plugin
         * @return {jsTree}
         */
        plugin: function (deco, opts) {
            var Child = $.jstree.plugins[deco];
            if (Child) {
                this._data[deco] = {};
                Child.prototype = this;
                return new Child(opts, this);
            }
            return this;
        },
        /**
         * initialize the instance. Used internally.
         * @private
         * @name init(el, optons)
         * @param {DOMElement|jQuery|String} el the element we are transforming
         * @param {Object} options options for this instance
         * @trigger init.jstree, loading.jstree, loaded.jstree, ready.jstree, changed.jstree
         */
        init: function (el, options) {
            this._model = {
                data: {},
                changed: [],
                force_full_redraw: false,
                redraw_timeout: false,
                default_state: {
                    loaded: true,
                    opened: false,
                    selected: false,
                    disabled: false
                }
            };
            this._model.data[$.jstree.root] = {
                id: $.jstree.root,
                parent: null,
                parents: [],
                children: [],
                children_d: [],
                state: { loaded: false }
            };

            this.element = $(el).addClass('jstree jstree-' + this._id);
            this.settings = options;

            this._data.core.ready = false;
            this._data.core.loaded = false;
            this._data.core.rtl = (this.element.css("direction") === "rtl");
            this.element[this._data.core.rtl ? 'addClass' : 'removeClass']("jstree-rtl");
            this.element.attr('role', 'tree');
            if (this.settings.core.multiple) {
                this.element.attr('aria-multiselectable', true);
            }
            if (!this.element.attr('tabindex')) {
                this.element.attr('tabindex', '0');
            }

            this.bind();
            /**
             * triggered after all events are bound
             * @event
             * @name init.jstree
             */
            this.trigger("init");

            this._data.core.original_container_html = this.element.find(" > ul > li").clone(true);
            this._data.core.original_container_html
                .find("li").addBack()
                .contents().filter(function () {
                    return this.nodeType === 3 && (!this.nodeValue || /^\s+$/.test(this.nodeValue));
                })
                .remove();
            this.element.html("<" + "ul class='jstree-container-ul jstree-children' role='group'><" + "li id='j" + this._id + "_loading' class='jstree-initial-node jstree-loading jstree-leaf jstree-last' role='tree-item'><i class='jstree-icon jstree-ocl'></i><" + "a class='jstree-anchor' href='#'><i class='jstree-icon jstree-themeicon-hidden'></i>" + this.get_string("Loading ...") + "</a></li></ul>");
            this.element.attr('aria-activedescendant', 'j' + this._id + '_loading');
            this._data.core.li_height = this.get_container_ul().children("li").first().height() || 24;
            this._data.core.node = this._create_prototype_node();
            /**
             * triggered after the loading text is shown and before loading starts
             * @event
             * @name loading.jstree
             */
            this.trigger("loading");
            this.load_node($.jstree.root);
        },
        /**
         * destroy an instance
         * @name destroy()
         * @param  {Boolean} keep_html if not set to `true` the container will be emptied, otherwise the current DOM elements will be kept intact
         */
        destroy: function (keep_html) {
            if (this._wrk) {
                try {
                    window.URL.revokeObjectURL(this._wrk);
                    this._wrk = null;
                }
                catch (ignore) { }
            }
            if (!keep_html) { this.element.empty(); }
            this.teardown();
        },
        /**
         * Create prototype node
         */
        _create_prototype_node: function () {
            var _node = document.createElement('LI'), _temp1, _temp2;
            _node.setAttribute('role', 'treeitem');
            _temp1 = document.createElement('I');
            _temp1.className = 'jstree-icon jstree-ocl';
            _temp1.setAttribute('role', 'presentation');
            _node.appendChild(_temp1);
            _temp1 = document.createElement('A');
            _temp1.className = 'jstree-anchor';
            _temp1.setAttribute('href', '#');
            _temp1.setAttribute('tabindex', '-1');
            _temp2 = document.createElement('I');
            _temp2.className = 'jstree-icon jstree-themeicon';
            _temp2.setAttribute('role', 'presentation');
            _temp1.appendChild(_temp2);
            _node.appendChild(_temp1);
            _temp1 = _temp2 = null;

            return _node;
        },
        /**
         * part of the destroying of an instance. Used internally.
         * @private
         * @name teardown()
         */
        teardown: function () {
            this.unbind();
            this.element
                .removeClass('jstree')
                .removeData('jstree')
                .find("[class^='jstree']")
                    .addBack()
                    .attr("class", function () { return this.className.replace(/jstree[^ ]*|$/ig, ''); });
            this.element = null;
        },
        /**
         * bind all events. Used internally.
         * @private
         * @name bind()
         */
        bind: function () {
            var word = '',
                tout = null,
                was_click = 0;
            this.element
                .on("dblclick.jstree", function (e) {
                    if (e.target.tagName && e.target.tagName.toLowerCase() === "input") { return true; }
                    if (document.selection && document.selection.empty) {
                        document.selection.empty();
                    }
                    else {
                        if (window.getSelection) {
                            var sel = window.getSelection();
                            try {
                                sel.removeAllRanges();
                                sel.collapse();
                            } catch (ignore) { }
                        }
                    }
                })
                .on("mousedown.jstree", $.proxy(function (e) {
                    if (e.target === this.element[0]) {
                        e.preventDefault(); // prevent losing focus when clicking scroll arrows (FF, Chrome)
                        was_click = +(new Date()); // ie does not allow to prevent losing focus
                    }
                }, this))
                .on("mousedown.jstree", ".jstree-ocl", function (e) {
                    e.preventDefault(); // prevent any node inside from losing focus when clicking the open/close icon
                })
                .on("click.jstree", ".jstree-ocl", $.proxy(function (e) {
                    this.toggle_node(e.target);
                }, this))
                .on("dblclick.jstree", ".jstree-anchor", $.proxy(function (e) {
                    if (e.target.tagName && e.target.tagName.toLowerCase() === "input") { return true; }
                    if (this.settings.core.dblclick_toggle) {
                        this.toggle_node(e.target);
                    }
                }, this))
                .on("click.jstree", ".jstree-anchor", $.proxy(function (e) {
                    e.preventDefault();
                    if (e.currentTarget !== document.activeElement) { $(e.currentTarget).focus(); }
                    this.activate_node(e.currentTarget, e);
                }, this))
                .on('keydown.jstree', '.jstree-anchor', $.proxy(function (e) {
                    if (e.target.tagName && e.target.tagName.toLowerCase() === "input") { return true; }
                    if (e.which !== 32 && e.which !== 13 && (e.shiftKey || e.ctrlKey || e.altKey || e.metaKey)) { return true; }
                    var o = null;
                    if (this._data.core.rtl) {
                        if (e.which === 37) { e.which = 39; }
                        else if (e.which === 39) { e.which = 37; }
                    }
                    switch (e.which) {
                        case 32: // aria defines space only with Ctrl
                            if (e.ctrlKey) {
                                e.type = "click";
                                $(e.currentTarget).trigger(e);
                            }
                            break;
                        case 13: // enter
                            e.type = "click";
                            $(e.currentTarget).trigger(e);
                            break;
                        case 37: // left
                            e.preventDefault();
                            if (this.is_open(e.currentTarget)) {
                                this.close_node(e.currentTarget);
                            }
                            else {
                                o = this.get_parent(e.currentTarget);
                                if (o && o.id !== $.jstree.root) { this.get_node(o, true).children('.jstree-anchor').focus(); }
                            }
                            break;
                        case 38: // up
                            e.preventDefault();
                            o = this.get_prev_dom(e.currentTarget);
                            if (o && o.length) { o.children('.jstree-anchor').focus(); }
                            break;
                        case 39: // right
                            e.preventDefault();
                            if (this.is_closed(e.currentTarget)) {
                                this.open_node(e.currentTarget, function (o) { this.get_node(o, true).children('.jstree-anchor').focus(); });
                            }
                            else if (this.is_open(e.currentTarget)) {
                                o = this.get_node(e.currentTarget, true).children('.jstree-children')[0];
                                if (o) { $(this._firstChild(o)).children('.jstree-anchor').focus(); }
                            }
                            break;
                        case 40: // down
                            e.preventDefault();
                            o = this.get_next_dom(e.currentTarget);
                            if (o && o.length) { o.children('.jstree-anchor').focus(); }
                            break;
                        case 106: // aria defines * on numpad as open_all - not very common
                            this.open_all();
                            break;
                        case 36: // home
                            e.preventDefault();
                            o = this._firstChild(this.get_container_ul()[0]);
                            if (o) { $(o).children('.jstree-anchor').filter(':visible').focus(); }
                            break;
                        case 35: // end
                            e.preventDefault();
                            this.element.find('.jstree-anchor').filter(':visible').last().focus();
                            break;
                        case 113: // f2 - safe to include - if check_callback is false it will fail
                            e.preventDefault();
                            this.edit(e.currentTarget);
                            break;
                        default:
                            break;
                            /*!
                            // delete
                            case 46:
                                e.preventDefault();
                                o = this.get_node(e.currentTarget);
                                if(o && o.id && o.id !== $.jstree.root) {
                                    o = this.is_selected(o) ? this.get_selected() : o;
                                    this.delete_node(o);
                                }
                                break;

                            */
                    }
                }, this))
                .on("load_node.jstree", $.proxy(function (e, data) {
                    if (data.status) {
                        if (data.node.id === $.jstree.root && !this._data.core.loaded) {
                            this._data.core.loaded = true;
                            if (this._firstChild(this.get_container_ul()[0])) {
                                this.element.attr('aria-activedescendant', this._firstChild(this.get_container_ul()[0]).id);
                            }
                            /**
                             * triggered after the root node is loaded for the first time
                             * @event
                             * @name loaded.jstree
                             */
                            this.trigger("loaded");
                        }
                        if (!this._data.core.ready) {
                            setTimeout($.proxy(function () {
                                if (this.element && !this.get_container_ul().find('.jstree-loading').length) {
                                    this._data.core.ready = true;
                                    if (this._data.core.selected.length) {
                                        if (this.settings.core.expand_selected_onload) {
                                            var tmp = [], i, j;
                                            for (i = 0, j = this._data.core.selected.length; i < j; i++) {
                                                tmp = tmp.concat(this._model.data[this._data.core.selected[i]].parents);
                                            }
                                            tmp = $.vakata.array_unique(tmp);
                                            for (i = 0, j = tmp.length; i < j; i++) {
                                                this.open_node(tmp[i], false, 0);
                                            }
                                        }
                                        this.trigger('changed', { 'action': 'ready', 'selected': this._data.core.selected });
                                    }
                                    /**
                                     * triggered after all nodes are finished loading
                                     * @event
                                     * @name ready.jstree
                                     */
                                    this.trigger("ready");
                                }
                            }, this), 0);
                        }
                    }
                }, this))
                // quick searching when the tree is focused
                .on('keypress.jstree', $.proxy(function (e) {
                    if (e.target.tagName && e.target.tagName.toLowerCase() === "input") { return true; }
                    if (tout) { clearTimeout(tout); }
                    tout = setTimeout(function () {
                        word = '';
                    }, 500);

                    var chr = String.fromCharCode(e.which).toLowerCase(),
                        col = this.element.find('.jstree-anchor').filter(':visible'),
                        ind = col.index(document.activeElement) || 0,
                        end = false;
                    word += chr;

                    // match for whole word from current node down (including the current node)
                    if (word.length > 1) {
                        col.slice(ind).each($.proxy(function (i, v) {
                            if ($(v).text().toLowerCase().indexOf(word) === 0) {
                                $(v).focus();
                                end = true;
                                return false;
                            }
                        }, this));
                        if (end) { return; }

                        // match for whole word from the beginning of the tree
                        col.slice(0, ind).each($.proxy(function (i, v) {
                            if ($(v).text().toLowerCase().indexOf(word) === 0) {
                                $(v).focus();
                                end = true;
                                return false;
                            }
                        }, this));
                        if (end) { return; }
                    }
                    // list nodes that start with that letter (only if word consists of a single char)
                    if (new RegExp('^' + chr.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&') + '+$').test(word)) {
                        // search for the next node starting with that letter
                        col.slice(ind + 1).each($.proxy(function (i, v) {
                            if ($(v).text().toLowerCase().charAt(0) === chr) {
                                $(v).focus();
                                end = true;
                                return false;
                            }
                        }, this));
                        if (end) { return; }

                        // search from the beginning
                        col.slice(0, ind + 1).each($.proxy(function (i, v) {
                            if ($(v).text().toLowerCase().charAt(0) === chr) {
                                $(v).focus();
                                end = true;
                                return false;
                            }
                        }, this));
                        if (end) { return; }
                    }
                }, this))
                // THEME RELATED
                .on("init.jstree", $.proxy(function () {
                    var s = this.settings.core.themes;
                    this._data.core.themes.dots = s.dots;
                    this._data.core.themes.stripes = s.stripes;
                    this._data.core.themes.icons = s.icons;
                    this._data.core.themes.ellipsis = s.ellipsis;
                    this.set_theme(s.name || "default", s.url);
                    this.set_theme_variant(s.variant);
                }, this))
                .on("loading.jstree", $.proxy(function () {
                    this[this._data.core.themes.dots ? "show_dots" : "hide_dots"]();
                    this[this._data.core.themes.icons ? "show_icons" : "hide_icons"]();
                    this[this._data.core.themes.stripes ? "show_stripes" : "hide_stripes"]();
                    this[this._data.core.themes.ellipsis ? "show_ellipsis" : "hide_ellipsis"]();
                }, this))
                .on('blur.jstree', '.jstree-anchor', $.proxy(function (e) {
                    this._data.core.focused = null;
                    $(e.currentTarget).filter('.jstree-hovered').mouseleave();
                    this.element.attr('tabindex', '0');
                }, this))
                .on('focus.jstree', '.jstree-anchor', $.proxy(function (e) {
                    var tmp = this.get_node(e.currentTarget);
                    if (tmp && tmp.id) {
                        this._data.core.focused = tmp.id;
                    }
                    this.element.find('.jstree-hovered').not(e.currentTarget).mouseleave();
                    $(e.currentTarget).mouseenter();
                    this.element.attr('tabindex', '-1');
                }, this))
                .on('focus.jstree', $.proxy(function () {
                    if (+(new Date()) - was_click > 500 && !this._data.core.focused) {
                        was_click = 0;
                        var act = this.get_node(this.element.attr('aria-activedescendant'), true);
                        if (act) {
                            act.find('> .jstree-anchor').focus();
                        }
                    }
                }, this))
                .on('mouseenter.jstree', '.jstree-anchor', $.proxy(function (e) {
                    this.hover_node(e.currentTarget);
                }, this))
                .on('mouseleave.jstree', '.jstree-anchor', $.proxy(function (e) {
                    this.dehover_node(e.currentTarget);
                }, this));
        },
        /**
         * part of the destroying of an instance. Used internally.
         * @private
         * @name unbind()
         */
        unbind: function () {
            this.element.off('.jstree');
            $(document).off('.jstree-' + this._id);
        },
        /**
         * trigger an event. Used internally.
         * @private
         * @name trigger(ev [, data])
         * @param  {String} ev the name of the event to trigger
         * @param  {Object} data additional data to pass with the event
         */
        trigger: function (ev, data) {
            if (!data) {
                data = {};
            }
            data.instance = this;
            this.element.triggerHandler(ev.replace('.jstree', '') + '.jstree', data);
        },
        /**
         * returns the jQuery extended instance container
         * @name get_container()
         * @return {jQuery}
         */
        get_container: function () {
            return this.element;
        },
        /**
         * returns the jQuery extended main UL node inside the instance container. Used internally.
         * @private
         * @name get_container_ul()
         * @return {jQuery}
         */
        get_container_ul: function () {
            return this.element.children(".jstree-children").first();
        },
        /**
         * gets string replacements (localization). Used internally.
         * @private
         * @name get_string(key)
         * @param  {String} key
         * @return {String}
         */
        get_string: function (key) {
            var a = this.settings.core.strings;
            if ($.isFunction(a)) { return a.call(this, key); }
            if (a && a[key]) { return a[key]; }
            return key;
        },
        /**
         * gets the first child of a DOM node. Used internally.
         * @private
         * @name _firstChild(dom)
         * @param  {DOMElement} dom
         * @return {DOMElement}
         */
        _firstChild: function (dom) {
            dom = dom ? dom.firstChild : null;
            while (dom !== null && dom.nodeType !== 1) {
                dom = dom.nextSibling;
            }
            return dom;
        },
        /**
         * gets the next sibling of a DOM node. Used internally.
         * @private
         * @name _nextSibling(dom)
         * @param  {DOMElement} dom
         * @return {DOMElement}
         */
        _nextSibling: function (dom) {
            dom = dom ? dom.nextSibling : null;
            while (dom !== null && dom.nodeType !== 1) {
                dom = dom.nextSibling;
            }
            return dom;
        },
        /**
         * gets the previous sibling of a DOM node. Used internally.
         * @private
         * @name _previousSibling(dom)
         * @param  {DOMElement} dom
         * @return {DOMElement}
         */
        _previousSibling: function (dom) {
            dom = dom ? dom.previousSibling : null;
            while (dom !== null && dom.nodeType !== 1) {
                dom = dom.previousSibling;
            }
            return dom;
        },
        /**
         * get the JSON representation of a node (or the actual jQuery extended DOM node) by using any input (child DOM element, ID string, selector, etc)
         * @name get_node(obj [, as_dom])
         * @param  {mixed} obj
         * @param  {Boolean} as_dom
         * @return {Object|jQuery}
         */
        get_node: function (obj, as_dom) {
            if (obj && obj.id) {
                obj = obj.id;
            }
            var dom;
            try {
                if (this._model.data[obj]) {
                    obj = this._model.data[obj];
                }
                else if (typeof obj === "string" && this._model.data[obj.replace(/^#/, '')]) {
                    obj = this._model.data[obj.replace(/^#/, '')];
                }
                else if (typeof obj === "string" && (dom = $('#' + obj.replace($.jstree.idregex, '\\$&'), this.element)).length && this._model.data[dom.closest('.jstree-node').attr('id')]) {
                    obj = this._model.data[dom.closest('.jstree-node').attr('id')];
                }
                else if ((dom = $(obj, this.element)).length && this._model.data[dom.closest('.jstree-node').attr('id')]) {
                    obj = this._model.data[dom.closest('.jstree-node').attr('id')];
                }
                else if ((dom = $(obj, this.element)).length && dom.hasClass('jstree')) {
                    obj = this._model.data[$.jstree.root];
                }
                else {
                    return false;
                }

                if (as_dom) {
                    obj = obj.id === $.jstree.root ? this.element : $('#' + obj.id.replace($.jstree.idregex, '\\$&'), this.element);
                }
                return obj;
            } catch (ex) { return false; }
        },
        /**
         * get the path to a node, either consisting of node texts, or of node IDs, optionally glued together (otherwise an array)
         * @name get_path(obj [, glue, ids])
         * @param  {mixed} obj the node
         * @param  {String} glue if you want the path as a string - pass the glue here (for example '/'), if a falsy value is supplied here, an array is returned
         * @param  {Boolean} ids if set to true build the path using ID, otherwise node text is used
         * @return {mixed}
         */
        get_path: function (obj, glue, ids) {
            obj = obj.parents ? obj : this.get_node(obj);
            if (!obj || obj.id === $.jstree.root || !obj.parents) {
                return false;
            }
            var i, j, p = [];
            p.push(ids ? obj.id : obj.text);
            for (i = 0, j = obj.parents.length; i < j; i++) {
                p.push(ids ? obj.parents[i] : this.get_text(obj.parents[i]));
            }
            p = p.reverse().slice(1);
            return glue ? p.join(glue) : p;
        },
        /**
         * get the next visible node that is below the `obj` node. If `strict` is set to `true` only sibling nodes are returned.
         * @name get_next_dom(obj [, strict])
         * @param  {mixed} obj
         * @param  {Boolean} strict
         * @return {jQuery}
         */
        get_next_dom: function (obj, strict) {
            var tmp;
            obj = this.get_node(obj, true);
            if (obj[0] === this.element[0]) {
                tmp = this._firstChild(this.get_container_ul()[0]);
                while (tmp && tmp.offsetHeight === 0) {
                    tmp = this._nextSibling(tmp);
                }
                return tmp ? $(tmp) : false;
            }
            if (!obj || !obj.length) {
                return false;
            }
            if (strict) {
                tmp = obj[0];
                do {
                    tmp = this._nextSibling(tmp);
                } while (tmp && tmp.offsetHeight === 0);
                return tmp ? $(tmp) : false;
            }
            if (obj.hasClass("jstree-open")) {
                tmp = this._firstChild(obj.children('.jstree-children')[0]);
                while (tmp && tmp.offsetHeight === 0) {
                    tmp = this._nextSibling(tmp);
                }
                if (tmp !== null) {
                    return $(tmp);
                }
            }
            tmp = obj[0];
            do {
                tmp = this._nextSibling(tmp);
            } while (tmp && tmp.offsetHeight === 0);
            if (tmp !== null) {
                return $(tmp);
            }
            return obj.parentsUntil(".jstree", ".jstree-node").nextAll(".jstree-node:visible").first();
        },
        /**
         * get the previous visible node that is above the `obj` node. If `strict` is set to `true` only sibling nodes are returned.
         * @name get_prev_dom(obj [, strict])
         * @param  {mixed} obj
         * @param  {Boolean} strict
         * @return {jQuery}
         */
        get_prev_dom: function (obj, strict) {
            var tmp;
            obj = this.get_node(obj, true);
            if (obj[0] === this.element[0]) {
                tmp = this.get_container_ul()[0].lastChild;
                while (tmp && tmp.offsetHeight === 0) {
                    tmp = this._previousSibling(tmp);
                }
                return tmp ? $(tmp) : false;
            }
            if (!obj || !obj.length) {
                return false;
            }
            if (strict) {
                tmp = obj[0];
                do {
                    tmp = this._previousSibling(tmp);
                } while (tmp && tmp.offsetHeight === 0);
                return tmp ? $(tmp) : false;
            }
            tmp = obj[0];
            do {
                tmp = this._previousSibling(tmp);
            } while (tmp && tmp.offsetHeight === 0);
            if (tmp !== null) {
                obj = $(tmp);
                while (obj.hasClass("jstree-open")) {
                    obj = obj.children(".jstree-children").first().children(".jstree-node:visible:last");
                }
                return obj;
            }
            tmp = obj[0].parentNode.parentNode;
            return tmp && tmp.className && tmp.className.indexOf('jstree-node') !== -1 ? $(tmp) : false;
        },
        /**
         * get the parent ID of a node
         * @name get_parent(obj)
         * @param  {mixed} obj
         * @return {String}
         */
        get_parent: function (obj) {
            obj = this.get_node(obj);
            if (!obj || obj.id === $.jstree.root) {
                return false;
            }
            return obj.parent;
        },
        /**
         * get a jQuery collection of all the children of a node (node must be rendered)
         * @name get_children_dom(obj)
         * @param  {mixed} obj
         * @return {jQuery}
         */
        get_children_dom: function (obj) {
            obj = this.get_node(obj, true);
            if (obj[0] === this.element[0]) {
                return this.get_container_ul().children(".jstree-node");
            }
            if (!obj || !obj.length) {
                return false;
            }
            return obj.children(".jstree-children").children(".jstree-node");
        },
        /**
         * checks if a node has children
         * @name is_parent(obj)
         * @param  {mixed} obj
         * @return {Boolean}
         */
        is_parent: function (obj) {
            obj = this.get_node(obj);
            return obj && (obj.state.loaded === false || obj.children.length > 0);
        },
        /**
         * checks if a node is loaded (its children are available)
         * @name is_loaded(obj)
         * @param  {mixed} obj
         * @return {Boolean}
         */
        is_loaded: function (obj) {
            obj = this.get_node(obj);
            return obj && obj.state.loaded;
        },
        /**
         * check if a node is currently loading (fetching children)
         * @name is_loading(obj)
         * @param  {mixed} obj
         * @return {Boolean}
         */
        is_loading: function (obj) {
            obj = this.get_node(obj);
            return obj && obj.state && obj.state.loading;
        },
        /**
         * check if a node is opened
         * @name is_open(obj)
         * @param  {mixed} obj
         * @return {Boolean}
         */
        is_open: function (obj) {
            obj = this.get_node(obj);
            return obj && obj.state.opened;
        },
        /**
         * check if a node is in a closed state
         * @name is_closed(obj)
         * @param  {mixed} obj
         * @return {Boolean}
         */
        is_closed: function (obj) {
            obj = this.get_node(obj);
            return obj && this.is_parent(obj) && !obj.state.opened;
        },
        /**
         * check if a node has no children
         * @name is_leaf(obj)
         * @param  {mixed} obj
         * @return {Boolean}
         */
        is_leaf: function (obj) {
            return !this.is_parent(obj);
        },
        /**
         * loads a node (fetches its children using the `core.data` setting). Multiple nodes can be passed to by using an array.
         * @name load_node(obj [, callback])
         * @param  {mixed} obj
         * @param  {function} callback a function to be executed once loading is complete, the function is executed in the instance's scope and receives two arguments - the node and a boolean status
         * @return {Boolean}
         * @trigger load_node.jstree
         */
        load_node: function (obj, callback) {
            var k, l, i, j, c;
            if ($.isArray(obj)) {
                this._load_nodes(obj.slice(), callback);
                return true;
            }
            obj = this.get_node(obj);
            if (!obj) {
                if (callback) { callback.call(this, obj, false); }
                return false;
            }
            // if(obj.state.loading) { } // the node is already loading - just wait for it to load and invoke callback? but if called implicitly it should be loaded again?
            if (obj.state.loaded) {
                obj.state.loaded = false;
                for (i = 0, j = obj.parents.length; i < j; i++) {
                    this._model.data[obj.parents[i]].children_d = $.vakata.array_filter(this._model.data[obj.parents[i]].children_d, function (v) {
                        return $.inArray(v, obj.children_d) === -1;
                    });
                }
                for (k = 0, l = obj.children_d.length; k < l; k++) {
                    if (this._model.data[obj.children_d[k]].state.selected) {
                        c = true;
                    }
                    delete this._model.data[obj.children_d[k]];
                }
                if (c) {
                    this._data.core.selected = $.vakata.array_filter(this._data.core.selected, function (v) {
                        return $.inArray(v, obj.children_d) === -1;
                    });
                }
                obj.children = [];
                obj.children_d = [];
                if (c) {
                    this.trigger('changed', { 'action': 'load_node', 'node': obj, 'selected': this._data.core.selected });
                }
            }
            obj.state.failed = false;
            obj.state.loading = true;
            this.get_node(obj, true).addClass("jstree-loading").attr('aria-busy', true);
            this._load_node(obj, $.proxy(function (status) {
                obj = this._model.data[obj.id];
                obj.state.loading = false;
                obj.state.loaded = status;
                obj.state.failed = !obj.state.loaded;
                var dom = this.get_node(obj, true), i = 0, j = 0, m = this._model.data, has_children = false;
                for (i = 0, j = obj.children.length; i < j; i++) {
                    if (m[obj.children[i]] && !m[obj.children[i]].state.hidden) {
                        has_children = true;
                        break;
                    }
                }
                if (obj.state.loaded && dom && dom.length) {
                    dom.removeClass('jstree-closed jstree-open jstree-leaf');
                    if (!has_children) {
                        dom.addClass('jstree-leaf');
                    }
                    else {
                        if (obj.id !== '#') {
                            dom.addClass(obj.state.opened ? 'jstree-open' : 'jstree-closed');
                        }
                    }
                }
                dom.removeClass("jstree-loading").attr('aria-busy', false);
                /**
                 * triggered after a node is loaded
                 * @event
                 * @name load_node.jstree
                 * @param {Object} node the node that was loading
                 * @param {Boolean} status was the node loaded successfully
                 */
                this.trigger('load_node', { "node": obj, "status": status });
                if (callback) {
                    callback.call(this, obj, status);
                }
            }, this));
            return true;
        },
        /**
         * load an array of nodes (will also load unavailable nodes as soon as the appear in the structure). Used internally.
         * @private
         * @name _load_nodes(nodes [, callback])
         * @param  {array} nodes
         * @param  {function} callback a function to be executed once loading is complete, the function is executed in the instance's scope and receives one argument - the array passed to _load_nodes
         */
        _load_nodes: function (nodes, callback, is_callback, force_reload) {
            var r = true,
                c = function () { this._load_nodes(nodes, callback, true); },
                m = this._model.data, i, j, tmp = [];
            for (i = 0, j = nodes.length; i < j; i++) {
                if (m[nodes[i]] && ((!m[nodes[i]].state.loaded && !m[nodes[i]].state.failed) || (!is_callback && force_reload))) {
                    if (!this.is_loading(nodes[i])) {
                        this.load_node(nodes[i], c);
                    }
                    r = false;
                }
            }
            if (r) {
                for (i = 0, j = nodes.length; i < j; i++) {
                    if (m[nodes[i]] && m[nodes[i]].state.loaded) {
                        tmp.push(nodes[i]);
                    }
                }
                if (callback && !callback.done) {
                    callback.call(this, tmp);
                    callback.done = true;
                }
            }
        },
        /**
         * loads all unloaded nodes
         * @name load_all([obj, callback])
         * @param {mixed} obj the node to load recursively, omit to load all nodes in the tree
         * @param {function} callback a function to be executed once loading all the nodes is complete,
         * @trigger load_all.jstree
         */
        load_all: function (obj, callback) {
            if (!obj) { obj = $.jstree.root; }
            obj = this.get_node(obj);
            if (!obj) { return false; }
            var to_load = [],
                m = this._model.data,
                c = m[obj.id].children_d,
                i, j;
            if (obj.state && !obj.state.loaded) {
                to_load.push(obj.id);
            }
            for (i = 0, j = c.length; i < j; i++) {
                if (m[c[i]] && m[c[i]].state && !m[c[i]].state.loaded) {
                    to_load.push(c[i]);
                }
            }
            if (to_load.length) {
                this._load_nodes(to_load, function () {
                    this.load_all(obj, callback);
                });
            }
            else {
                /**
                 * triggered after a load_all call completes
                 * @event
                 * @name load_all.jstree
                 * @param {Object} node the recursively loaded node
                 */
                if (callback) { callback.call(this, obj); }
                this.trigger('load_all', { "node": obj });
            }
        },
        /**
         * handles the actual loading of a node. Used only internally.
         * @private
         * @name _load_node(obj [, callback])
         * @param  {mixed} obj
         * @param  {function} callback a function to be executed once loading is complete, the function is executed in the instance's scope and receives one argument - a boolean status
         * @return {Boolean}
         */
        _load_node: function (obj, callback) {
            var s = this.settings.core.data, t;
            var notTextOrCommentNode = function notTextOrCommentNode() {
                return this.nodeType !== 3 && this.nodeType !== 8;
            };
            // use original HTML
            if (!s) {
                if (obj.id === $.jstree.root) {
                    return this._append_html_data(obj, this._data.core.original_container_html.clone(true), function (status) {
                        callback.call(this, status);
                    });
                }
                else {
                    return callback.call(this, false);
                }
                // return callback.call(this, obj.id === $.jstree.root ? this._append_html_data(obj, this._data.core.original_container_html.clone(true)) : false);
            }
            if ($.isFunction(s)) {
                return s.call(this, obj, $.proxy(function (d) {
                    if (d === false) {
                        callback.call(this, false);
                    }
                    else {
                        this[typeof d === 'string' ? '_append_html_data' : '_append_json_data'](obj, typeof d === 'string' ? $($.parseHTML(d)).filter(notTextOrCommentNode) : d, function (status) {
                            callback.call(this, status);
                        });
                    }
                    // return d === false ? callback.call(this, false) : callback.call(this, this[typeof d === 'string' ? '_append_html_data' : '_append_json_data'](obj, typeof d === 'string' ? $(d) : d));
                }, this));
            }
            if (typeof s === 'object') {
                if (s.url) {
                    s = $.extend(true, {}, s);
                    if ($.isFunction(s.url)) {
                        s.url = s.url.call(this, obj);
                    }
                    if ($.isFunction(s.data)) {
                        s.data = s.data.call(this, obj);
                    }
                    return $.ajax(s)
                        .done($.proxy(function (d, t, x) {
                            var type = x.getResponseHeader('Content-Type');
                            if ((type && type.indexOf('json') !== -1) || typeof d === "object") {
                                return this._append_json_data(obj, d, function (status) { callback.call(this, status); });
                                //return callback.call(this, this._append_json_data(obj, d));
                            }
                            if ((type && type.indexOf('html') !== -1) || typeof d === "string") {
                                return this._append_html_data(obj, $($.parseHTML(d)).filter(notTextOrCommentNode), function (status) { callback.call(this, status); });
                                // return callback.call(this, this._append_html_data(obj, $(d)));
                            }
                            this._data.core.last_error = { 'error': 'ajax', 'plugin': 'core', 'id': 'core_04', 'reason': 'Could not load node', 'data': JSON.stringify({ 'id': obj.id, 'xhr': x }) };
                            this.settings.core.error.call(this, this._data.core.last_error);
                            return callback.call(this, false);
                        }, this))
                        .fail($.proxy(function (f) {
                            callback.call(this, false);
                            this._data.core.last_error = { 'error': 'ajax', 'plugin': 'core', 'id': 'core_04', 'reason': 'Could not load node', 'data': JSON.stringify({ 'id': obj.id, 'xhr': f }) };
                            this.settings.core.error.call(this, this._data.core.last_error);
                        }, this));
                }
                t = ($.isArray(s) || $.isPlainObject(s)) ? JSON.parse(JSON.stringify(s)) : s;
                if (obj.id === $.jstree.root) {
                    return this._append_json_data(obj, t, function (status) {
                        callback.call(this, status);
                    });
                }
                else {
                    this._data.core.last_error = { 'error': 'nodata', 'plugin': 'core', 'id': 'core_05', 'reason': 'Could not load node', 'data': JSON.stringify({ 'id': obj.id }) };
                    this.settings.core.error.call(this, this._data.core.last_error);
                    return callback.call(this, false);
                }
                //return callback.call(this, (obj.id === $.jstree.root ? this._append_json_data(obj, t) : false) );
            }
            if (typeof s === 'string') {
                if (obj.id === $.jstree.root) {
                    return this._append_html_data(obj, $($.parseHTML(s)).filter(notTextOrCommentNode), function (status) {
                        callback.call(this, status);
                    });
                }
                else {
                    this._data.core.last_error = { 'error': 'nodata', 'plugin': 'core', 'id': 'core_06', 'reason': 'Could not load node', 'data': JSON.stringify({ 'id': obj.id }) };
                    this.settings.core.error.call(this, this._data.core.last_error);
                    return callback.call(this, false);
                }
                //return callback.call(this, (obj.id === $.jstree.root ? this._append_html_data(obj, $(s)) : false) );
            }
            return callback.call(this, false);
        },
        /**
         * adds a node to the list of nodes to redraw. Used only internally.
         * @private
         * @name _node_changed(obj [, callback])
         * @param  {mixed} obj
         */
        _node_changed: function (obj) {
            obj = this.get_node(obj);
            if (obj) {
                this._model.changed.push(obj.id);
            }
        },
        /**
         * appends HTML content to the tree. Used internally.
         * @private
         * @name _append_html_data(obj, data)
         * @param  {mixed} obj the node to append to
         * @param  {String} data the HTML string to parse and append
         * @trigger model.jstree, changed.jstree
         */
        _append_html_data: function (dom, data, cb) {
            dom = this.get_node(dom);
            dom.children = [];
            dom.children_d = [];
            var dat = data.is('ul') ? data.children() : data,
                par = dom.id,
                chd = [],
                dpc = [],
                m = this._model.data,
                p = m[par],
                s = this._data.core.selected.length,
                tmp, i, j;
            dat.each($.proxy(function (i, v) {
                tmp = this._parse_model_from_html($(v), par, p.parents.concat());
                if (tmp) {
                    chd.push(tmp);
                    dpc.push(tmp);
                    if (m[tmp].children_d.length) {
                        dpc = dpc.concat(m[tmp].children_d);
                    }
                }
            }, this));
            p.children = chd;
            p.children_d = dpc;
            for (i = 0, j = p.parents.length; i < j; i++) {
                m[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);
            }
            /**
             * triggered when new data is inserted to the tree model
             * @event
             * @name model.jstree
             * @param {Array} nodes an array of node IDs
             * @param {String} parent the parent ID of the nodes
             */
            this.trigger('model', { "nodes": dpc, 'parent': par });
            if (par !== $.jstree.root) {
                this._node_changed(par);
                this.redraw();
            }
            else {
                this.get_container_ul().children('.jstree-initial-node').remove();
                this.redraw(true);
            }
            if (this._data.core.selected.length !== s) {
                this.trigger('changed', { 'action': 'model', 'selected': this._data.core.selected });
            }
            cb.call(this, true);
        },
        /**
         * appends JSON content to the tree. Used internally.
         * @private
         * @name _append_json_data(obj, data)
         * @param  {mixed} obj the node to append to
         * @param  {String} data the JSON object to parse and append
         * @param  {Boolean} force_processing internal param - do not set
         * @trigger model.jstree, changed.jstree
         */
        _append_json_data: function (dom, data, cb, force_processing) {
            if (this.element === null) { return; }
            dom = this.get_node(dom);
            dom.children = [];
            dom.children_d = [];
            // *%$@!!!
            if (data.d) {
                data = data.d;
                if (typeof data === "string") {
                    data = JSON.parse(data);
                }
            }
            if (!$.isArray(data)) { data = [data]; }
            var w = null,
                args = {
                    'df': this._model.default_state,
                    'dat': data,
                    'par': dom.id,
                    'm': this._model.data,
                    't_id': this._id,
                    't_cnt': this._cnt,
                    'sel': this._data.core.selected
                },
                func = function (data, undefined) {
                    if (data.data) { data = data.data; }
                    var dat = data.dat,
                        par = data.par,
                        chd = [],
                        dpc = [],
                        add = [],
                        df = data.df,
                        t_id = data.t_id,
                        t_cnt = data.t_cnt,
                        m = data.m,
                        p = m[par],
                        sel = data.sel,
                        tmp, i, j, rslt,
                        parse_flat = function (d, p, ps) {
                            if (!ps) { ps = []; }
                            else { ps = ps.concat(); }
                            if (p) { ps.unshift(p); }
                            var tid = d.id.toString(),
                                i, j, c, e,
                                tmp = {
                                    id: tid,
                                    text: d.text || '',
                                    icon: d.icon !== undefined ? d.icon : true,
                                    parent: p,
                                    parents: ps,
                                    children: d.children || [],
                                    children_d: d.children_d || [],
                                    data: d.data,
                                    state: {},
                                    li_attr: { id: false },
                                    a_attr: { href: '#' },
                                    original: false
                                };
                            for (i in df) {
                                if (df.hasOwnProperty(i)) {
                                    tmp.state[i] = df[i];
                                }
                            }
                            if (d && d.data && d.data.jstree && d.data.jstree.icon) {
                                tmp.icon = d.data.jstree.icon;
                            }
                            if (tmp.icon === undefined || tmp.icon === null || tmp.icon === "") {
                                tmp.icon = true;
                            }
                            if (d && d.data) {
                                tmp.data = d.data;
                                if (d.data.jstree) {
                                    for (i in d.data.jstree) {
                                        if (d.data.jstree.hasOwnProperty(i)) {
                                            tmp.state[i] = d.data.jstree[i];
                                        }
                                    }
                                }
                            }
                            if (d && typeof d.state === 'object') {
                                for (i in d.state) {
                                    if (d.state.hasOwnProperty(i)) {
                                        tmp.state[i] = d.state[i];
                                    }
                                }
                            }
                            if (d && typeof d.li_attr === 'object') {
                                for (i in d.li_attr) {
                                    if (d.li_attr.hasOwnProperty(i)) {
                                        tmp.li_attr[i] = d.li_attr[i];
                                    }
                                }
                            }
                            if (!tmp.li_attr.id) {
                                tmp.li_attr.id = tid;
                            }
                            if (d && typeof d.a_attr === 'object') {
                                for (i in d.a_attr) {
                                    if (d.a_attr.hasOwnProperty(i)) {
                                        tmp.a_attr[i] = d.a_attr[i];
                                    }
                                }
                            }
                            if (d && d.children && d.children === true) {
                                tmp.state.loaded = false;
                                tmp.children = [];
                                tmp.children_d = [];
                            }
                            m[tmp.id] = tmp;
                            for (i = 0, j = tmp.children.length; i < j; i++) {
                                c = parse_flat(m[tmp.children[i]], tmp.id, ps);
                                e = m[c];
                                tmp.children_d.push(c);
                                if (e.children_d.length) {
                                    tmp.children_d = tmp.children_d.concat(e.children_d);
                                }
                            }
                            delete d.data;
                            delete d.children;
                            m[tmp.id].original = d;
                            if (tmp.state.selected) {
                                add.push(tmp.id);
                            }
                            return tmp.id;
                        },
                        parse_nest = function (d, p, ps) {
                            if (!ps) { ps = []; }
                            else { ps = ps.concat(); }
                            if (p) { ps.unshift(p); }
                            var tid = false, i, j, c, e, tmp;
                            do {
                                tid = 'j' + t_id + '_' + (++t_cnt);
                            } while (m[tid]);

                            tmp = {
                                id: false,
                                text: typeof d === 'string' ? d : '',
                                icon: typeof d === 'object' && d.icon !== undefined ? d.icon : true,
                                parent: p,
                                parents: ps,
                                children: [],
                                children_d: [],
                                data: null,
                                state: {},
                                li_attr: { id: false },
                                a_attr: { href: '#' },
                                original: false
                            };
                            for (i in df) {
                                if (df.hasOwnProperty(i)) {
                                    tmp.state[i] = df[i];
                                }
                            }
                            if (d && d.id) { tmp.id = d.id.toString(); }
                            if (d && d.text) { tmp.text = d.text; }
                            if (d && d.data && d.data.jstree && d.data.jstree.icon) {
                                tmp.icon = d.data.jstree.icon;
                            }
                            if (tmp.icon === undefined || tmp.icon === null || tmp.icon === "") {
                                tmp.icon = true;
                            }
                            if (d && d.data) {
                                tmp.data = d.data;
                                if (d.data.jstree) {
                                    for (i in d.data.jstree) {
                                        if (d.data.jstree.hasOwnProperty(i)) {
                                            tmp.state[i] = d.data.jstree[i];
                                        }
                                    }
                                }
                            }
                            if (d && typeof d.state === 'object') {
                                for (i in d.state) {
                                    if (d.state.hasOwnProperty(i)) {
                                        tmp.state[i] = d.state[i];
                                    }
                                }
                            }
                            if (d && typeof d.li_attr === 'object') {
                                for (i in d.li_attr) {
                                    if (d.li_attr.hasOwnProperty(i)) {
                                        tmp.li_attr[i] = d.li_attr[i];
                                    }
                                }
                            }
                            if (tmp.li_attr.id && !tmp.id) {
                                tmp.id = tmp.li_attr.id.toString();
                            }
                            if (!tmp.id) {
                                tmp.id = tid;
                            }
                            if (!tmp.li_attr.id) {
                                tmp.li_attr.id = tmp.id;
                            }
                            if (d && typeof d.a_attr === 'object') {
                                for (i in d.a_attr) {
                                    if (d.a_attr.hasOwnProperty(i)) {
                                        tmp.a_attr[i] = d.a_attr[i];
                                    }
                                }
                            }
                            if (d && d.children && d.children.length) {
                                for (i = 0, j = d.children.length; i < j; i++) {
                                    c = parse_nest(d.children[i], tmp.id, ps);
                                    e = m[c];
                                    tmp.children.push(c);
                                    if (e.children_d.length) {
                                        tmp.children_d = tmp.children_d.concat(e.children_d);
                                    }
                                }
                                tmp.children_d = tmp.children_d.concat(tmp.children);
                            }
                            if (d && d.children && d.children === true) {
                                tmp.state.loaded = false;
                                tmp.children = [];
                                tmp.children_d = [];
                            }
                            delete d.data;
                            delete d.children;
                            tmp.original = d;
                            m[tmp.id] = tmp;
                            if (tmp.state.selected) {
                                add.push(tmp.id);
                            }
                            return tmp.id;
                        };

                    if (dat.length && dat[0].id !== undefined && dat[0].parent !== undefined) {
                        // Flat JSON support (for easy import from DB):
                        // 1) convert to object (foreach)
                        for (i = 0, j = dat.length; i < j; i++) {
                            if (!dat[i].children) {
                                dat[i].children = [];
                            }
                            m[dat[i].id.toString()] = dat[i];
                        }
                        // 2) populate children (foreach)
                        for (i = 0, j = dat.length; i < j; i++) {
                            m[dat[i].parent.toString()].children.push(dat[i].id.toString());
                            // populate parent.children_d
                            p.children_d.push(dat[i].id.toString());
                        }
                        // 3) normalize && populate parents and children_d with recursion
                        for (i = 0, j = p.children.length; i < j; i++) {
                            tmp = parse_flat(m[p.children[i]], par, p.parents.concat());
                            dpc.push(tmp);
                            if (m[tmp].children_d.length) {
                                dpc = dpc.concat(m[tmp].children_d);
                            }
                        }
                        for (i = 0, j = p.parents.length; i < j; i++) {
                            m[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);
                        }
                        // ?) three_state selection - p.state.selected && t - (if three_state foreach(dat => ch) -> foreach(parents) if(parent.selected) child.selected = true;
                        rslt = {
                            'cnt': t_cnt,
                            'mod': m,
                            'sel': sel,
                            'par': par,
                            'dpc': dpc,
                            'add': add
                        };
                    }
                    else {
                        for (i = 0, j = dat.length; i < j; i++) {
                            tmp = parse_nest(dat[i], par, p.parents.concat());
                            if (tmp) {
                                chd.push(tmp);
                                dpc.push(tmp);
                                if (m[tmp].children_d.length) {
                                    dpc = dpc.concat(m[tmp].children_d);
                                }
                            }
                        }
                        p.children = chd;
                        p.children_d = dpc;
                        for (i = 0, j = p.parents.length; i < j; i++) {
                            m[p.parents[i]].children_d = m[p.parents[i]].children_d.concat(dpc);
                        }
                        rslt = {
                            'cnt': t_cnt,
                            'mod': m,
                            'sel': sel,
                            'par': par,
                            'dpc': dpc,
                            'add': add
                        };
                    }
                    if (typeof window === 'undefined' || typeof window.document === 'undefined') {
                        postMessage(rslt);
                    }
                    else {
                        return rslt;
                    }
                },
                rslt = function (rslt, worker) {
                    if (this.element === null) { return; }
                    this._cnt = rslt.cnt;
                    var i, m = this._model.data;
                    for (i in m) {
                        if (m.hasOwnProperty(i) && m[i].state && m[i].state.loading && rslt.mod[i]) {
                            rslt.mod[i].state.loading = true;
                        }
                    }
                    this._model.data = rslt.mod; // breaks the reference in load_node - careful

                    if (worker) {
                        var j, a = rslt.add, r = rslt.sel, s = this._data.core.selected.slice();
                        m = this._model.data;
                        // if selection was changed while calculating in worker
                        if (r.length !== s.length || $.vakata.array_unique(r.concat(s)).length !== r.length) {
                            // deselect nodes that are no longer selected
                            for (i = 0, j = r.length; i < j; i++) {
                                if ($.inArray(r[i], a) === -1 && $.inArray(r[i], s) === -1) {
                                    m[r[i]].state.selected = false;
                                }
                            }
                            // select nodes that were selected in the mean time
                            for (i = 0, j = s.length; i < j; i++) {
                                if ($.inArray(s[i], r) === -1) {
                                    m[s[i]].state.selected = true;
                                }
                            }
                        }
                    }
                    if (rslt.add.length) {
                        this._data.core.selected = this._data.core.selected.concat(rslt.add);
                    }

                    this.trigger('model', { "nodes": rslt.dpc, 'parent': rslt.par });

                    if (rslt.par !== $.jstree.root) {
                        this._node_changed(rslt.par);
                        this.redraw();
                    }
                    else {
                        // this.get_container_ul().children('.jstree-initial-node').remove();
                        this.redraw(true);
                    }
                    if (rslt.add.length) {
                        this.trigger('changed', { 'action': 'model', 'selected': this._data.core.selected });
                    }
                    cb.call(this, true);
                };
            if (this.settings.core.worker && window.Blob && window.URL && window.Worker) {
                try {
                    if (this._wrk === null) {
                        this._wrk = window.URL.createObjectURL(
                            new window.Blob(
                                ['self.onmessage = ' + func.toString()],
                                { type: "text/javascript" }
                            )
                        );
                    }
                    if (!this._data.core.working || force_processing) {
                        this._data.core.working = true;
                        w = new window.Worker(this._wrk);
                        w.onmessage = $.proxy(function (e) {
                            rslt.call(this, e.data, true);
                            try { w.terminate(); w = null; } catch (ignore) { }
                            if (this._data.core.worker_queue.length) {
                                this._append_json_data.apply(this, this._data.core.worker_queue.shift());
                            }
                            else {
                                this._data.core.working = false;
                            }
                        }, this);
                        if (!args.par) {
                            if (this._data.core.worker_queue.length) {
                                this._append_json_data.apply(this, this._data.core.worker_queue.shift());
                            }
                            else {
                                this._data.core.working = false;
                            }
                        }
                        else {
                            w.postMessage(args);
                        }
                    }
                    else {
                        this._data.core.worker_queue.push([dom, data, cb, true]);
                    }
                }
                catch (e) {
                    rslt.call(this, func(args), false);
                    if (this._data.core.worker_queue.length) {
                        this._append_json_data.apply(this, this._data.core.worker_queue.shift());
                    }
                    else {
                        this._data.core.working = false;
                    }
                }
            }
            else {
                rslt.call(this, func(args), false);
            }
        },
        /**
         * parses a node from a jQuery object and appends them to the in memory tree model. Used internally.
         * @private
         * @name _parse_model_from_html(d [, p, ps])
         * @param  {jQuery} d the jQuery object to parse
         * @param  {String} p the parent ID
         * @param  {Array} ps list of all parents
         * @return {String} the ID of the object added to the model
         */
        _parse_model_from_html: function (d, p, ps) {
            if (!ps) { ps = []; }
            else { ps = [].concat(ps); }
            if (p) { ps.unshift(p); }
            var c, e, m = this._model.data,
                data = {
                    id: false,
                    text: false,
                    icon: true,
                    parent: p,
                    parents: ps,
                    children: [],
                    children_d: [],
                    data: null,
                    state: {},
                    li_attr: { id: false },
                    a_attr: { href: '#' },
                    original: false
                }, i, tmp, tid;
            for (i in this._model.default_state) {
                if (this._model.default_state.hasOwnProperty(i)) {
                    data.state[i] = this._model.default_state[i];
                }
            }
            tmp = $.vakata.attributes(d, true);
            $.each(tmp, function (i, v) {
                v = $.trim(v);
                if (!v.length) { return true; }
                data.li_attr[i] = v;
                if (i === 'id') {
                    data.id = v.toString();
                }
            });
            tmp = d.children('a').first();
            if (tmp.length) {
                tmp = $.vakata.attributes(tmp, true);
                $.each(tmp, function (i, v) {
                    v = $.trim(v);
                    if (v.length) {
                        data.a_attr[i] = v;
                    }
                });
            }
            tmp = d.children("a").first().length ? d.children("a").first().clone() : d.clone();
            tmp.children("ins, i, ul").remove();
            tmp = tmp.html();
            tmp = $('<div />').html(tmp);
            data.text = this.settings.core.force_text ? tmp.text() : tmp.html();
            tmp = d.data();
            data.data = tmp ? $.extend(true, {}, tmp) : null;
            data.state.opened = d.hasClass('jstree-open');
            data.state.selected = d.children('a').hasClass('jstree-clicked');
            data.state.disabled = d.children('a').hasClass('jstree-disabled');
            if (data.data && data.data.jstree) {
                for (i in data.data.jstree) {
                    if (data.data.jstree.hasOwnProperty(i)) {
                        data.state[i] = data.data.jstree[i];
                    }
                }
            }
            tmp = d.children("a").children(".jstree-themeicon");
            if (tmp.length) {
                data.icon = tmp.hasClass('jstree-themeicon-hidden') ? false : tmp.attr('rel');
            }
            if (data.state.icon !== undefined) {
                data.icon = data.state.icon;
            }
            if (data.icon === undefined || data.icon === null || data.icon === "") {
                data.icon = true;
            }
            tmp = d.children("ul").children("li");
            do {
                tid = 'j' + this._id + '_' + (++this._cnt);
            } while (m[tid]);
            data.id = data.li_attr.id ? data.li_attr.id.toString() : tid;
            if (tmp.length) {
                tmp.each($.proxy(function (i, v) {
                    c = this._parse_model_from_html($(v), data.id, ps);
                    e = this._model.data[c];
                    data.children.push(c);
                    if (e.children_d.length) {
                        data.children_d = data.children_d.concat(e.children_d);
                    }
                }, this));
                data.children_d = data.children_d.concat(data.children);
            }
            else {
                if (d.hasClass('jstree-closed')) {
                    data.state.loaded = false;
                }
            }
            if (data.li_attr['class']) {
                data.li_attr['class'] = data.li_attr['class'].replace('jstree-closed', '').replace('jstree-open', '');
            }
            if (data.a_attr['class']) {
                data.a_attr['class'] = data.a_attr['class'].replace('jstree-clicked', '').replace('jstree-disabled', '');
            }
            m[data.id] = data;
            if (data.state.selected) {
                this._data.core.selected.push(data.id);
            }
            return data.id;
        },
        /**
         * parses a node from a JSON object (used when dealing with flat data, which has no nesting of children, but has id and parent properties) and appends it to the in memory tree model. Used internally.
         * @private
         * @name _parse_model_from_flat_json(d [, p, ps])
         * @param  {Object} d the JSON object to parse
         * @param  {String} p the parent ID
         * @param  {Array} ps list of all parents
         * @return {String} the ID of the object added to the model
         */
        _parse_model_from_flat_json: function (d, p, ps) {
            if (!ps) { ps = []; }
            else { ps = ps.concat(); }
            if (p) { ps.unshift(p); }
            var tid = d.id.toString(),
                m = this._model.data,
                df = this._model.default_state,
                i, j, c, e,
                tmp = {
                    id: tid,
                    text: d.text || '',
                    icon: d.icon !== undefined ? d.icon : true,
                    parent: p,
                    parents: ps,
                    children: d.children || [],
                    children_d: d.children_d || [],
                    data: d.data,
                    state: {},
                    li_attr: { id: false },
                    a_attr: { href: '#' },
                    original: false
                };
            for (i in df) {
                if (df.hasOwnProperty(i)) {
                    tmp.state[i] = df[i];
                }
            }
            if (d && d.data && d.data.jstree && d.data.jstree.icon) {
                tmp.icon = d.data.jstree.icon;
            }
            if (tmp.icon === undefined || tmp.icon === null || tmp.icon === "") {
                tmp.icon = true;
            }
            if (d && d.data) {
                tmp.data = d.data;
                if (d.data.jstree) {
                    for (i in d.data.jstree) {
                        if (d.data.jstree.hasOwnProperty(i)) {
                            tmp.state[i] = d.data.jstree[i];
                        }
                    }
                }
            }
            if (d && typeof d.state === 'object') {
                for (i in d.state) {
                    if (d.state.hasOwnProperty(i)) {
                        tmp.state[i] = d.state[i];
                    }
                }
            }
            if (d && typeof d.li_attr === 'object') {
                for (i in d.li_attr) {
                    if (d.li_attr.hasOwnProperty(i)) {
                        tmp.li_attr[i] = d.li_attr[i];
                    }
                }
            }
            if (!tmp.li_attr.id) {
                tmp.li_attr.id = tid;
            }
            if (d && typeof d.a_attr === 'object') {
                for (i in d.a_attr) {
                    if (d.a_attr.hasOwnProperty(i)) {
                        tmp.a_attr[i] = d.a_attr[i];
                    }
                }
            }
            if (d && d.children && d.children === true) {
                tmp.state.loaded = false;
                tmp.children = [];
                tmp.children_d = [];
            }
            m[tmp.id] = tmp;
            for (i = 0, j = tmp.children.length; i < j; i++) {
                c = this._parse_model_from_flat_json(m[tmp.children[i]], tmp.id, ps);
                e = m[c];
                tmp.children_d.push(c);
                if (e.children_d.length) {
                    tmp.children_d = tmp.children_d.concat(e.children_d);
                }
            }
            delete d.data;
            delete d.children;
            m[tmp.id].original = d;
            if (tmp.state.selected) {
                this._data.core.selected.push(tmp.id);
            }
            return tmp.id;
        },
        /**
         * parses a node from a JSON object and appends it to the in memory tree model. Used internally.
         * @private
         * @name _parse_model_from_json(d [, p, ps])
         * @param  {Object} d the JSON object to parse
         * @param  {String} p the parent ID
         * @param  {Array} ps list of all parents
         * @return {String} the ID of the object added to the model
         */
        _parse_model_from_json: function (d, p, ps) {
            if (!ps) { ps = []; }
            else { ps = ps.concat(); }
            if (p) { ps.unshift(p); }
            var tid = false, i, j, c, e, m = this._model.data, df = this._model.default_state, tmp;
            do {
                tid = 'j' + this._id + '_' + (++this._cnt);
            } while (m[tid]);

            tmp = {
                id: false,
                text: typeof d === 'string' ? d : '',
                icon: typeof d === 'object' && d.icon !== undefined ? d.icon : true,
                parent: p,
                parents: ps,
                children: [],
                children_d: [],
                data: null,
                state: {},
                li_attr: { id: false },
                a_attr: { href: '#' },
                original: false
            };
            for (i in df) {
                if (df.hasOwnProperty(i)) {
                    tmp.state[i] = df[i];
                }
            }
            if (d && d.id) { tmp.id = d.id.toString(); }
            if (d && d.text) { tmp.text = d.text; }
            if (d && d.data && d.data.jstree && d.data.jstree.icon) {
                tmp.icon = d.data.jstree.icon;
            }
            if (tmp.icon === undefined || tmp.icon === null || tmp.icon === "") {
                tmp.icon = true;
            }
            if (d && d.data) {
                tmp.data = d.data;
                if (d.data.jstree) {
                    for (i in d.data.jstree) {
                        if (d.data.jstree.hasOwnProperty(i)) {
                            tmp.state[i] = d.data.jstree[i];
                        }
                    }
                }
            }
            if (d && typeof d.state === 'object') {
                for (i in d.state) {
                    if (d.state.hasOwnProperty(i)) {
                        tmp.state[i] = d.state[i];
                    }
                }
            }
            if (d && typeof d.li_attr === 'object') {
                for (i in d.li_attr) {
                    if (d.li_attr.hasOwnProperty(i)) {
                        tmp.li_attr[i] = d.li_attr[i];
                    }
                }
            }
            if (tmp.li_attr.id && !tmp.id) {
                tmp.id = tmp.li_attr.id.toString();
            }
            if (!tmp.id) {
                tmp.id = tid;
            }
            if (!tmp.li_attr.id) {
                tmp.li_attr.id = tmp.id;
            }
            if (d && typeof d.a_attr === 'object') {
                for (i in d.a_attr) {
                    if (d.a_attr.hasOwnProperty(i)) {
                        tmp.a_attr[i] = d.a_attr[i];
                    }
                }
            }
            if (d && d.children && d.children.length) {
                for (i = 0, j = d.children.length; i < j; i++) {
                    c = this._parse_model_from_json(d.children[i], tmp.id, ps);
                    e = m[c];
                    tmp.children.push(c);
                    if (e.children_d.length) {
                        tmp.children_d = tmp.children_d.concat(e.children_d);
                    }
                }
                tmp.children_d = tmp.children_d.concat(tmp.children);
            }
            if (d && d.children && d.children === true) {
                tmp.state.loaded = false;
                tmp.children = [];
                tmp.children_d = [];
            }
            delete d.data;
            delete d.children;
            tmp.original = d;
            m[tmp.id] = tmp;
            if (tmp.state.selected) {
                this._data.core.selected.push(tmp.id);
            }
            return tmp.id;
        },
        /**
         * redraws all nodes that need to be redrawn. Used internally.
         * @private
         * @name _redraw()
         * @trigger redraw.jstree
         */
        _redraw: function () {
            var nodes = this._model.force_full_redraw ? this._model.data[$.jstree.root].children.concat([]) : this._model.changed.concat([]),
                f = document.createElement('UL'), tmp, i, j, fe = this._data.core.focused;
            for (i = 0, j = nodes.length; i < j; i++) {
                tmp = this.redraw_node(nodes[i], true, this._model.force_full_redraw);
                if (tmp && this._model.force_full_redraw) {
                    f.appendChild(tmp);
                }
            }
            if (this._model.force_full_redraw) {
                f.className = this.get_container_ul()[0].className;
                f.setAttribute('role', 'group');
                this.element.empty().append(f);
                //this.get_container_ul()[0].appendChild(f);
            }
            if (fe !== null) {
                tmp = this.get_node(fe, true);
                if (tmp && tmp.length && tmp.children('.jstree-anchor')[0] !== document.activeElement) {
                    tmp.children('.jstree-anchor').focus();
                }
                else {
                    this._data.core.focused = null;
                }
            }
            this._model.force_full_redraw = false;
            this._model.changed = [];
            /**
             * triggered after nodes are redrawn
             * @event
             * @name redraw.jstree
             * @param {array} nodes the redrawn nodes
             */
            this.trigger('redraw', { "nodes": nodes });
        },
        /**
         * redraws all nodes that need to be redrawn or optionally - the whole tree
         * @name redraw([full])
         * @param {Boolean} full if set to `true` all nodes are redrawn.
         */
        redraw: function (full) {
            if (full) {
                this._model.force_full_redraw = true;
            }
            //if(this._model.redraw_timeout) {
            //	clearTimeout(this._model.redraw_timeout);
            //}
            //this._model.redraw_timeout = setTimeout($.proxy(this._redraw, this),0);
            this._redraw();
        },
        /**
         * redraws a single node's children. Used internally.
         * @private
         * @name draw_children(node)
         * @param {mixed} node the node whose children will be redrawn
         */
        draw_children: function (node) {
            var obj = this.get_node(node),
                i = false,
                j = false,
                k = false,
                d = document;
            if (!obj) { return false; }
            if (obj.id === $.jstree.root) { return this.redraw(true); }
            node = this.get_node(node, true);
            if (!node || !node.length) { return false; } // TODO: quick toggle

            node.children('.jstree-children').remove();
            node = node[0];
            if (obj.children.length && obj.state.loaded) {
                k = d.createElement('UL');
                k.setAttribute('role', 'group');
                k.className = 'jstree-children';
                for (i = 0, j = obj.children.length; i < j; i++) {
                    k.appendChild(this.redraw_node(obj.children[i], true, true));
                }
                node.appendChild(k);
            }
        },
        /**
         * redraws a single node. Used internally.
         * @private
         * @name redraw_node(node, deep, is_callback, force_render)
         * @param {mixed} node the node to redraw
         * @param {Boolean} deep should child nodes be redrawn too
         * @param {Boolean} is_callback is this a recursion call
         * @param {Boolean} force_render should children of closed parents be drawn anyway
         */
        redraw_node: function (node, deep, is_callback, force_render) {
            var obj = this.get_node(node),
                par = false,
                ind = false,
                old = false,
                i = false,
                j = false,
                k = false,
                c = '',
                d = document,
                m = this._model.data,
                f = false,
                s = false,
                tmp = null,
                t = 0,
                l = 0,
                has_children = false,
                last_sibling = false;
            if (!obj) { return false; }
            if (obj.id === $.jstree.root) { return this.redraw(true); }
            deep = deep || obj.children.length === 0;
            node = !document.querySelector ? document.getElementById(obj.id) : this.element[0].querySelector('#' + ("0123456789".indexOf(obj.id[0]) !== -1 ? '\\3' + obj.id[0] + ' ' + obj.id.substr(1).replace($.jstree.idregex, '\\$&') : obj.id.replace($.jstree.idregex, '\\$&'))); //, this.element);
            if (!node) {
                deep = true;
                //node = d.createElement('LI');
                if (!is_callback) {
                    par = obj.parent !== $.jstree.root ? $('#' + obj.parent.replace($.jstree.idregex, '\\$&'), this.element)[0] : null;
                    if (par !== null && (!par || !m[obj.parent].state.opened)) {
                        return false;
                    }
                    ind = $.inArray(obj.id, par === null ? m[$.jstree.root].children : m[obj.parent].children);
                }
            }
            else {
                node = $(node);
                if (!is_callback) {
                    par = node.parent().parent()[0];
                    if (par === this.element[0]) {
                        par = null;
                    }
                    ind = node.index();
                }
                // m[obj.id].data = node.data(); // use only node's data, no need to touch jquery storage
                if (!deep && obj.children.length && !node.children('.jstree-children').length) {
                    deep = true;
                }
                if (!deep) {
                    old = node.children('.jstree-children')[0];
                }
                f = node.children('.jstree-anchor')[0] === document.activeElement;
                node.remove();
                //node = d.createElement('LI');
                //node = node[0];
            }
            node = this._data.core.node.cloneNode(true);
            // node is DOM, deep is boolean

            c = 'jstree-node ';
            for (i in obj.li_attr) {
                if (obj.li_attr.hasOwnProperty(i)) {
                    if (i === 'id') { continue; }
                    if (i !== 'class') {
                        node.setAttribute(i, obj.li_attr[i]);
                    }
                    else {
                        c += obj.li_attr[i];
                    }
                }
            }
            if (!obj.a_attr.id) {
                obj.a_attr.id = obj.id + '_anchor';
            }
            node.setAttribute('aria-selected', !!obj.state.selected);
            node.setAttribute('aria-level', obj.parents.length);
            node.setAttribute('aria-labelledby', obj.a_attr.id);
            if (obj.state.disabled) {
                node.setAttribute('aria-disabled', true);
            }

            for (i = 0, j = obj.children.length; i < j; i++) {
                if (!m[obj.children[i]].state.hidden) {
                    has_children = true;
                    break;
                }
            }
            if (obj.parent !== null && m[obj.parent] && !obj.state.hidden) {
                i = $.inArray(obj.id, m[obj.parent].children);
                last_sibling = obj.id;
                if (i !== -1) {
                    i++;
                    for (j = m[obj.parent].children.length; i < j; i++) {
                        if (!m[m[obj.parent].children[i]].state.hidden) {
                            last_sibling = m[obj.parent].children[i];
                        }
                        if (last_sibling !== obj.id) {
                            break;
                        }
                    }
                }
            }

            if (obj.state.hidden) {
                c += ' jstree-hidden';
            }
            if (obj.state.loaded && !has_children) {
                c += ' jstree-leaf';
            }
            else {
                c += obj.state.opened && obj.state.loaded ? ' jstree-open' : ' jstree-closed';
                node.setAttribute('aria-expanded', (obj.state.opened && obj.state.loaded));
            }
            if (last_sibling === obj.id) {
                c += ' jstree-last';
            }
            node.id = obj.id;
            node.className = c;
            c = (obj.state.selected ? ' jstree-clicked' : '') + (obj.state.disabled ? ' jstree-disabled' : '');
            for (j in obj.a_attr) {
                if (obj.a_attr.hasOwnProperty(j)) {
                    if (j === 'href' && obj.a_attr[j] === '#') { continue; }
                    if (j !== 'class') {
                        node.childNodes[1].setAttribute(j, obj.a_attr[j]);
                    }
                    else {
                        c += ' ' + obj.a_attr[j];
                    }
                }
            }
            if (c.length) {
                node.childNodes[1].className = 'jstree-anchor ' + c;
            }
            if ((obj.icon && obj.icon !== true) || obj.icon === false) {
                if (obj.icon === false) {
                    node.childNodes[1].childNodes[0].className += ' jstree-themeicon-hidden';
                }
                else if (obj.icon.indexOf('/') === -1 && obj.icon.indexOf('.') === -1) {
                    node.childNodes[1].childNodes[0].className += ' ' + obj.icon + ' jstree-themeicon-custom';
                }
                else {
                    node.childNodes[1].childNodes[0].style.backgroundImage = 'url("' + obj.icon + '")';
                    node.childNodes[1].childNodes[0].style.backgroundPosition = 'center center';
                    node.childNodes[1].childNodes[0].style.backgroundSize = 'auto';
                    node.childNodes[1].childNodes[0].className += ' jstree-themeicon-custom';
                }
            }

            if (this.settings.core.force_text) {
                node.childNodes[1].appendChild(d.createTextNode(obj.text));
            }
            else {
                node.childNodes[1].innerHTML += obj.text;
            }


            if (deep && obj.children.length && (obj.state.opened || force_render) && obj.state.loaded) {
                k = d.createElement('UL');
                k.setAttribute('role', 'group');
                k.className = 'jstree-children';
                for (i = 0, j = obj.children.length; i < j; i++) {
                    k.appendChild(this.redraw_node(obj.children[i], deep, true));
                }
                node.appendChild(k);
            }
            if (old) {
                node.appendChild(old);
            }
            if (!is_callback) {
                // append back using par / ind
                if (!par) {
                    par = this.element[0];
                }
                for (i = 0, j = par.childNodes.length; i < j; i++) {
                    if (par.childNodes[i] && par.childNodes[i].className && par.childNodes[i].className.indexOf('jstree-children') !== -1) {
                        tmp = par.childNodes[i];
                        break;
                    }
                }
                if (!tmp) {
                    tmp = d.createElement('UL');
                    tmp.setAttribute('role', 'group');
                    tmp.className = 'jstree-children';
                    par.appendChild(tmp);
                }
                par = tmp;

                if (ind < par.childNodes.length) {
                    par.insertBefore(node, par.childNodes[ind]);
                }
                else {
                    par.appendChild(node);
                }
                if (f) {
                    t = this.element[0].scrollTop;
                    l = this.element[0].scrollLeft;
                    node.childNodes[1].focus();
                    this.element[0].scrollTop = t;
                    this.element[0].scrollLeft = l;
                }
            }
            if (obj.state.opened && !obj.state.loaded) {
                obj.state.opened = false;
                setTimeout($.proxy(function () {
                    this.open_node(obj.id, false, 0);
                }, this), 0);
            }
            return node;
        },
        /**
         * opens a node, revaling its children. If the node is not loaded it will be loaded and opened once ready.
         * @name open_node(obj [, callback, animation])
         * @param {mixed} obj the node to open
         * @param {Function} callback a function to execute once the node is opened
         * @param {Number} animation the animation duration in milliseconds when opening the node (overrides the `core.animation` setting). Use `false` for no animation.
         * @trigger open_node.jstree, after_open.jstree, before_open.jstree
         */
        open_node: function (obj, callback, animation) {
            var t1, t2, d, t;
            if ($.isArray(obj)) {
                obj = obj.slice();
                for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {
                    this.open_node(obj[t1], callback, animation);
                }
                return true;
            }
            obj = this.get_node(obj);
            if (!obj || obj.id === $.jstree.root) {
                return false;
            }
            animation = animation === undefined ? this.settings.core.animation : animation;
            if (!this.is_closed(obj)) {
                if (callback) {
                    callback.call(this, obj, false);
                }
                return false;
            }
            if (!this.is_loaded(obj)) {
                if (this.is_loading(obj)) {
                    return setTimeout($.proxy(function () {
                        this.open_node(obj, callback, animation);
                    }, this), 500);
                }
                this.load_node(obj, function (o, ok) {
                    return ok ? this.open_node(o, callback, animation) : (callback ? callback.call(this, o, false) : false);
                });
            }
            else {
                d = this.get_node(obj, true);
                t = this;
                if (d.length) {
                    if (animation && d.children(".jstree-children").length) {
                        d.children(".jstree-children").stop(true, true);
                    }
                    if (obj.children.length && !this._firstChild(d.children('.jstree-children')[0])) {
                        this.draw_children(obj);
                        //d = this.get_node(obj, true);
                    }
                    if (!animation) {
                        this.trigger('before_open', { "node": obj });
                        d[0].className = d[0].className.replace('jstree-closed', 'jstree-open');
                        d[0].setAttribute("aria-expanded", true);
                    }
                    else {
                        this.trigger('before_open', { "node": obj });
                        d
                            .children(".jstree-children").css("display", "none").end()
                            .removeClass("jstree-closed").addClass("jstree-open").attr("aria-expanded", true)
                            .children(".jstree-children").stop(true, true)
                                .slideDown(animation, function () {
                                    this.style.display = "";
                                    if (t.element) {
                                        t.trigger("after_open", { "node": obj });
                                    }
                                });
                    }
                }
                obj.state.opened = true;
                if (callback) {
                    callback.call(this, obj, true);
                }
                if (!d.length) {
                    /**
                     * triggered when a node is about to be opened (if the node is supposed to be in the DOM, it will be, but it won't be visible yet)
                     * @event
                     * @name before_open.jstree
                     * @param {Object} node the opened node
                     */
                    this.trigger('before_open', { "node": obj });
                }
                /**
                 * triggered when a node is opened (if there is an animation it will not be completed yet)
                 * @event
                 * @name open_node.jstree
                 * @param {Object} node the opened node
                 */
                this.trigger('open_node', { "node": obj });
                if (!animation || !d.length) {
                    /**
                     * triggered when a node is opened and the animation is complete
                     * @event
                     * @name after_open.jstree
                     * @param {Object} node the opened node
                     */
                    this.trigger("after_open", { "node": obj });
                }
                return true;
            }
        },
        /**
         * opens every parent of a node (node should be loaded)
         * @name _open_to(obj)
         * @param {mixed} obj the node to reveal
         * @private
         */
        _open_to: function (obj) {
            obj = this.get_node(obj);
            if (!obj || obj.id === $.jstree.root) {
                return false;
            }
            var i, j, p = obj.parents;
            for (i = 0, j = p.length; i < j; i += 1) {
                if (i !== $.jstree.root) {
                    this.open_node(p[i], false, 0);
                }
            }
            return $('#' + obj.id.replace($.jstree.idregex, '\\$&'), this.element);
        },
        /**
         * closes a node, hiding its children
         * @name close_node(obj [, animation])
         * @param {mixed} obj the node to close
         * @param {Number} animation the animation duration in milliseconds when closing the node (overrides the `core.animation` setting). Use `false` for no animation.
         * @trigger close_node.jstree, after_close.jstree
         */
        close_node: function (obj, animation) {
            var t1, t2, t, d;
            if ($.isArray(obj)) {
                obj = obj.slice();
                for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {
                    this.close_node(obj[t1], animation);
                }
                return true;
            }
            obj = this.get_node(obj);
            if (!obj || obj.id === $.jstree.root) {
                return false;
            }
            if (this.is_closed(obj)) {
                return false;
            }
            animation = animation === undefined ? this.settings.core.animation : animation;
            t = this;
            d = this.get_node(obj, true);

            obj.state.opened = false;
            /**
             * triggered when a node is closed (if there is an animation it will not be complete yet)
             * @event
             * @name close_node.jstree
             * @param {Object} node the closed node
             */
            this.trigger('close_node', { "node": obj });
            if (!d.length) {
                /**
                 * triggered when a node is closed and the animation is complete
                 * @event
                 * @name after_close.jstree
                 * @param {Object} node the closed node
                 */
                this.trigger("after_close", { "node": obj });
            }
            else {
                if (!animation) {
                    d[0].className = d[0].className.replace('jstree-open', 'jstree-closed');
                    d.attr("aria-expanded", false).children('.jstree-children').remove();
                    this.trigger("after_close", { "node": obj });
                }
                else {
                    d
                        .children(".jstree-children").attr("style", "display:block !important").end()
                        .removeClass("jstree-open").addClass("jstree-closed").attr("aria-expanded", false)
                        .children(".jstree-children").stop(true, true).slideUp(animation, function () {
                            this.style.display = "";
                            d.children('.jstree-children').remove();
                            if (t.element) {
                                t.trigger("after_close", { "node": obj });
                            }
                        });
                }
            }
        },
        /**
         * toggles a node - closing it if it is open, opening it if it is closed
         * @name toggle_node(obj)
         * @param {mixed} obj the node to toggle
         */
        toggle_node: function (obj) {
            var t1, t2;
            if ($.isArray(obj)) {
                obj = obj.slice();
                for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {
                    this.toggle_node(obj[t1]);
                }
                return true;
            }
            if (this.is_closed(obj)) {
                return this.open_node(obj);
            }
            if (this.is_open(obj)) {
                return this.close_node(obj);
            }
        },
        /**
         * opens all nodes within a node (or the tree), revaling their children. If the node is not loaded it will be loaded and opened once ready.
         * @name open_all([obj, animation, original_obj])
         * @param {mixed} obj the node to open recursively, omit to open all nodes in the tree
         * @param {Number} animation the animation duration in milliseconds when opening the nodes, the default is no animation
         * @param {jQuery} reference to the node that started the process (internal use)
         * @trigger open_all.jstree
         */
        open_all: function (obj, animation, original_obj) {
            if (!obj) { obj = $.jstree.root; }
            obj = this.get_node(obj);
            if (!obj) { return false; }
            var dom = obj.id === $.jstree.root ? this.get_container_ul() : this.get_node(obj, true), i, j, _this;
            if (!dom.length) {
                for (i = 0, j = obj.children_d.length; i < j; i++) {
                    if (this.is_closed(this._model.data[obj.children_d[i]])) {
                        this._model.data[obj.children_d[i]].state.opened = true;
                    }
                }
                return this.trigger('open_all', { "node": obj });
            }
            original_obj = original_obj || dom;
            _this = this;
            dom = this.is_closed(obj) ? dom.find('.jstree-closed').addBack() : dom.find('.jstree-closed');
            dom.each(function () {
                _this.open_node(
                    this,
                    function (node, status) { if (status && this.is_parent(node)) { this.open_all(node, animation, original_obj); } },
                    animation || 0
                );
            });
            if (original_obj.find('.jstree-closed').length === 0) {
                /**
                 * triggered when an `open_all` call completes
                 * @event
                 * @name open_all.jstree
                 * @param {Object} node the opened node
                 */
                this.trigger('open_all', { "node": this.get_node(original_obj) });
            }
        },
        /**
         * closes all nodes within a node (or the tree), revaling their children
         * @name close_all([obj, animation])
         * @param {mixed} obj the node to close recursively, omit to close all nodes in the tree
         * @param {Number} animation the animation duration in milliseconds when closing the nodes, the default is no animation
         * @trigger close_all.jstree
         */
        close_all: function (obj, animation) {
            if (!obj) { obj = $.jstree.root; }
            obj = this.get_node(obj);
            if (!obj) { return false; }
            var dom = obj.id === $.jstree.root ? this.get_container_ul() : this.get_node(obj, true),
                _this = this, i, j;
            if (dom.length) {
                dom = this.is_open(obj) ? dom.find('.jstree-open').addBack() : dom.find('.jstree-open');
                $(dom.get().reverse()).each(function () { _this.close_node(this, animation || 0); });
            }
            for (i = 0, j = obj.children_d.length; i < j; i++) {
                this._model.data[obj.children_d[i]].state.opened = false;
            }
            /**
             * triggered when an `close_all` call completes
             * @event
             * @name close_all.jstree
             * @param {Object} node the closed node
             */
            this.trigger('close_all', { "node": obj });
        },
        /**
         * checks if a node is disabled (not selectable)
         * @name is_disabled(obj)
         * @param  {mixed} obj
         * @return {Boolean}
         */
        is_disabled: function (obj) {
            obj = this.get_node(obj);
            return obj && obj.state && obj.state.disabled;
        },
        /**
         * enables a node - so that it can be selected
         * @name enable_node(obj)
         * @param {mixed} obj the node to enable
         * @trigger enable_node.jstree
         */
        enable_node: function (obj) {
            var t1, t2;
            if ($.isArray(obj)) {
                obj = obj.slice();
                for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {
                    this.enable_node(obj[t1]);
                }
                return true;
            }
            obj = this.get_node(obj);
            if (!obj || obj.id === $.jstree.root) {
                return false;
            }
            obj.state.disabled = false;
            this.get_node(obj, true).children('.jstree-anchor').removeClass('jstree-disabled').attr('aria-disabled', false);
            /**
             * triggered when an node is enabled
             * @event
             * @name enable_node.jstree
             * @param {Object} node the enabled node
             */
            this.trigger('enable_node', { 'node': obj });
        },
        /**
         * disables a node - so that it can not be selected
         * @name disable_node(obj)
         * @param {mixed} obj the node to disable
         * @trigger disable_node.jstree
         */
        disable_node: function (obj) {
            var t1, t2;
            if ($.isArray(obj)) {
                obj = obj.slice();
                for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {
                    this.disable_node(obj[t1]);
                }
                return true;
            }
            obj = this.get_node(obj);
            if (!obj || obj.id === $.jstree.root) {
                return false;
            }
            obj.state.disabled = true;
            this.get_node(obj, true).children('.jstree-anchor').addClass('jstree-disabled').attr('aria-disabled', true);
            /**
             * triggered when an node is disabled
             * @event
             * @name disable_node.jstree
             * @param {Object} node the disabled node
             */
            this.trigger('disable_node', { 'node': obj });
        },
        /**
         * determines if a node is hidden
         * @name is_hidden(obj)
         * @param {mixed} obj the node
         */
        is_hidden: function (obj) {
            obj = this.get_node(obj);
            return obj.state.hidden === true;
        },
        /**
         * hides a node - it is still in the structure but will not be visible
         * @name hide_node(obj)
         * @param {mixed} obj the node to hide
         * @param {Boolean} skip_redraw internal parameter controlling if redraw is called
         * @trigger hide_node.jstree
         */
        hide_node: function (obj, skip_redraw) {
            var t1, t2;
            if ($.isArray(obj)) {
                obj = obj.slice();
                for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {
                    this.hide_node(obj[t1], true);
                }
                if (!skip_redraw) {
                    this.redraw();
                }
                return true;
            }
            obj = this.get_node(obj);
            if (!obj || obj.id === $.jstree.root) {
                return false;
            }
            if (!obj.state.hidden) {
                obj.state.hidden = true;
                this._node_changed(obj.parent);
                if (!skip_redraw) {
                    this.redraw();
                }
                /**
                 * triggered when an node is hidden
                 * @event
                 * @name hide_node.jstree
                 * @param {Object} node the hidden node
                 */
                this.trigger('hide_node', { 'node': obj });
            }
        },
        /**
         * shows a node
         * @name show_node(obj)
         * @param {mixed} obj the node to show
         * @param {Boolean} skip_redraw internal parameter controlling if redraw is called
         * @trigger show_node.jstree
         */
        show_node: function (obj, skip_redraw) {
            var t1, t2;
            if ($.isArray(obj)) {
                obj = obj.slice();
                for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {
                    this.show_node(obj[t1], true);
                }
                if (!skip_redraw) {
                    this.redraw();
                }
                return true;
            }
            obj = this.get_node(obj);
            if (!obj || obj.id === $.jstree.root) {
                return false;
            }
            if (obj.state.hidden) {
                obj.state.hidden = false;
                this._node_changed(obj.parent);
                if (!skip_redraw) {
                    this.redraw();
                }
                /**
                 * triggered when an node is shown
                 * @event
                 * @name show_node.jstree
                 * @param {Object} node the shown node
                 */
                this.trigger('show_node', { 'node': obj });
            }
        },
        /**
         * hides all nodes
         * @name hide_all()
         * @trigger hide_all.jstree
         */
        hide_all: function (skip_redraw) {
            var i, m = this._model.data, ids = [];
            for (i in m) {
                if (m.hasOwnProperty(i) && i !== $.jstree.root && !m[i].state.hidden) {
                    m[i].state.hidden = true;
                    ids.push(i);
                }
            }
            this._model.force_full_redraw = true;
            if (!skip_redraw) {
                this.redraw();
            }
            /**
             * triggered when all nodes are hidden
             * @event
             * @name hide_all.jstree
             * @param {Array} nodes the IDs of all hidden nodes
             */
            this.trigger('hide_all', { 'nodes': ids });
            return ids;
        },
        /**
         * shows all nodes
         * @name show_all()
         * @trigger show_all.jstree
         */
        show_all: function (skip_redraw) {
            var i, m = this._model.data, ids = [];
            for (i in m) {
                if (m.hasOwnProperty(i) && i !== $.jstree.root && m[i].state.hidden) {
                    m[i].state.hidden = false;
                    ids.push(i);
                }
            }
            this._model.force_full_redraw = true;
            if (!skip_redraw) {
                this.redraw();
            }
            /**
             * triggered when all nodes are shown
             * @event
             * @name show_all.jstree
             * @param {Array} nodes the IDs of all shown nodes
             */
            this.trigger('show_all', { 'nodes': ids });
            return ids;
        },
        /**
         * called when a node is selected by the user. Used internally.
         * @private
         * @name activate_node(obj, e)
         * @param {mixed} obj the node
         * @param {Object} e the related event
         * @trigger activate_node.jstree, changed.jstree
         */
        activate_node: function (obj, e) {
            if (this.is_disabled(obj)) {
                return false;
            }
            if (!e || typeof e !== 'object') {
                e = {};
            }

            // ensure last_clicked is still in the DOM, make it fresh (maybe it was moved?) and make sure it is still selected, if not - make last_clicked the last selected node
            this._data.core.last_clicked = this._data.core.last_clicked && this._data.core.last_clicked.id !== undefined ? this.get_node(this._data.core.last_clicked.id) : null;
            if (this._data.core.last_clicked && !this._data.core.last_clicked.state.selected) { this._data.core.last_clicked = null; }
            if (!this._data.core.last_clicked && this._data.core.selected.length) { this._data.core.last_clicked = this.get_node(this._data.core.selected[this._data.core.selected.length - 1]); }

            if (!this.settings.core.multiple || (!e.metaKey && !e.ctrlKey && !e.shiftKey) || (e.shiftKey && (!this._data.core.last_clicked || !this.get_parent(obj) || this.get_parent(obj) !== this._data.core.last_clicked.parent))) {
                if (!this.settings.core.multiple && (e.metaKey || e.ctrlKey || e.shiftKey) && this.is_selected(obj)) {
                    this.deselect_node(obj, false, e);
                }
                else {
                    this.deselect_all(true);
                    this.select_node(obj, false, false, e);
                    this._data.core.last_clicked = this.get_node(obj);
                }
            }
            else {
                if (e.shiftKey) {
                    var o = this.get_node(obj).id,
                        l = this._data.core.last_clicked.id,
                        p = this.get_node(this._data.core.last_clicked.parent).children,
                        c = false,
                        i, j;
                    for (i = 0, j = p.length; i < j; i += 1) {
                        // separate IFs work whem o and l are the same
                        if (p[i] === o) {
                            c = !c;
                        }
                        if (p[i] === l) {
                            c = !c;
                        }
                        if (!this.is_disabled(p[i]) && (c || p[i] === o || p[i] === l)) {
                            if (!this.is_hidden(p[i])) {
                                this.select_node(p[i], true, false, e);
                            }
                        }
                        else {
                            this.deselect_node(p[i], true, e);
                        }
                    }
                    this.trigger('changed', { 'action': 'select_node', 'node': this.get_node(obj), 'selected': this._data.core.selected, 'event': e });
                }
                else {
                    if (!this.is_selected(obj)) {
                        this.select_node(obj, false, false, e);
                    }
                    else {
                        this.deselect_node(obj, false, e);
                    }
                }
            }
            /**
             * triggered when an node is clicked or intercated with by the user
             * @event
             * @name activate_node.jstree
             * @param {Object} node
             * @param {Object} event the ooriginal event (if any) which triggered the call (may be an empty object)
             */
            this.trigger('activate_node', { 'node': this.get_node(obj), 'event': e });
        },
        /**
         * applies the hover state on a node, called when a node is hovered by the user. Used internally.
         * @private
         * @name hover_node(obj)
         * @param {mixed} obj
         * @trigger hover_node.jstree
         */
        hover_node: function (obj) {
            obj = this.get_node(obj, true);
            if (!obj || !obj.length || obj.children('.jstree-hovered').length) {
                return false;
            }
            var o = this.element.find('.jstree-hovered'), t = this.element;
            if (o && o.length) { this.dehover_node(o); }

            obj.children('.jstree-anchor').addClass('jstree-hovered');
            /**
             * triggered when an node is hovered
             * @event
             * @name hover_node.jstree
             * @param {Object} node
             */
            this.trigger('hover_node', { 'node': this.get_node(obj) });
            setTimeout(function () { t.attr('aria-activedescendant', obj[0].id); }, 0);
        },
        /**
         * removes the hover state from a nodecalled when a node is no longer hovered by the user. Used internally.
         * @private
         * @name dehover_node(obj)
         * @param {mixed} obj
         * @trigger dehover_node.jstree
         */
        dehover_node: function (obj) {
            obj = this.get_node(obj, true);
            if (!obj || !obj.length || !obj.children('.jstree-hovered').length) {
                return false;
            }
            obj.children('.jstree-anchor').removeClass('jstree-hovered');
            /**
             * triggered when an node is no longer hovered
             * @event
             * @name dehover_node.jstree
             * @param {Object} node
             */
            this.trigger('dehover_node', { 'node': this.get_node(obj) });
        },
        /**
         * select a node
         * @name select_node(obj [, supress_event, prevent_open])
         * @param {mixed} obj an array can be used to select multiple nodes
         * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered
         * @param {Boolean} prevent_open if set to `true` parents of the selected node won't be opened
         * @trigger select_node.jstree, changed.jstree
         */
        select_node: function (obj, supress_event, prevent_open, e) {
            var dom, t1, t2, th;
            if ($.isArray(obj)) {
                obj = obj.slice();
                for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {
                    this.select_node(obj[t1], supress_event, prevent_open, e);
                }
                return true;
            }
            obj = this.get_node(obj);
            if (!obj || obj.id === $.jstree.root) {
                return false;
            }
            dom = this.get_node(obj, true);
            if (!obj.state.selected) {
                obj.state.selected = true;
                this._data.core.selected.push(obj.id);
                if (!prevent_open) {
                    dom = this._open_to(obj);
                }
                if (dom && dom.length) {
                    dom.attr('aria-selected', true).children('.jstree-anchor').addClass('jstree-clicked');
                }
                /**
                 * triggered when an node is selected
                 * @event
                 * @name select_node.jstree
                 * @param {Object} node
                 * @param {Array} selected the current selection
                 * @param {Object} event the event (if any) that triggered this select_node
                 */
                this.trigger('select_node', { 'node': obj, 'selected': this._data.core.selected, 'event': e });
                if (!supress_event) {
                    /**
                     * triggered when selection changes
                     * @event
                     * @name changed.jstree
                     * @param {Object} node
                     * @param {Object} action the action that caused the selection to change
                     * @param {Array} selected the current selection
                     * @param {Object} event the event (if any) that triggered this changed event
                     */
                    this.trigger('changed', { 'action': 'select_node', 'node': obj, 'selected': this._data.core.selected, 'event': e });
                }
            }
        },
        /**
         * deselect a node
         * @name deselect_node(obj [, supress_event])
         * @param {mixed} obj an array can be used to deselect multiple nodes
         * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered
         * @trigger deselect_node.jstree, changed.jstree
         */
        deselect_node: function (obj, supress_event, e) {
            var t1, t2, dom;
            if ($.isArray(obj)) {
                obj = obj.slice();
                for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {
                    this.deselect_node(obj[t1], supress_event, e);
                }
                return true;
            }
            obj = this.get_node(obj);
            if (!obj || obj.id === $.jstree.root) {
                return false;
            }
            dom = this.get_node(obj, true);
            if (obj.state.selected) {
                obj.state.selected = false;
                this._data.core.selected = $.vakata.array_remove_item(this._data.core.selected, obj.id);
                if (dom.length) {
                    dom.attr('aria-selected', false).children('.jstree-anchor').removeClass('jstree-clicked');
                }
                /**
                 * triggered when an node is deselected
                 * @event
                 * @name deselect_node.jstree
                 * @param {Object} node
                 * @param {Array} selected the current selection
                 * @param {Object} event the event (if any) that triggered this deselect_node
                 */
                this.trigger('deselect_node', { 'node': obj, 'selected': this._data.core.selected, 'event': e });
                if (!supress_event) {
                    this.trigger('changed', { 'action': 'deselect_node', 'node': obj, 'selected': this._data.core.selected, 'event': e });
                }
            }
        },
        /**
         * select all nodes in the tree
         * @name select_all([supress_event])
         * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered
         * @trigger select_all.jstree, changed.jstree
         */
        select_all: function (supress_event) {
            var tmp = this._data.core.selected.concat([]), i, j;
            this._data.core.selected = this._model.data[$.jstree.root].children_d.concat();
            for (i = 0, j = this._data.core.selected.length; i < j; i++) {
                if (this._model.data[this._data.core.selected[i]]) {
                    this._model.data[this._data.core.selected[i]].state.selected = true;
                }
            }
            this.redraw(true);
            /**
             * triggered when all nodes are selected
             * @event
             * @name select_all.jstree
             * @param {Array} selected the current selection
             */
            this.trigger('select_all', { 'selected': this._data.core.selected });
            if (!supress_event) {
                this.trigger('changed', { 'action': 'select_all', 'selected': this._data.core.selected, 'old_selection': tmp });
            }
        },
        /**
         * deselect all selected nodes
         * @name deselect_all([supress_event])
         * @param {Boolean} supress_event if set to `true` the `changed.jstree` event won't be triggered
         * @trigger deselect_all.jstree, changed.jstree
         */
        deselect_all: function (supress_event) {
            var tmp = this._data.core.selected.concat([]), i, j;
            for (i = 0, j = this._data.core.selected.length; i < j; i++) {
                if (this._model.data[this._data.core.selected[i]]) {
                    this._model.data[this._data.core.selected[i]].state.selected = false;
                }
            }
            this._data.core.selected = [];
            this.element.find('.jstree-clicked').removeClass('jstree-clicked').parent().attr('aria-selected', false);
            /**
             * triggered when all nodes are deselected
             * @event
             * @name deselect_all.jstree
             * @param {Object} node the previous selection
             * @param {Array} selected the current selection
             */
            this.trigger('deselect_all', { 'selected': this._data.core.selected, 'node': tmp });
            if (!supress_event) {
                this.trigger('changed', { 'action': 'deselect_all', 'selected': this._data.core.selected, 'old_selection': tmp });
            }
        },
        /**
         * checks if a node is selected
         * @name is_selected(obj)
         * @param  {mixed}  obj
         * @return {Boolean}
         */
        is_selected: function (obj) {
            obj = this.get_node(obj);
            if (!obj || obj.id === $.jstree.root) {
                return false;
            }
            return obj.state.selected;
        },
        /**
         * get an array of all selected nodes
         * @name get_selected([full])
         * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
         * @return {Array}
         */
        get_selected: function (full) {
            return full ? $.map(this._data.core.selected, $.proxy(function (i) { return this.get_node(i); }, this)) : this._data.core.selected.slice();
        },
        /**
         * get an array of all top level selected nodes (ignoring children of selected nodes)
         * @name get_top_selected([full])
         * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
         * @return {Array}
         */
        get_top_selected: function (full) {
            var tmp = this.get_selected(true),
                obj = {}, i, j, k, l;
            for (i = 0, j = tmp.length; i < j; i++) {
                obj[tmp[i].id] = tmp[i];
            }
            for (i = 0, j = tmp.length; i < j; i++) {
                for (k = 0, l = tmp[i].children_d.length; k < l; k++) {
                    if (obj[tmp[i].children_d[k]]) {
                        delete obj[tmp[i].children_d[k]];
                    }
                }
            }
            tmp = [];
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    tmp.push(i);
                }
            }
            return full ? $.map(tmp, $.proxy(function (i) { return this.get_node(i); }, this)) : tmp;
        },
        /**
         * get an array of all bottom level selected nodes (ignoring selected parents)
         * @name get_bottom_selected([full])
         * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
         * @return {Array}
         */
        get_bottom_selected: function (full) {
            var tmp = this.get_selected(true),
                obj = [], i, j;
            for (i = 0, j = tmp.length; i < j; i++) {
                if (!tmp[i].children.length) {
                    obj.push(tmp[i].id);
                }
            }
            return full ? $.map(obj, $.proxy(function (i) { return this.get_node(i); }, this)) : obj;
        },
        /**
         * gets the current state of the tree so that it can be restored later with `set_state(state)`. Used internally.
         * @name get_state()
         * @private
         * @return {Object}
         */
        get_state: function () {
            var state = {
                'core': {
                    'open': [],
                    'scroll': {
                        'left': this.element.scrollLeft(),
                        'top': this.element.scrollTop()
                    },
                    /*!
                    'themes' : {
                        'name' : this.get_theme(),
                        'icons' : this._data.core.themes.icons,
                        'dots' : this._data.core.themes.dots
                    },
                    */
                    'selected': []
                }
            }, i;
            for (i in this._model.data) {
                if (this._model.data.hasOwnProperty(i)) {
                    if (i !== $.jstree.root) {
                        if (this._model.data[i].state.opened) {
                            state.core.open.push(i);
                        }
                        if (this._model.data[i].state.selected) {
                            state.core.selected.push(i);
                        }
                    }
                }
            }
            return state;
        },
        /**
         * sets the state of the tree. Used internally.
         * @name set_state(state [, callback])
         * @private
         * @param {Object} state the state to restore. Keep in mind this object is passed by reference and jstree will modify it.
         * @param {Function} callback an optional function to execute once the state is restored.
         * @trigger set_state.jstree
         */
        set_state: function (state, callback) {
            if (state) {
                if (state.core) {
                    var res, n, t, _this, i;
                    if (state.core.open) {
                        if (!$.isArray(state.core.open) || !state.core.open.length) {
                            delete state.core.open;
                            this.set_state(state, callback);
                        }
                        else {
                            this._load_nodes(state.core.open, function (nodes) {
                                this.open_node(nodes, false, 0);
                                delete state.core.open;
                                this.set_state(state, callback);
                            });
                        }
                        return false;
                    }
                    if (state.core.scroll) {
                        if (state.core.scroll && state.core.scroll.left !== undefined) {
                            this.element.scrollLeft(state.core.scroll.left);
                        }
                        if (state.core.scroll && state.core.scroll.top !== undefined) {
                            this.element.scrollTop(state.core.scroll.top);
                        }
                        delete state.core.scroll;
                        this.set_state(state, callback);
                        return false;
                    }
                    if (state.core.selected) {
                        _this = this;
                        this.deselect_all();
                        $.each(state.core.selected, function (i, v) {
                            _this.select_node(v, false, true);
                        });
                        delete state.core.selected;
                        this.set_state(state, callback);
                        return false;
                    }
                    for (i in state) {
                        if (state.hasOwnProperty(i) && i !== "core" && $.inArray(i, this.settings.plugins) === -1) {
                            delete state[i];
                        }
                    }
                    if ($.isEmptyObject(state.core)) {
                        delete state.core;
                        this.set_state(state, callback);
                        return false;
                    }
                }
                if ($.isEmptyObject(state)) {
                    state = null;
                    if (callback) { callback.call(this); }
                    /**
                     * triggered when a `set_state` call completes
                     * @event
                     * @name set_state.jstree
                     */
                    this.trigger('set_state');
                    return false;
                }
                return true;
            }
            return false;
        },
        /**
         * refreshes the tree - all nodes are reloaded with calls to `load_node`.
         * @name refresh()
         * @param {Boolean} skip_loading an option to skip showing the loading indicator
         * @param {Mixed} forget_state if set to `true` state will not be reapplied, if set to a function (receiving the current state as argument) the result of that function will be used as state
         * @trigger refresh.jstree
         */
        refresh: function (skip_loading, forget_state) {
            this._data.core.state = forget_state === true ? {} : this.get_state();
            if (forget_state && $.isFunction(forget_state)) { this._data.core.state = forget_state.call(this, this._data.core.state); }
            this._cnt = 0;
            this._model.data = {};
            this._model.data[$.jstree.root] = {
                id: $.jstree.root,
                parent: null,
                parents: [],
                children: [],
                children_d: [],
                state: { loaded: false }
            };
            this._data.core.selected = [];
            this._data.core.last_clicked = null;
            this._data.core.focused = null;

            var c = this.get_container_ul()[0].className;
            if (!skip_loading) {
                this.element.html("<" + "ul class='" + c + "' role='group'><" + "li class='jstree-initial-node jstree-loading jstree-leaf jstree-last' role='treeitem' id='j" + this._id + "_loading'><i class='jstree-icon jstree-ocl'></i><" + "a class='jstree-anchor' href='#'><i class='jstree-icon jstree-themeicon-hidden'></i>" + this.get_string("Loading ...") + "</a></li></ul>");
                this.element.attr('aria-activedescendant', 'j' + this._id + '_loading');
            }
            this.load_node($.jstree.root, function (o, s) {
                if (s) {
                    this.get_container_ul()[0].className = c;
                    if (this._firstChild(this.get_container_ul()[0])) {
                        this.element.attr('aria-activedescendant', this._firstChild(this.get_container_ul()[0]).id);
                    }
                    this.set_state($.extend(true, {}, this._data.core.state), function () {
                        /**
                         * triggered when a `refresh` call completes
                         * @event
                         * @name refresh.jstree
                         */
                        this.trigger('refresh');
                    });
                }
                this._data.core.state = null;
            });
        },
        /**
         * refreshes a node in the tree (reload its children) all opened nodes inside that node are reloaded with calls to `load_node`.
         * @name refresh_node(obj)
         * @param  {mixed} obj the node
         * @trigger refresh_node.jstree
         */
        refresh_node: function (obj) {
            obj = this.get_node(obj);
            if (!obj || obj.id === $.jstree.root) { return false; }
            var opened = [], to_load = [], s = this._data.core.selected.concat([]);
            to_load.push(obj.id);
            if (obj.state.opened === true) { opened.push(obj.id); }
            this.get_node(obj, true).find('.jstree-open').each(function () { to_load.push(this.id); opened.push(this.id); });
            this._load_nodes(to_load, $.proxy(function (nodes) {
                this.open_node(opened, false, 0);
                this.select_node(s);
                /**
                 * triggered when a node is refreshed
                 * @event
                 * @name refresh_node.jstree
                 * @param {Object} node - the refreshed node
                 * @param {Array} nodes - an array of the IDs of the nodes that were reloaded
                 */
                this.trigger('refresh_node', { 'node': obj, 'nodes': nodes });
            }, this), false, true);
        },
        /**
         * set (change) the ID of a node
         * @name set_id(obj, id)
         * @param  {mixed} obj the node
         * @param  {String} id the new ID
         * @return {Boolean}
         * @trigger set_id.jstree
         */
        set_id: function (obj, id) {
            obj = this.get_node(obj);
            if (!obj || obj.id === $.jstree.root) { return false; }
            var i, j, m = this._model.data, old = obj.id;
            id = id.toString();
            // update parents (replace current ID with new one in children and children_d)
            m[obj.parent].children[$.inArray(obj.id, m[obj.parent].children)] = id;
            for (i = 0, j = obj.parents.length; i < j; i++) {
                m[obj.parents[i]].children_d[$.inArray(obj.id, m[obj.parents[i]].children_d)] = id;
            }
            // update children (replace current ID with new one in parent and parents)
            for (i = 0, j = obj.children.length; i < j; i++) {
                m[obj.children[i]].parent = id;
            }
            for (i = 0, j = obj.children_d.length; i < j; i++) {
                m[obj.children_d[i]].parents[$.inArray(obj.id, m[obj.children_d[i]].parents)] = id;
            }
            i = $.inArray(obj.id, this._data.core.selected);
            if (i !== -1) { this._data.core.selected[i] = id; }
            // update model and obj itself (obj.id, this._model.data[KEY])
            i = this.get_node(obj.id, true);
            if (i) {
                i.attr('id', id); //.children('.jstree-anchor').attr('id', id + '_anchor').end().attr('aria-labelledby', id + '_anchor');
                if (this.element.attr('aria-activedescendant') === obj.id) {
                    this.element.attr('aria-activedescendant', id);
                }
            }
            delete m[obj.id];
            obj.id = id;
            obj.li_attr.id = id;
            m[id] = obj;
            /**
             * triggered when a node id value is changed
             * @event
             * @name set_id.jstree
             * @param {Object} node
             * @param {String} old the old id
             */
            this.trigger('set_id', { "node": obj, "new": obj.id, "old": old });
            return true;
        },
        /**
         * get the text value of a node
         * @name get_text(obj)
         * @param  {mixed} obj the node
         * @return {String}
         */
        get_text: function (obj) {
            obj = this.get_node(obj);
            return (!obj || obj.id === $.jstree.root) ? false : obj.text;
        },
        /**
         * set the text value of a node. Used internally, please use `rename_node(obj, val)`.
         * @private
         * @name set_text(obj, val)
         * @param  {mixed} obj the node, you can pass an array to set the text on multiple nodes
         * @param  {String} val the new text value
         * @return {Boolean}
         * @trigger set_text.jstree
         */
        set_text: function (obj, val) {
            var t1, t2;
            if ($.isArray(obj)) {
                obj = obj.slice();
                for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {
                    this.set_text(obj[t1], val);
                }
                return true;
            }
            obj = this.get_node(obj);
            if (!obj || obj.id === $.jstree.root) { return false; }
            obj.text = val;
            if (this.get_node(obj, true).length) {
                this.redraw_node(obj.id);
            }
            /**
             * triggered when a node text value is changed
             * @event
             * @name set_text.jstree
             * @param {Object} obj
             * @param {String} text the new value
             */
            this.trigger('set_text', { "obj": obj, "text": val });
            return true;
        },
        /**
         * gets a JSON representation of a node (or the whole tree)
         * @name get_json([obj, options])
         * @param  {mixed} obj
         * @param  {Object} options
         * @param  {Boolean} options.no_state do not return state information
         * @param  {Boolean} options.no_id do not return ID
         * @param  {Boolean} options.no_children do not include children
         * @param  {Boolean} options.no_data do not include node data
         * @param  {Boolean} options.no_li_attr do not include LI attributes
         * @param  {Boolean} options.no_a_attr do not include A attributes
         * @param  {Boolean} options.flat return flat JSON instead of nested
         * @return {Object}
         */
        get_json: function (obj, options, flat) {
            obj = this.get_node(obj || $.jstree.root);
            if (!obj) { return false; }
            if (options && options.flat && !flat) { flat = []; }
            var tmp = {
                'id': obj.id,
                'text': obj.text,
                'icon': this.get_icon(obj),
                'li_attr': $.extend(true, {}, obj.li_attr),
                'a_attr': $.extend(true, {}, obj.a_attr),
                'state': {},
                'data': options && options.no_data ? false : $.extend(true, {}, obj.data)
                //( this.get_node(obj, true).length ? this.get_node(obj, true).data() : obj.data ),
            }, i, j;
            if (options && options.flat) {
                tmp.parent = obj.parent;
            }
            else {
                tmp.children = [];
            }
            if (!options || !options.no_state) {
                for (i in obj.state) {
                    if (obj.state.hasOwnProperty(i)) {
                        tmp.state[i] = obj.state[i];
                    }
                }
            } else {
                delete tmp.state;
            }
            if (options && options.no_li_attr) {
                delete tmp.li_attr;
            }
            if (options && options.no_a_attr) {
                delete tmp.a_attr;
            }
            if (options && options.no_id) {
                delete tmp.id;
                if (tmp.li_attr && tmp.li_attr.id) {
                    delete tmp.li_attr.id;
                }
                if (tmp.a_attr && tmp.a_attr.id) {
                    delete tmp.a_attr.id;
                }
            }
            if (options && options.flat && obj.id !== $.jstree.root) {
                flat.push(tmp);
            }
            if (!options || !options.no_children) {
                for (i = 0, j = obj.children.length; i < j; i++) {
                    if (options && options.flat) {
                        this.get_json(obj.children[i], options, flat);
                    }
                    else {
                        tmp.children.push(this.get_json(obj.children[i], options));
                    }
                }
            }
            return options && options.flat ? flat : (obj.id === $.jstree.root ? tmp.children : tmp);
        },
        /**
         * create a new node (do not confuse with load_node)
         * @name create_node([par, node, pos, callback, is_loaded])
         * @param  {mixed}   par       the parent node (to create a root node use either "#" (string) or `null`)
         * @param  {mixed}   node      the data for the new node (a valid JSON object, or a simple string with the name)
         * @param  {mixed}   pos       the index at which to insert the node, "first" and "last" are also supported, default is "last"
         * @param  {Function} callback a function to be called once the node is created
         * @param  {Boolean} is_loaded internal argument indicating if the parent node was succesfully loaded
         * @return {String}            the ID of the newly create node
         * @trigger model.jstree, create_node.jstree
         */
        create_node: function (par, node, pos, callback, is_loaded) {
            if (par === null) { par = $.jstree.root; }
            par = this.get_node(par);
            if (!par) { return false; }
            pos = pos === undefined ? "last" : pos;
            if (!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
                return this.load_node(par, function () { this.create_node(par, node, pos, callback, true); });
            }
            if (!node) { node = { "text": this.get_string('New node') }; }
            if (typeof node === "string") { node = { "text": node }; }
            if (node.text === undefined) { node.text = this.get_string('New node'); }
            var tmp, dpc, i, j;

            if (par.id === $.jstree.root) {
                if (pos === "before") { pos = "first"; }
                if (pos === "after") { pos = "last"; }
            }
            switch (pos) {
                case "before":
                    tmp = this.get_node(par.parent);
                    pos = $.inArray(par.id, tmp.children);
                    par = tmp;
                    break;
                case "after":
                    tmp = this.get_node(par.parent);
                    pos = $.inArray(par.id, tmp.children) + 1;
                    par = tmp;
                    break;
                case "inside":
                case "first":
                    pos = 0;
                    break;
                case "last":
                    pos = par.children.length;
                    break;
                default:
                    if (!pos) { pos = 0; }
                    break;
            }
            if (pos > par.children.length) { pos = par.children.length; }
            if (!node.id) { node.id = true; }
            if (!this.check("create_node", node, par, pos)) {
                this.settings.core.error.call(this, this._data.core.last_error);
                return false;
            }
            if (node.id === true) { delete node.id; }
            node = this._parse_model_from_json(node, par.id, par.parents.concat());
            if (!node) { return false; }
            tmp = this.get_node(node);
            dpc = [];
            dpc.push(node);
            dpc = dpc.concat(tmp.children_d);
            this.trigger('model', { "nodes": dpc, "parent": par.id });

            par.children_d = par.children_d.concat(dpc);
            for (i = 0, j = par.parents.length; i < j; i++) {
                this._model.data[par.parents[i]].children_d = this._model.data[par.parents[i]].children_d.concat(dpc);
            }
            node = tmp;
            tmp = [];
            for (i = 0, j = par.children.length; i < j; i++) {
                tmp[i >= pos ? i + 1 : i] = par.children[i];
            }
            tmp[pos] = node.id;
            par.children = tmp;

            this.redraw_node(par, true);
            if (callback) { callback.call(this, this.get_node(node)); }
            /**
             * triggered when a node is created
             * @event
             * @name create_node.jstree
             * @param {Object} node
             * @param {String} parent the parent's ID
             * @param {Number} position the position of the new node among the parent's children
             */
            this.trigger('create_node', { "node": this.get_node(node), "parent": par.id, "position": pos });
            return node.id;
        },
        /**
         * set the text value of a node
         * @name rename_node(obj, val)
         * @param  {mixed} obj the node, you can pass an array to rename multiple nodes to the same name
         * @param  {String} val the new text value
         * @return {Boolean}
         * @trigger rename_node.jstree
         */
        rename_node: function (obj, val) {
            var t1, t2, old;
            if ($.isArray(obj)) {
                obj = obj.slice();
                for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {
                    this.rename_node(obj[t1], val);
                }
                return true;
            }
            obj = this.get_node(obj);
            if (!obj || obj.id === $.jstree.root) { return false; }
            old = obj.text;
            if (!this.check("rename_node", obj, this.get_parent(obj), val)) {
                this.settings.core.error.call(this, this._data.core.last_error);
                return false;
            }
            this.set_text(obj, val); // .apply(this, Array.prototype.slice.call(arguments))
            /**
             * triggered when a node is renamed
             * @event
             * @name rename_node.jstree
             * @param {Object} node
             * @param {String} text the new value
             * @param {String} old the old value
             */
            this.trigger('rename_node', { "node": obj, "text": val, "old": old });
            return true;
        },
        /**
         * remove a node
         * @name delete_node(obj)
         * @param  {mixed} obj the node, you can pass an array to delete multiple nodes
         * @return {Boolean}
         * @trigger delete_node.jstree, changed.jstree
         */
        delete_node: function (obj) {
            var t1, t2, par, pos, tmp, i, j, k, l, c, top, lft;
            if ($.isArray(obj)) {
                obj = obj.slice();
                for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {
                    this.delete_node(obj[t1]);
                }
                return true;
            }
            obj = this.get_node(obj);
            if (!obj || obj.id === $.jstree.root) { return false; }
            par = this.get_node(obj.parent);
            pos = $.inArray(obj.id, par.children);
            c = false;
            if (!this.check("delete_node", obj, par, pos)) {
                this.settings.core.error.call(this, this._data.core.last_error);
                return false;
            }
            if (pos !== -1) {
                par.children = $.vakata.array_remove(par.children, pos);
            }
            tmp = obj.children_d.concat([]);
            tmp.push(obj.id);
            for (i = 0, j = obj.parents.length; i < j; i++) {
                this._model.data[obj.parents[i]].children_d = $.vakata.array_filter(this._model.data[obj.parents[i]].children_d, function (v) {
                    return $.inArray(v, tmp) === -1;
                });
            }
            for (k = 0, l = tmp.length; k < l; k++) {
                if (this._model.data[tmp[k]].state.selected) {
                    c = true;
                    break;
                }
            }
            if (c) {
                this._data.core.selected = $.vakata.array_filter(this._data.core.selected, function (v) {
                    return $.inArray(v, tmp) === -1;
                });
            }
            /**
             * triggered when a node is deleted
             * @event
             * @name delete_node.jstree
             * @param {Object} node
             * @param {String} parent the parent's ID
             */
            this.trigger('delete_node', { "node": obj, "parent": par.id });
            if (c) {
                this.trigger('changed', { 'action': 'delete_node', 'node': obj, 'selected': this._data.core.selected, 'parent': par.id });
            }
            for (k = 0, l = tmp.length; k < l; k++) {
                delete this._model.data[tmp[k]];
            }
            if ($.inArray(this._data.core.focused, tmp) !== -1) {
                this._data.core.focused = null;
                top = this.element[0].scrollTop;
                lft = this.element[0].scrollLeft;
                if (par.id === $.jstree.root) {
                    if (this._model.data[$.jstree.root].children[0]) {
                        this.get_node(this._model.data[$.jstree.root].children[0], true).children('.jstree-anchor').focus();
                    }
                }
                else {
                    this.get_node(par, true).children('.jstree-anchor').focus();
                }
                this.element[0].scrollTop = top;
                this.element[0].scrollLeft = lft;
            }
            this.redraw_node(par, true);
            return true;
        },
        /**
         * check if an operation is premitted on the tree. Used internally.
         * @private
         * @name check(chk, obj, par, pos)
         * @param  {String} chk the operation to check, can be "create_node", "rename_node", "delete_node", "copy_node" or "move_node"
         * @param  {mixed} obj the node
         * @param  {mixed} par the parent
         * @param  {mixed} pos the position to insert at, or if "rename_node" - the new name
         * @param  {mixed} more some various additional information, for example if a "move_node" operations is triggered by DND this will be the hovered node
         * @return {Boolean}
         */
        check: function (chk, obj, par, pos, more) {
            obj = obj && obj.id ? obj : this.get_node(obj);
            par = par && par.id ? par : this.get_node(par);
            var tmp = chk.match(/^move_node|copy_node|create_node$/i) ? par : obj,
                chc = this.settings.core.check_callback;
            if (chk === "move_node" || chk === "copy_node") {
                if ((!more || !more.is_multi) && (obj.id === par.id || (chk === "move_node" && $.inArray(obj.id, par.children) === pos) || $.inArray(par.id, obj.children_d) !== -1)) {
                    this._data.core.last_error = { 'error': 'check', 'plugin': 'core', 'id': 'core_01', 'reason': 'Moving parent inside child', 'data': JSON.stringify({ 'chk': chk, 'pos': pos, 'obj': obj && obj.id ? obj.id : false, 'par': par && par.id ? par.id : false }) };
                    return false;
                }
            }
            if (tmp && tmp.data) { tmp = tmp.data; }
            if (tmp && tmp.functions && (tmp.functions[chk] === false || tmp.functions[chk] === true)) {
                if (tmp.functions[chk] === false) {
                    this._data.core.last_error = { 'error': 'check', 'plugin': 'core', 'id': 'core_02', 'reason': 'Node data prevents function: ' + chk, 'data': JSON.stringify({ 'chk': chk, 'pos': pos, 'obj': obj && obj.id ? obj.id : false, 'par': par && par.id ? par.id : false }) };
                }
                return tmp.functions[chk];
            }
            if (chc === false || ($.isFunction(chc) && chc.call(this, chk, obj, par, pos, more) === false) || (chc && chc[chk] === false)) {
                this._data.core.last_error = { 'error': 'check', 'plugin': 'core', 'id': 'core_03', 'reason': 'User config for core.check_callback prevents function: ' + chk, 'data': JSON.stringify({ 'chk': chk, 'pos': pos, 'obj': obj && obj.id ? obj.id : false, 'par': par && par.id ? par.id : false }) };
                return false;
            }
            return true;
        },
        /**
         * get the last error
         * @name last_error()
         * @return {Object}
         */
        last_error: function () {
            return this._data.core.last_error;
        },
        /**
         * move a node to a new parent
         * @name move_node(obj, par [, pos, callback, is_loaded])
         * @param  {mixed} obj the node to move, pass an array to move multiple nodes
         * @param  {mixed} par the new parent
         * @param  {mixed} pos the position to insert at (besides integer values, "first" and "last" are supported, as well as "before" and "after"), defaults to integer `0`
         * @param  {function} callback a function to call once the move is completed, receives 3 arguments - the node, the new parent and the position
         * @param  {Boolean} is_loaded internal parameter indicating if the parent node has been loaded
         * @param  {Boolean} skip_redraw internal parameter indicating if the tree should be redrawn
         * @param  {Boolean} instance internal parameter indicating if the node comes from another instance
         * @trigger move_node.jstree
         */
        move_node: function (obj, par, pos, callback, is_loaded, skip_redraw, origin) {
            var t1, t2, old_par, old_pos, new_par, old_ins, is_multi, dpc, tmp, i, j, k, l, p;

            par = this.get_node(par);
            pos = pos === undefined ? 0 : pos;
            if (!par) { return false; }
            if (!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
                return this.load_node(par, function () { this.move_node(obj, par, pos, callback, true, false, origin); });
            }

            if ($.isArray(obj)) {
                if (obj.length === 1) {
                    obj = obj[0];
                }
                else {
                    //obj = obj.slice();
                    for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {
                        if ((tmp = this.move_node(obj[t1], par, pos, callback, is_loaded, false, origin))) {
                            par = tmp;
                            pos = "after";
                        }
                    }
                    this.redraw();
                    return true;
                }
            }
            obj = obj && obj.id ? obj : this.get_node(obj);

            if (!obj || obj.id === $.jstree.root) { return false; }

            old_par = (obj.parent || $.jstree.root).toString();
            new_par = (!pos.toString().match(/^(before|after)$/) || par.id === $.jstree.root) ? par : this.get_node(par.parent);
            old_ins = origin ? origin : (this._model.data[obj.id] ? this : $.jstree.reference(obj.id));
            is_multi = !old_ins || !old_ins._id || (this._id !== old_ins._id);
            old_pos = old_ins && old_ins._id && old_par && old_ins._model.data[old_par] && old_ins._model.data[old_par].children ? $.inArray(obj.id, old_ins._model.data[old_par].children) : -1;
            if (old_ins && old_ins._id) {
                obj = old_ins._model.data[obj.id];
            }

            if (is_multi) {
                if ((tmp = this.copy_node(obj, par, pos, callback, is_loaded, false, origin))) {
                    if (old_ins) { old_ins.delete_node(obj); }
                    return tmp;
                }
                return false;
            }
            //var m = this._model.data;
            if (par.id === $.jstree.root) {
                if (pos === "before") { pos = "first"; }
                if (pos === "after") { pos = "last"; }
            }
            switch (pos) {
                case "before":
                    pos = $.inArray(par.id, new_par.children);
                    break;
                case "after":
                    pos = $.inArray(par.id, new_par.children) + 1;
                    break;
                case "inside":
                case "first":
                    pos = 0;
                    break;
                case "last":
                    pos = new_par.children.length;
                    break;
                default:
                    if (!pos) { pos = 0; }
                    break;
            }
            if (pos > new_par.children.length) { pos = new_par.children.length; }
            if (!this.check("move_node", obj, new_par, pos, { 'core': true, 'origin': origin, 'is_multi': (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign': (!old_ins || !old_ins._id) })) {
                this.settings.core.error.call(this, this._data.core.last_error);
                return false;
            }
            if (obj.parent === new_par.id) {
                dpc = new_par.children.concat();
                tmp = $.inArray(obj.id, dpc);
                if (tmp !== -1) {
                    dpc = $.vakata.array_remove(dpc, tmp);
                    if (pos > tmp) { pos--; }
                }
                tmp = [];
                for (i = 0, j = dpc.length; i < j; i++) {
                    tmp[i >= pos ? i + 1 : i] = dpc[i];
                }
                tmp[pos] = obj.id;
                new_par.children = tmp;
                this._node_changed(new_par.id);
                this.redraw(new_par.id === $.jstree.root);
            }
            else {
                // clean old parent and up
                tmp = obj.children_d.concat();
                tmp.push(obj.id);
                for (i = 0, j = obj.parents.length; i < j; i++) {
                    dpc = [];
                    p = old_ins._model.data[obj.parents[i]].children_d;
                    for (k = 0, l = p.length; k < l; k++) {
                        if ($.inArray(p[k], tmp) === -1) {
                            dpc.push(p[k]);
                        }
                    }
                    old_ins._model.data[obj.parents[i]].children_d = dpc;
                }
                old_ins._model.data[old_par].children = $.vakata.array_remove_item(old_ins._model.data[old_par].children, obj.id);

                // insert into new parent and up
                for (i = 0, j = new_par.parents.length; i < j; i++) {
                    this._model.data[new_par.parents[i]].children_d = this._model.data[new_par.parents[i]].children_d.concat(tmp);
                }
                dpc = [];
                for (i = 0, j = new_par.children.length; i < j; i++) {
                    dpc[i >= pos ? i + 1 : i] = new_par.children[i];
                }
                dpc[pos] = obj.id;
                new_par.children = dpc;
                new_par.children_d.push(obj.id);
                new_par.children_d = new_par.children_d.concat(obj.children_d);

                // update object
                obj.parent = new_par.id;
                tmp = new_par.parents.concat();
                tmp.unshift(new_par.id);
                p = obj.parents.length;
                obj.parents = tmp;

                // update object children
                tmp = tmp.concat();
                for (i = 0, j = obj.children_d.length; i < j; i++) {
                    this._model.data[obj.children_d[i]].parents = this._model.data[obj.children_d[i]].parents.slice(0, p * -1);
                    Array.prototype.push.apply(this._model.data[obj.children_d[i]].parents, tmp);
                }

                if (old_par === $.jstree.root || new_par.id === $.jstree.root) {
                    this._model.force_full_redraw = true;
                }
                if (!this._model.force_full_redraw) {
                    this._node_changed(old_par);
                    this._node_changed(new_par.id);
                }
                if (!skip_redraw) {
                    this.redraw();
                }
            }
            if (callback) { callback.call(this, obj, new_par, pos); }
            /**
             * triggered when a node is moved
             * @event
             * @name move_node.jstree
             * @param {Object} node
             * @param {String} parent the parent's ID
             * @param {Number} position the position of the node among the parent's children
             * @param {String} old_parent the old parent of the node
             * @param {Number} old_position the old position of the node
             * @param {Boolean} is_multi do the node and new parent belong to different instances
             * @param {jsTree} old_instance the instance the node came from
             * @param {jsTree} new_instance the instance of the new parent
             */
            this.trigger('move_node', { "node": obj, "parent": new_par.id, "position": pos, "old_parent": old_par, "old_position": old_pos, 'is_multi': (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign': (!old_ins || !old_ins._id), 'old_instance': old_ins, 'new_instance': this });
            return obj.id;
        },
        /**
         * copy a node to a new parent
         * @name copy_node(obj, par [, pos, callback, is_loaded])
         * @param  {mixed} obj the node to copy, pass an array to copy multiple nodes
         * @param  {mixed} par the new parent
         * @param  {mixed} pos the position to insert at (besides integer values, "first" and "last" are supported, as well as "before" and "after"), defaults to integer `0`
         * @param  {function} callback a function to call once the move is completed, receives 3 arguments - the node, the new parent and the position
         * @param  {Boolean} is_loaded internal parameter indicating if the parent node has been loaded
         * @param  {Boolean} skip_redraw internal parameter indicating if the tree should be redrawn
         * @param  {Boolean} instance internal parameter indicating if the node comes from another instance
         * @trigger model.jstree copy_node.jstree
         */
        copy_node: function (obj, par, pos, callback, is_loaded, skip_redraw, origin) {
            var t1, t2, dpc, tmp, i, j, node, old_par, new_par, old_ins, is_multi;

            par = this.get_node(par);
            pos = pos === undefined ? 0 : pos;
            if (!par) { return false; }
            if (!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
                return this.load_node(par, function () { this.copy_node(obj, par, pos, callback, true, false, origin); });
            }

            if ($.isArray(obj)) {
                if (obj.length === 1) {
                    obj = obj[0];
                }
                else {
                    //obj = obj.slice();
                    for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {
                        if ((tmp = this.copy_node(obj[t1], par, pos, callback, is_loaded, true, origin))) {
                            par = tmp;
                            pos = "after";
                        }
                    }
                    this.redraw();
                    return true;
                }
            }
            obj = obj && obj.id ? obj : this.get_node(obj);
            if (!obj || obj.id === $.jstree.root) { return false; }

            old_par = (obj.parent || $.jstree.root).toString();
            new_par = (!pos.toString().match(/^(before|after)$/) || par.id === $.jstree.root) ? par : this.get_node(par.parent);
            old_ins = origin ? origin : (this._model.data[obj.id] ? this : $.jstree.reference(obj.id));
            is_multi = !old_ins || !old_ins._id || (this._id !== old_ins._id);

            if (old_ins && old_ins._id) {
                obj = old_ins._model.data[obj.id];
            }

            if (par.id === $.jstree.root) {
                if (pos === "before") { pos = "first"; }
                if (pos === "after") { pos = "last"; }
            }
            switch (pos) {
                case "before":
                    pos = $.inArray(par.id, new_par.children);
                    break;
                case "after":
                    pos = $.inArray(par.id, new_par.children) + 1;
                    break;
                case "inside":
                case "first":
                    pos = 0;
                    break;
                case "last":
                    pos = new_par.children.length;
                    break;
                default:
                    if (!pos) { pos = 0; }
                    break;
            }
            if (pos > new_par.children.length) { pos = new_par.children.length; }
            if (!this.check("copy_node", obj, new_par, pos, { 'core': true, 'origin': origin, 'is_multi': (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign': (!old_ins || !old_ins._id) })) {
                this.settings.core.error.call(this, this._data.core.last_error);
                return false;
            }
            node = old_ins ? old_ins.get_json(obj, { no_id: true, no_data: true, no_state: true }) : obj;
            if (!node) { return false; }
            if (node.id === true) { delete node.id; }
            node = this._parse_model_from_json(node, new_par.id, new_par.parents.concat());
            if (!node) { return false; }
            tmp = this.get_node(node);
            if (obj && obj.state && obj.state.loaded === false) { tmp.state.loaded = false; }
            dpc = [];
            dpc.push(node);
            dpc = dpc.concat(tmp.children_d);
            this.trigger('model', { "nodes": dpc, "parent": new_par.id });

            // insert into new parent and up
            for (i = 0, j = new_par.parents.length; i < j; i++) {
                this._model.data[new_par.parents[i]].children_d = this._model.data[new_par.parents[i]].children_d.concat(dpc);
            }
            dpc = [];
            for (i = 0, j = new_par.children.length; i < j; i++) {
                dpc[i >= pos ? i + 1 : i] = new_par.children[i];
            }
            dpc[pos] = tmp.id;
            new_par.children = dpc;
            new_par.children_d.push(tmp.id);
            new_par.children_d = new_par.children_d.concat(tmp.children_d);

            if (new_par.id === $.jstree.root) {
                this._model.force_full_redraw = true;
            }
            if (!this._model.force_full_redraw) {
                this._node_changed(new_par.id);
            }
            if (!skip_redraw) {
                this.redraw(new_par.id === $.jstree.root);
            }
            if (callback) { callback.call(this, tmp, new_par, pos); }
            /**
             * triggered when a node is copied
             * @event
             * @name copy_node.jstree
             * @param {Object} node the copied node
             * @param {Object} original the original node
             * @param {String} parent the parent's ID
             * @param {Number} position the position of the node among the parent's children
             * @param {String} old_parent the old parent of the node
             * @param {Number} old_position the position of the original node
             * @param {Boolean} is_multi do the node and new parent belong to different instances
             * @param {jsTree} old_instance the instance the node came from
             * @param {jsTree} new_instance the instance of the new parent
             */
            this.trigger('copy_node', { "node": tmp, "original": obj, "parent": new_par.id, "position": pos, "old_parent": old_par, "old_position": old_ins && old_ins._id && old_par && old_ins._model.data[old_par] && old_ins._model.data[old_par].children ? $.inArray(obj.id, old_ins._model.data[old_par].children) : -1, 'is_multi': (old_ins && old_ins._id && old_ins._id !== this._id), 'is_foreign': (!old_ins || !old_ins._id), 'old_instance': old_ins, 'new_instance': this });
            return tmp.id;
        },
        /**
         * cut a node (a later call to `paste(obj)` would move the node)
         * @name cut(obj)
         * @param  {mixed} obj multiple objects can be passed using an array
         * @trigger cut.jstree
         */
        cut: function (obj) {
            if (!obj) { obj = this._data.core.selected.concat(); }
            if (!$.isArray(obj)) { obj = [obj]; }
            if (!obj.length) { return false; }
            var tmp = [], o, t1, t2;
            for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {
                o = this.get_node(obj[t1]);
                if (o && o.id && o.id !== $.jstree.root) { tmp.push(o); }
            }
            if (!tmp.length) { return false; }
            ccp_node = tmp;
            ccp_inst = this;
            ccp_mode = 'move_node';
            /**
             * triggered when nodes are added to the buffer for moving
             * @event
             * @name cut.jstree
             * @param {Array} node
             */
            this.trigger('cut', { "node": obj });
        },
        /**
         * copy a node (a later call to `paste(obj)` would copy the node)
         * @name copy(obj)
         * @param  {mixed} obj multiple objects can be passed using an array
         * @trigger copy.jstree
         */
        copy: function (obj) {
            if (!obj) { obj = this._data.core.selected.concat(); }
            if (!$.isArray(obj)) { obj = [obj]; }
            if (!obj.length) { return false; }
            var tmp = [], o, t1, t2;
            for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {
                o = this.get_node(obj[t1]);
                if (o && o.id && o.id !== $.jstree.root) { tmp.push(o); }
            }
            if (!tmp.length) { return false; }
            ccp_node = tmp;
            ccp_inst = this;
            ccp_mode = 'copy_node';
            /**
             * triggered when nodes are added to the buffer for copying
             * @event
             * @name copy.jstree
             * @param {Array} node
             */
            this.trigger('copy', { "node": obj });
        },
        /**
         * get the current buffer (any nodes that are waiting for a paste operation)
         * @name get_buffer()
         * @return {Object} an object consisting of `mode` ("copy_node" or "move_node"), `node` (an array of objects) and `inst` (the instance)
         */
        get_buffer: function () {
            return { 'mode': ccp_mode, 'node': ccp_node, 'inst': ccp_inst };
        },
        /**
         * check if there is something in the buffer to paste
         * @name can_paste()
         * @return {Boolean}
         */
        can_paste: function () {
            return ccp_mode !== false && ccp_node !== false; // && ccp_inst._model.data[ccp_node];
        },
        /**
         * copy or move the previously cut or copied nodes to a new parent
         * @name paste(obj [, pos])
         * @param  {mixed} obj the new parent
         * @param  {mixed} pos the position to insert at (besides integer, "first" and "last" are supported), defaults to integer `0`
         * @trigger paste.jstree
         */
        paste: function (obj, pos) {
            obj = this.get_node(obj);
            if (!obj || !ccp_mode || !ccp_mode.match(/^(copy_node|move_node)$/) || !ccp_node) { return false; }
            if (this[ccp_mode](ccp_node, obj, pos, false, false, false, ccp_inst)) {
                /**
                 * triggered when paste is invoked
                 * @event
                 * @name paste.jstree
                 * @param {String} parent the ID of the receiving node
                 * @param {Array} node the nodes in the buffer
                 * @param {String} mode the performed operation - "copy_node" or "move_node"
                 */
                this.trigger('paste', { "parent": obj.id, "node": ccp_node, "mode": ccp_mode });
            }
            ccp_node = false;
            ccp_mode = false;
            ccp_inst = false;
        },
        /**
         * clear the buffer of previously copied or cut nodes
         * @name clear_buffer()
         * @trigger clear_buffer.jstree
         */
        clear_buffer: function () {
            ccp_node = false;
            ccp_mode = false;
            ccp_inst = false;
            /**
             * triggered when the copy / cut buffer is cleared
             * @event
             * @name clear_buffer.jstree
             */
            this.trigger('clear_buffer');
        },
        /**
         * put a node in edit mode (input field to rename the node)
         * @name edit(obj [, default_text, callback])
         * @param  {mixed} obj
         * @param  {String} default_text the text to populate the input with (if omitted or set to a non-string value the node's text value is used)
         * @param  {Function} callback a function to be called once the text box is blurred, it is called in the instance's scope and receives the node, a status parameter (true if the rename is successful, false otherwise) and a boolean indicating if the user cancelled the edit. You can access the node's title using .text
         */
        edit: function (obj, default_text, callback) {
            var rtl, w, a, s, t, h1, h2, fn, tmp, cancel = false;
            obj = this.get_node(obj);
            if (!obj) { return false; }
            if (this.settings.core.check_callback === false) {
                this._data.core.last_error = { 'error': 'check', 'plugin': 'core', 'id': 'core_07', 'reason': 'Could not edit node because of check_callback' };
                this.settings.core.error.call(this, this._data.core.last_error);
                return false;
            }
            tmp = obj;
            default_text = typeof default_text === 'string' ? default_text : obj.text;
            this.set_text(obj, "");
            obj = this._open_to(obj);
            tmp.text = default_text;

            rtl = this._data.core.rtl;
            w = this.element.width();
            this._data.core.focused = tmp.id;
            a = obj.children('.jstree-anchor').focus();
            s = $('<span>');
            /*!
            oi = obj.children("i:visible"),
            ai = a.children("i:visible"),
            w1 = oi.width() * oi.length,
            w2 = ai.width() * ai.length,
            */
            t = default_text;
            h1 = $("<" + "div />", { css: { "position": "absolute", "top": "-200px", "left": (rtl ? "0px" : "-1000px"), "visibility": "hidden" } }).appendTo("body");
            h2 = $("<" + "input />", {
                "value": t,
                "class": "jstree-rename-input",
                // "size" : t.length,
                "css": {
                    "padding": "0",
                    "border": "1px solid silver",
                    "box-sizing": "border-box",
                    "display": "inline-block",
                    "height": (this._data.core.li_height) + "px",
                    "lineHeight": (this._data.core.li_height) + "px",
                    "width": "150px" // will be set a bit further down
                },
                "blur": $.proxy(function (e) {
                    e.stopImmediatePropagation();
                    e.preventDefault();
                    var i = s.children(".jstree-rename-input"),
                        v = i.val(),
                        f = this.settings.core.force_text,
                        nv;
                    if (v === "") { v = t; }
                    h1.remove();
                    s.replaceWith(a);
                    s.remove();
                    t = f ? t : $('<div></div>').append($.parseHTML(t)).html();
                    this.set_text(obj, t);
                    nv = !!this.rename_node(obj, f ? $('<div></div>').text(v).text() : $('<div></div>').append($.parseHTML(v)).html());
                    if (!nv) {
                        this.set_text(obj, t); // move this up? and fix #483
                    }
                    this._data.core.focused = tmp.id;
                    setTimeout($.proxy(function () {
                        var node = this.get_node(tmp.id, true);
                        if (node.length) {
                            this._data.core.focused = tmp.id;
                            node.children('.jstree-anchor').focus();
                        }
                    }, this), 0);
                    if (callback) {
                        callback.call(this, tmp, nv, cancel);
                    }
                    h2 = null;
                }, this),
                "keydown": function (e) {
                    var key = e.which;
                    if (key === 27) {
                        cancel = true;
                        this.value = t;
                    }
                    if (key === 27 || key === 13 || key === 37 || key === 38 || key === 39 || key === 40 || key === 32) {
                        e.stopImmediatePropagation();
                    }
                    if (key === 27 || key === 13) {
                        e.preventDefault();
                        this.blur();
                    }
                },
                "click": function (e) { e.stopImmediatePropagation(); },
                "mousedown": function (e) { e.stopImmediatePropagation(); },
                "keyup": function (e) {
                    h2.width(Math.min(h1.text("pW" + this.value).width(), w));
                },
                "keypress": function (e) {
                    if (e.which === 13) { return false; }
                }
            });
            fn = {
                fontFamily: a.css('fontFamily') || '',
                fontSize: a.css('fontSize') || '',
                fontWeight: a.css('fontWeight') || '',
                fontStyle: a.css('fontStyle') || '',
                fontStretch: a.css('fontStretch') || '',
                fontVariant: a.css('fontVariant') || '',
                letterSpacing: a.css('letterSpacing') || '',
                wordSpacing: a.css('wordSpacing') || ''
            };
            s.attr('class', a.attr('class')).append(a.contents().clone()).append(h2);
            a.replaceWith(s);
            h1.css(fn);
            h2.css(fn).width(Math.min(h1.text("pW" + h2[0].value).width(), w))[0].select();
            $(document).one('mousedown.jstree touchstart.jstree dnd_start.vakata', function (e) {
                if (h2 && e.target !== h2) {
                    $(h2).blur();
                }
            });
        },


        /**
         * changes the theme
         * @name set_theme(theme_name [, theme_url])
         * @param {String} theme_name the name of the new theme to apply
         * @param {mixed} theme_url  the location of the CSS file for this theme. Omit or set to `false` if you manually included the file. Set to `true` to autoload from the `core.themes.dir` directory.
         * @trigger set_theme.jstree
         */
        set_theme: function (theme_name, theme_url) {
            if (!theme_name) { return false; }
            if (theme_url === true) {
                var dir = this.settings.core.themes.dir;
                if (!dir) { dir = $.jstree.path + '/themes'; }
                theme_url = dir + '/' + theme_name + '/style.css';
            }
            if (theme_url && $.inArray(theme_url, themes_loaded) === -1) {
                $('head').append('<' + 'link rel="stylesheet" href="' + theme_url + '" type="text/css" />');
                themes_loaded.push(theme_url);
            }
            if (this._data.core.themes.name) {
                this.element.removeClass('jstree-' + this._data.core.themes.name);
            }
            this._data.core.themes.name = theme_name;
            this.element.addClass('jstree-' + theme_name);
            this.element[this.settings.core.themes.responsive ? 'addClass' : 'removeClass']('jstree-' + theme_name + '-responsive');
            /**
             * triggered when a theme is set
             * @event
             * @name set_theme.jstree
             * @param {String} theme the new theme
             */
            this.trigger('set_theme', { 'theme': theme_name });
        },
        /**
         * gets the name of the currently applied theme name
         * @name get_theme()
         * @return {String}
         */
        get_theme: function () { return this._data.core.themes.name; },
        /**
         * changes the theme variant (if the theme has variants)
         * @name set_theme_variant(variant_name)
         * @param {String|Boolean} variant_name the variant to apply (if `false` is used the current variant is removed)
         */
        set_theme_variant: function (variant_name) {
            if (this._data.core.themes.variant) {
                this.element.removeClass('jstree-' + this._data.core.themes.name + '-' + this._data.core.themes.variant);
            }
            this._data.core.themes.variant = variant_name;
            if (variant_name) {
                this.element.addClass('jstree-' + this._data.core.themes.name + '-' + this._data.core.themes.variant);
            }
        },
        /**
         * gets the name of the currently applied theme variant
         * @name get_theme()
         * @return {String}
         */
        get_theme_variant: function () { return this._data.core.themes.variant; },
        /**
         * shows a striped background on the container (if the theme supports it)
         * @name show_stripes()
         */
        show_stripes: function () {
            this._data.core.themes.stripes = true;
            this.get_container_ul().addClass("jstree-striped");
            /**
             * triggered when stripes are shown
             * @event
             * @name show_stripes.jstree
             */
            this.trigger('show_stripes');
        },
        /**
         * hides the striped background on the container
         * @name hide_stripes()
         */
        hide_stripes: function () {
            this._data.core.themes.stripes = false;
            this.get_container_ul().removeClass("jstree-striped");
            /**
             * triggered when stripes are hidden
             * @event
             * @name hide_stripes.jstree
             */
            this.trigger('hide_stripes');
        },
        /**
         * toggles the striped background on the container
         * @name toggle_stripes()
         */
        toggle_stripes: function () { if (this._data.core.themes.stripes) { this.hide_stripes(); } else { this.show_stripes(); } },
        /**
         * shows the connecting dots (if the theme supports it)
         * @name show_dots()
         */
        show_dots: function () {
            this._data.core.themes.dots = true;
            this.get_container_ul().removeClass("jstree-no-dots");
            /**
             * triggered when dots are shown
             * @event
             * @name show_dots.jstree
             */
            this.trigger('show_dots');
        },
        /**
         * hides the connecting dots
         * @name hide_dots()
         */
        hide_dots: function () {
            this._data.core.themes.dots = false;
            this.get_container_ul().addClass("jstree-no-dots");
            /**
             * triggered when dots are hidden
             * @event
             * @name hide_dots.jstree
             */
            this.trigger('hide_dots');
        },
        /**
         * toggles the connecting dots
         * @name toggle_dots()
         */
        toggle_dots: function () { if (this._data.core.themes.dots) { this.hide_dots(); } else { this.show_dots(); } },
        /**
         * show the node icons
         * @name show_icons()
         */
        show_icons: function () {
            this._data.core.themes.icons = true;
            this.get_container_ul().removeClass("jstree-no-icons");
            /**
             * triggered when icons are shown
             * @event
             * @name show_icons.jstree
             */
            this.trigger('show_icons');
        },
        /**
         * hide the node icons
         * @name hide_icons()
         */
        hide_icons: function () {
            this._data.core.themes.icons = false;
            this.get_container_ul().addClass("jstree-no-icons");
            /**
             * triggered when icons are hidden
             * @event
             * @name hide_icons.jstree
             */
            this.trigger('hide_icons');
        },
        /**
         * toggle the node icons
         * @name toggle_icons()
         */
        toggle_icons: function () { if (this._data.core.themes.icons) { this.hide_icons(); } else { this.show_icons(); } },
        /**
         * show the node ellipsis
         * @name show_icons()
         */
        show_ellipsis: function () {
            this._data.core.themes.ellipsis = true;
            this.get_container_ul().addClass("jstree-ellipsis");
            /**
             * triggered when ellisis is shown
             * @event
             * @name show_ellipsis.jstree
             */
            this.trigger('show_ellipsis');
        },
        /**
         * hide the node ellipsis
         * @name hide_ellipsis()
         */
        hide_ellipsis: function () {
            this._data.core.themes.ellipsis = false;
            this.get_container_ul().removeClass("jstree-ellipsis");
            /**
             * triggered when ellisis is hidden
             * @event
             * @name hide_ellipsis.jstree
             */
            this.trigger('hide_ellipsis');
        },
        /**
         * toggle the node ellipsis
         * @name toggle_icons()
         */
        toggle_ellipsis: function () { if (this._data.core.themes.ellipsis) { this.hide_ellipsis(); } else { this.show_ellipsis(); } },
        /**
         * set the node icon for a node
         * @name set_icon(obj, icon)
         * @param {mixed} obj
         * @param {String} icon the new icon - can be a path to an icon or a className, if using an image that is in the current directory use a `./` prefix, otherwise it will be detected as a class
         */
        set_icon: function (obj, icon) {
            var t1, t2, dom, old;
            if ($.isArray(obj)) {
                obj = obj.slice();
                for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {
                    this.set_icon(obj[t1], icon);
                }
                return true;
            }
            obj = this.get_node(obj);
            if (!obj || obj.id === $.jstree.root) { return false; }
            old = obj.icon;
            obj.icon = icon === true || icon === null || icon === undefined || icon === '' ? true : icon;
            dom = this.get_node(obj, true).children(".jstree-anchor").children(".jstree-themeicon");
            if (icon === false) {
                this.hide_icon(obj);
            }
            else if (icon === true || icon === null || icon === undefined || icon === '') {
                dom.removeClass('jstree-themeicon-custom ' + old).css("background", "").removeAttr("rel");
                if (old === false) { this.show_icon(obj); }
            }
            else if (icon.indexOf("/") === -1 && icon.indexOf(".") === -1) {
                dom.removeClass(old).css("background", "");
                dom.addClass(icon + ' jstree-themeicon-custom').attr("rel", icon);
                if (old === false) { this.show_icon(obj); }
            }
            else {
                dom.removeClass(old).css("background", "");
                dom.addClass('jstree-themeicon-custom').css("background", "url('" + icon + "') center center no-repeat").attr("rel", icon);
                if (old === false) { this.show_icon(obj); }
            }
            return true;
        },
        /**
         * get the node icon for a node
         * @name get_icon(obj)
         * @param {mixed} obj
         * @return {String}
         */
        get_icon: function (obj) {
            obj = this.get_node(obj);
            return (!obj || obj.id === $.jstree.root) ? false : obj.icon;
        },
        /**
         * hide the icon on an individual node
         * @name hide_icon(obj)
         * @param {mixed} obj
         */
        hide_icon: function (obj) {
            var t1, t2;
            if ($.isArray(obj)) {
                obj = obj.slice();
                for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {
                    this.hide_icon(obj[t1]);
                }
                return true;
            }
            obj = this.get_node(obj);
            if (!obj || obj === $.jstree.root) { return false; }
            obj.icon = false;
            this.get_node(obj, true).children(".jstree-anchor").children(".jstree-themeicon").addClass('jstree-themeicon-hidden');
            return true;
        },
        /**
         * show the icon on an individual node
         * @name show_icon(obj)
         * @param {mixed} obj
         */
        show_icon: function (obj) {
            var t1, t2, dom;
            if ($.isArray(obj)) {
                obj = obj.slice();
                for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {
                    this.show_icon(obj[t1]);
                }
                return true;
            }
            obj = this.get_node(obj);
            if (!obj || obj === $.jstree.root) { return false; }
            dom = this.get_node(obj, true);
            obj.icon = dom.length ? dom.children(".jstree-anchor").children(".jstree-themeicon").attr('rel') : true;
            if (!obj.icon) { obj.icon = true; }
            dom.children(".jstree-anchor").children(".jstree-themeicon").removeClass('jstree-themeicon-hidden');
            return true;
        }
    };

    // helpers
    $.vakata = {};
    // collect attributes
    $.vakata.attributes = function (node, with_values) {
        node = $(node)[0];
        var attr = with_values ? {} : [];
        if (node && node.attributes) {
            $.each(node.attributes, function (i, v) {
                if ($.inArray(v.name.toLowerCase(), ['style', 'contenteditable', 'hasfocus', 'tabindex']) !== -1) { return; }
                if (v.value !== null && $.trim(v.value) !== '') {
                    if (with_values) { attr[v.name] = v.value; }
                    else { attr.push(v.name); }
                }
            });
        }
        return attr;
    };
    $.vakata.array_unique = function (array) {
        var a = [], i, j, l, o = {};
        for (i = 0, l = array.length; i < l; i++) {
            if (o[array[i]] === undefined) {
                a.push(array[i]);
                o[array[i]] = true;
            }
        }
        return a;
    };
    // remove item from array
    $.vakata.array_remove = function (array, from) {
        array.splice(from, 1);
        return array;
        //var rest = array.slice((to || from) + 1 || array.length);
        //array.length = from < 0 ? array.length + from : from;
        //array.push.apply(array, rest);
        //return array;
    };
    // remove item from array
    $.vakata.array_remove_item = function (array, item) {
        var tmp = $.inArray(item, array);
        return tmp !== -1 ? $.vakata.array_remove(array, tmp) : array;
    };
    $.vakata.array_filter = function (c, a, b, d, e) {
        if (c.filter) {
            return c.filter(a, b);
        }
        d = [];
        for (e in c) {
            if (~~e + '' === e + '' && e >= 0 && a.call(b, c[e], +e, c)) {
                d.push(c[e]);
            }
        }
        return d;
    };


    /**
     * ### Changed plugin
     *
     * This plugin adds more information to the `changed.jstree` event. The new data is contained in the `changed` event data property, and contains a lists of `selected` and `deselected` nodes.
     */

    $.jstree.plugins.changed = function (options, parent) {
        var last = [];
        this.trigger = function (ev, data) {
            var i, j;
            if (!data) {
                data = {};
            }
            if (ev.replace('.jstree', '') === 'changed') {
                data.changed = { selected: [], deselected: [] };
                var tmp = {};
                for (i = 0, j = last.length; i < j; i++) {
                    tmp[last[i]] = 1;
                }
                for (i = 0, j = data.selected.length; i < j; i++) {
                    if (!tmp[data.selected[i]]) {
                        data.changed.selected.push(data.selected[i]);
                    }
                    else {
                        tmp[data.selected[i]] = 2;
                    }
                }
                for (i = 0, j = last.length; i < j; i++) {
                    if (tmp[last[i]] === 1) {
                        data.changed.deselected.push(last[i]);
                    }
                }
                last = data.selected.slice();
            }
            /**
             * triggered when selection changes (the "changed" plugin enhances the original event with more data)
             * @event
             * @name changed.jstree
             * @param {Object} node
             * @param {Object} action the action that caused the selection to change
             * @param {Array} selected the current selection
             * @param {Object} changed an object containing two properties `selected` and `deselected` - both arrays of node IDs, which were selected or deselected since the last changed event
             * @param {Object} event the event (if any) that triggered this changed event
             * @plugin changed
             */
            parent.trigger.call(this, ev, data);
        };
        this.refresh = function (skip_loading, forget_state) {
            last = [];
            return parent.refresh.apply(this, arguments);
        };
    };

    /**
     * ### Checkbox plugin
     *
     * This plugin renders checkbox icons in front of each node, making multiple selection much easier.
     * It also supports tri-state behavior, meaning that if a node has a few of its children checked it will be rendered as undetermined, and state will be propagated up.
     */

    var _i = document.createElement('I');
    _i.className = 'jstree-icon jstree-checkbox';
    _i.setAttribute('role', 'presentation');
    /**
     * stores all defaults for the checkbox plugin
     * @name $.jstree.defaults.checkbox
     * @plugin checkbox
     */
    $.jstree.defaults.checkbox = {
        /**
         * a boolean indicating if checkboxes should be visible (can be changed at a later time using `show_checkboxes()` and `hide_checkboxes`). Defaults to `true`.
         * @name $.jstree.defaults.checkbox.visible
         * @plugin checkbox
         */
        visible: true,
        /**
         * a boolean indicating if checkboxes should cascade down and have an undetermined state. Defaults to `true`.
         * @name $.jstree.defaults.checkbox.three_state
         * @plugin checkbox
         */
        three_state: true,
        /**
         * a boolean indicating if clicking anywhere on the node should act as clicking on the checkbox. Defaults to `true`.
         * @name $.jstree.defaults.checkbox.whole_node
         * @plugin checkbox
         */
        whole_node: true,
        /**
         * a boolean indicating if the selected style of a node should be kept, or removed. Defaults to `true`.
         * @name $.jstree.defaults.checkbox.keep_selected_style
         * @plugin checkbox
         */
        keep_selected_style: true,
        /**
         * This setting controls how cascading and undetermined nodes are applied.
         * If 'up' is in the string - cascading up is enabled, if 'down' is in the string - cascading down is enabled, if 'undetermined' is in the string - undetermined nodes will be used.
         * If `three_state` is set to `true` this setting is automatically set to 'up+down+undetermined'. Defaults to ''.
         * @name $.jstree.defaults.checkbox.cascade
         * @plugin checkbox
         */
        cascade: '',
        /**
         * This setting controls if checkbox are bound to the general tree selection or to an internal array maintained by the checkbox plugin. Defaults to `true`, only set to `false` if you know exactly what you are doing.
         * @name $.jstree.defaults.checkbox.tie_selection
         * @plugin checkbox
         */
        tie_selection: true
    };
    $.jstree.plugins.checkbox = function (options, parent) {
        this.bind = function () {
            parent.bind.call(this);
            this._data.checkbox.uto = false;
            this._data.checkbox.selected = [];
            if (this.settings.checkbox.three_state) {
                this.settings.checkbox.cascade = 'up+down+undetermined';
            }
            this.element
                .on("init.jstree", $.proxy(function () {
                    this._data.checkbox.visible = this.settings.checkbox.visible;
                    if (!this.settings.checkbox.keep_selected_style) {
                        this.element.addClass('jstree-checkbox-no-clicked');
                    }
                    if (this.settings.checkbox.tie_selection) {
                        this.element.addClass('jstree-checkbox-selection');
                    }
                }, this))
                .on("loading.jstree", $.proxy(function () {
                    this[this._data.checkbox.visible ? 'show_checkboxes' : 'hide_checkboxes']();
                }, this));
            if (this.settings.checkbox.cascade.indexOf('undetermined') !== -1) {
                this.element
                    .on('changed.jstree uncheck_node.jstree check_node.jstree uncheck_all.jstree check_all.jstree move_node.jstree copy_node.jstree redraw.jstree open_node.jstree', $.proxy(function () {
                        // only if undetermined is in setting
                        if (this._data.checkbox.uto) { clearTimeout(this._data.checkbox.uto); }
                        this._data.checkbox.uto = setTimeout($.proxy(this._undetermined, this), 50);
                    }, this));
            }
            if (!this.settings.checkbox.tie_selection) {
                this.element
                    .on('model.jstree', $.proxy(function (e, data) {
                        var m = this._model.data,
                            p = m[data.parent],
                            dpc = data.nodes,
                            i, j;
                        for (i = 0, j = dpc.length; i < j; i++) {
                            m[dpc[i]].state.checked = m[dpc[i]].state.checked || (m[dpc[i]].original && m[dpc[i]].original.state && m[dpc[i]].original.state.checked);
                            if (m[dpc[i]].state.checked) {
                                this._data.checkbox.selected.push(dpc[i]);
                            }
                        }
                    }, this));
            }
            if (this.settings.checkbox.cascade.indexOf('up') !== -1 || this.settings.checkbox.cascade.indexOf('down') !== -1) {
                this.element
                    .on('model.jstree', $.proxy(function (e, data) {
                        var m = this._model.data,
                            p = m[data.parent],
                            dpc = data.nodes,
                            chd = [],
                            c, i, j, k, l, tmp, s = this.settings.checkbox.cascade, t = this.settings.checkbox.tie_selection;

                        if (s.indexOf('down') !== -1) {
                            // apply down
                            if (p.state[t ? 'selected' : 'checked']) {
                                for (i = 0, j = dpc.length; i < j; i++) {
                                    m[dpc[i]].state[t ? 'selected' : 'checked'] = true;
                                }
                                this._data[t ? 'core' : 'checkbox'].selected = this._data[t ? 'core' : 'checkbox'].selected.concat(dpc);
                            }
                            else {
                                for (i = 0, j = dpc.length; i < j; i++) {
                                    if (m[dpc[i]].state[t ? 'selected' : 'checked']) {
                                        for (k = 0, l = m[dpc[i]].children_d.length; k < l; k++) {
                                            m[m[dpc[i]].children_d[k]].state[t ? 'selected' : 'checked'] = true;
                                        }
                                        this._data[t ? 'core' : 'checkbox'].selected = this._data[t ? 'core' : 'checkbox'].selected.concat(m[dpc[i]].children_d);
                                    }
                                }
                            }
                        }

                        if (s.indexOf('up') !== -1) {
                            // apply up
                            for (i = 0, j = p.children_d.length; i < j; i++) {
                                if (!m[p.children_d[i]].children.length) {
                                    chd.push(m[p.children_d[i]].parent);
                                }
                            }
                            // [Roger] : Comment out these lines to prevent parents from getting selected
                            //chd = $.vakata.array_unique(chd);
                            //for (k = 0, l = chd.length; k < l; k++) {
                            //    p = m[chd[k]];
                            //    while (p && p.id !== $.jstree.root) {
                            //        c = 0;
                            //        for (i = 0, j = p.children.length; i < j; i++) {
                            //            c += m[p.children[i]].state[t ? 'selected' : 'checked'];
                            //        }
                            //        if (c === j) {
                            //            p.state[t ? 'selected' : 'checked'] = true;
                            //            this._data[t ? 'core' : 'checkbox'].selected.push(p.id);
                            //            tmp = this.get_node(p, true);
                            //            if (tmp && tmp.length) {
                            //                tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
                            //            }
                            //        }
                            //        else {
                            //            break;
                            //        }
                            //        p = this.get_node(p.parent);
                            //    }
                            //}
                        }

                        this._data[t ? 'core' : 'checkbox'].selected = $.vakata.array_unique(this._data[t ? 'core' : 'checkbox'].selected);
                    }, this))
                    .on(this.settings.checkbox.tie_selection ? 'select_node.jstree' : 'check_node.jstree', $.proxy(function (e, data) {
                        var obj = data.node,
                            m = this._model.data,
                            par = this.get_node(obj.parent),
                            dom = this.get_node(obj, true),
                            i, j, c, tmp, s = this.settings.checkbox.cascade, t = this.settings.checkbox.tie_selection,
                            sel = {}, cur = this._data[t ? 'core' : 'checkbox'].selected;

                        for (i = 0, j = cur.length; i < j; i++) {
                            sel[cur[i]] = true;
                        }
                        // apply down
                        if (s.indexOf('down') !== -1) {
                            //this._data[ t ? 'core' : 'checkbox' ].selected = $.vakata.array_unique(this._data[ t ? 'core' : 'checkbox' ].selected.concat(obj.children_d));
                            for (i = 0, j = obj.children_d.length; i < j; i++) {
                                sel[obj.children_d[i]] = true;
                                tmp = m[obj.children_d[i]];
                                tmp.state[t ? 'selected' : 'checked'] = true;
                                if (tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {
                                    tmp.original.state.undetermined = false;
                                }
                            }
                        }

                        // apply up
                        if (s.indexOf('up') !== -1) {
                            //[Roger] : Comment out these lines to prevent parents from getting selected
                            //while (par && par.id !== $.jstree.root) {
                            //    c = 0;
                            //    for (i = 0, j = par.children.length; i < j; i++) {
                            //        c += m[par.children[i]].state[t ? 'selected' : 'checked'];
                            //    }
                            //    if (c === j) {
                            //        par.state[t ? 'selected' : 'checked'] = true;
                            //        sel[par.id] = true;
                            //        //this._data[ t ? 'core' : 'checkbox' ].selected.push(par.id);
                            //        tmp = this.get_node(par, true);
                            //        if (tmp && tmp.length) {
                            //            tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
                            //        }
                            //    }
                            //    else {
                            //        break;
                            //    }
                            //    par = this.get_node(par.parent);
                            //}
                        }

                        cur = [];
                        for (i in sel) {
                            if (sel.hasOwnProperty(i)) {
                                cur.push(i);
                            }
                        }
                        this._data[t ? 'core' : 'checkbox'].selected = cur;

                        // apply down (process .children separately?)
                        if (s.indexOf('down') !== -1 && dom.length) {
                            dom.find('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked').parent().attr('aria-selected', true);
                        }
                    }, this))
                    .on(this.settings.checkbox.tie_selection ? 'deselect_all.jstree' : 'uncheck_all.jstree', $.proxy(function (e, data) {
                        var obj = this.get_node($.jstree.root),
                            m = this._model.data,
                            i, j, tmp;
                        for (i = 0, j = obj.children_d.length; i < j; i++) {
                            tmp = m[obj.children_d[i]];
                            if (tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {
                                tmp.original.state.undetermined = false;
                            }
                        }
                    }, this))
                    .on(this.settings.checkbox.tie_selection ? 'deselect_node.jstree' : 'uncheck_node.jstree', $.proxy(function (e, data) {
                        var obj = data.node,
                            dom = this.get_node(obj, true),
                            i, j, tmp, s = this.settings.checkbox.cascade, t = this.settings.checkbox.tie_selection,
                            cur = this._data[t ? 'core' : 'checkbox'].selected, sel = {};
                        if (obj && obj.original && obj.original.state && obj.original.state.undetermined) {
                            obj.original.state.undetermined = false;
                        }

                        // apply down
                        if (s.indexOf('down') !== -1) {
                            for (i = 0, j = obj.children_d.length; i < j; i++) {
                                tmp = this._model.data[obj.children_d[i]];
                                tmp.state[t ? 'selected' : 'checked'] = false;
                                if (tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {
                                    tmp.original.state.undetermined = false;
                                }
                            }
                        }

                        // apply up
                        if (s.indexOf('up') !== -1) {
                            for (i = 0, j = obj.parents.length; i < j; i++) {
                                tmp = this._model.data[obj.parents[i]];
                                tmp.state[t ? 'selected' : 'checked'] = false;
                                if (tmp && tmp.original && tmp.original.state && tmp.original.state.undetermined) {
                                    tmp.original.state.undetermined = false;
                                }
                                tmp = this.get_node(obj.parents[i], true);
                                if (tmp && tmp.length) {
                                    tmp.attr('aria-selected', false).children('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked');
                                }
                            }
                        }
                        sel = {};
                        for (i = 0, j = cur.length; i < j; i++) {
                            // apply down + apply up
                            if (
                                (s.indexOf('down') === -1 || $.inArray(cur[i], obj.children_d) === -1) &&
                                (s.indexOf('up') === -1 || $.inArray(cur[i], obj.parents) === -1)
                            ) {
                                sel[cur[i]] = true;
                            }
                        }
                        cur = [];
                        for (i in sel) {
                            if (sel.hasOwnProperty(i)) {
                                cur.push(i);
                            }
                        }
                        this._data[t ? 'core' : 'checkbox'].selected = cur;

                        // apply down (process .children separately?)
                        if (s.indexOf('down') !== -1 && dom.length) {
                            dom.find('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked').parent().attr('aria-selected', false);
                        }
                    }, this));
            }
            if (this.settings.checkbox.cascade.indexOf('up') !== -1) {
                this.element
                    .on('delete_node.jstree', $.proxy(function (e, data) {
                        // apply up (whole handler)
                        var p = this.get_node(data.parent),
                            m = this._model.data,
                            i, j, c, tmp, t = this.settings.checkbox.tie_selection;
                        while (p && p.id !== $.jstree.root && !p.state[t ? 'selected' : 'checked']) {
                            c = 0;
                            for (i = 0, j = p.children.length; i < j; i++) {
                                c += m[p.children[i]].state[t ? 'selected' : 'checked'];
                            }
                            if (j > 0 && c === j) {
                                p.state[t ? 'selected' : 'checked'] = true;
                                this._data[t ? 'core' : 'checkbox'].selected.push(p.id);
                                tmp = this.get_node(p, true);
                                if (tmp && tmp.length) {
                                    tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
                                }
                            }
                            else {
                                break;
                            }
                            p = this.get_node(p.parent);
                        }
                    }, this))
                    .on('move_node.jstree', $.proxy(function (e, data) {
                        // apply up (whole handler)
                        var is_multi = data.is_multi,
                            old_par = data.old_parent,
                            new_par = this.get_node(data.parent),
                            m = this._model.data,
                            p, c, i, j, tmp, t = this.settings.checkbox.tie_selection;
                        if (!is_multi) {
                            p = this.get_node(old_par);
                            while (p && p.id !== $.jstree.root && !p.state[t ? 'selected' : 'checked']) {
                                c = 0;
                                for (i = 0, j = p.children.length; i < j; i++) {
                                    c += m[p.children[i]].state[t ? 'selected' : 'checked'];
                                }
                                if (j > 0 && c === j) {
                                    p.state[t ? 'selected' : 'checked'] = true;
                                    this._data[t ? 'core' : 'checkbox'].selected.push(p.id);
                                    tmp = this.get_node(p, true);
                                    if (tmp && tmp.length) {
                                        tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
                                    }
                                }
                                else {
                                    break;
                                }
                                p = this.get_node(p.parent);
                            }
                        }
                        p = new_par;
                        while (p && p.id !== $.jstree.root) {
                            c = 0;
                            for (i = 0, j = p.children.length; i < j; i++) {
                                c += m[p.children[i]].state[t ? 'selected' : 'checked'];
                            }
                            if (c === j) {
                                if (!p.state[t ? 'selected' : 'checked']) {
                                    p.state[t ? 'selected' : 'checked'] = true;
                                    this._data[t ? 'core' : 'checkbox'].selected.push(p.id);
                                    tmp = this.get_node(p, true);
                                    if (tmp && tmp.length) {
                                        tmp.attr('aria-selected', true).children('.jstree-anchor').addClass(t ? 'jstree-clicked' : 'jstree-checked');
                                    }
                                }
                            }
                            else {
                                if (p.state[t ? 'selected' : 'checked']) {
                                    p.state[t ? 'selected' : 'checked'] = false;
                                    this._data[t ? 'core' : 'checkbox'].selected = $.vakata.array_remove_item(this._data[t ? 'core' : 'checkbox'].selected, p.id);
                                    tmp = this.get_node(p, true);
                                    if (tmp && tmp.length) {
                                        tmp.attr('aria-selected', false).children('.jstree-anchor').removeClass(t ? 'jstree-clicked' : 'jstree-checked');
                                    }
                                }
                                else {
                                    break;
                                }
                            }
                            p = this.get_node(p.parent);
                        }
                    }, this));
            }
        };
        /**
         * set the undetermined state where and if necessary. Used internally.
         * @private
         * @name _undetermined()
         * @plugin checkbox
         */
        this._undetermined = function () {
            return; // [Roger]: Added return to prevent parent checkboxes from showing in an undetermined state
            if (this.element === null) { return; }
            var i, j, k, l, o = {}, m = this._model.data, t = this.settings.checkbox.tie_selection, s = this._data[t ? 'core' : 'checkbox'].selected, p = [], tt = this;
            for (i = 0, j = s.length; i < j; i++) {
                if (m[s[i]] && m[s[i]].parents) {
                    for (k = 0, l = m[s[i]].parents.length; k < l; k++) {
                        if (o[m[s[i]].parents[k]] !== undefined) {
                            break;
                        }
                        if (m[s[i]].parents[k] !== $.jstree.root) {
                            o[m[s[i]].parents[k]] = true;
                            p.push(m[s[i]].parents[k]);
                        }
                    }
                }
            }
            // attempt for server side undetermined state
            this.element.find('.jstree-closed').not(':has(.jstree-children)')
                .each(function () {
                    var tmp = tt.get_node(this), tmp2;
                    if (!tmp.state.loaded) {
                        if (tmp.original && tmp.original.state && tmp.original.state.undetermined && tmp.original.state.undetermined === true) {
                            if (o[tmp.id] === undefined && tmp.id !== $.jstree.root) {
                                o[tmp.id] = true;
                                p.push(tmp.id);
                            }
                            for (k = 0, l = tmp.parents.length; k < l; k++) {
                                if (o[tmp.parents[k]] === undefined && tmp.parents[k] !== $.jstree.root) {
                                    o[tmp.parents[k]] = true;
                                    p.push(tmp.parents[k]);
                                }
                            }
                        }
                    }
                    else {
                        for (i = 0, j = tmp.children_d.length; i < j; i++) {
                            tmp2 = m[tmp.children_d[i]];
                            if (!tmp2.state.loaded && tmp2.original && tmp2.original.state && tmp2.original.state.undetermined && tmp2.original.state.undetermined === true) {
                                if (o[tmp2.id] === undefined && tmp2.id !== $.jstree.root) {
                                    o[tmp2.id] = true;
                                    p.push(tmp2.id);
                                }
                                for (k = 0, l = tmp2.parents.length; k < l; k++) {
                                    if (o[tmp2.parents[k]] === undefined && tmp2.parents[k] !== $.jstree.root) {
                                        o[tmp2.parents[k]] = true;
                                        p.push(tmp2.parents[k]);
                                    }
                                }
                            }
                        }
                    }
                });

            this.element.find('.jstree-undetermined').removeClass('jstree-undetermined');
            for (i = 0, j = p.length; i < j; i++) {
                if (!m[p[i]].state[t ? 'selected' : 'checked']) {
                    s = this.get_node(p[i], true);
                    if (s && s.length) {
                        s.children('.jstree-anchor').children('.jstree-checkbox').addClass('jstree-undetermined');
                    }
                }
            }
        };
        this.redraw_node = function (obj, deep, is_callback, force_render) {
            obj = parent.redraw_node.apply(this, arguments);
            if (obj) {
                var i, j, tmp = null, icon = null;
                for (i = 0, j = obj.childNodes.length; i < j; i++) {
                    if (obj.childNodes[i] && obj.childNodes[i].className && obj.childNodes[i].className.indexOf("jstree-anchor") !== -1) {
                        tmp = obj.childNodes[i];
                        break;
                    }
                }
                if (tmp) {
                    if (!this.settings.checkbox.tie_selection && this._model.data[obj.id].state.checked) { tmp.className += ' jstree-checked'; }
                    icon = _i.cloneNode(false);
                    if (this._model.data[obj.id].state.checkbox_disabled) { icon.className += ' jstree-checkbox-disabled'; }
                    tmp.insertBefore(icon, tmp.childNodes[0]);
                }
            }
            if (!is_callback && this.settings.checkbox.cascade.indexOf('undetermined') !== -1) {
                if (this._data.checkbox.uto) { clearTimeout(this._data.checkbox.uto); }
                this._data.checkbox.uto = setTimeout($.proxy(this._undetermined, this), 50);
            }
            return obj;
        };
        /**
         * show the node checkbox icons
         * @name show_checkboxes()
         * @plugin checkbox
         */
        this.show_checkboxes = function () { this._data.core.themes.checkboxes = true; this.get_container_ul().removeClass("jstree-no-checkboxes"); };
        /**
         * hide the node checkbox icons
         * @name hide_checkboxes()
         * @plugin checkbox
         */
        this.hide_checkboxes = function () { this._data.core.themes.checkboxes = false; this.get_container_ul().addClass("jstree-no-checkboxes"); };
        /**
         * toggle the node icons
         * @name toggle_checkboxes()
         * @plugin checkbox
         */
        this.toggle_checkboxes = function () { if (this._data.core.themes.checkboxes) { this.hide_checkboxes(); } else { this.show_checkboxes(); } };
        /**
         * checks if a node is in an undetermined state
         * @name is_undetermined(obj)
         * @param  {mixed} obj
         * @return {Boolean}
         */
        this.is_undetermined = function (obj) {
            obj = this.get_node(obj);
            var s = this.settings.checkbox.cascade, i, j, t = this.settings.checkbox.tie_selection, d = this._data[t ? 'core' : 'checkbox'].selected, m = this._model.data;
            if (!obj || obj.state[t ? 'selected' : 'checked'] === true || s.indexOf('undetermined') === -1 || (s.indexOf('down') === -1 && s.indexOf('up') === -1)) {
                return false;
            }
            if (!obj.state.loaded && obj.original.state.undetermined === true) {
                return true;
            }
            for (i = 0, j = obj.children_d.length; i < j; i++) {
                if ($.inArray(obj.children_d[i], d) !== -1 || (!m[obj.children_d[i]].state.loaded && m[obj.children_d[i]].original.state.undetermined)) {
                    return true;
                }
            }
            return false;
        };
        /**
         * disable a node's checkbox
         * @name disable_checkbox(obj)
         * @param {mixed} obj an array can be used too
         * @trigger disable_checkbox.jstree
         * @plugin checkbox
         */
        this.disable_checkbox = function (obj) {
            var t1, t2, dom;
            if ($.isArray(obj)) {
                obj = obj.slice();
                for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {
                    this.disable_checkbox(obj[t1]);
                }
                return true;
            }
            obj = this.get_node(obj);
            if (!obj || obj.id === $.jstree.root) {
                return false;
            }
            dom = this.get_node(obj, true);
            if (!obj.state.checkbox_disabled) {
                obj.state.checkbox_disabled = true;
                if (dom && dom.length) {
                    dom.children('.jstree-anchor').children('.jstree-checkbox').addClass('jstree-checkbox-disabled');
                }
                /**
                 * triggered when an node's checkbox is disabled
                 * @event
                 * @name disable_checkbox.jstree
                 * @param {Object} node
                 * @plugin checkbox
                 */
                this.trigger('disable_checkbox', { 'node': obj });
            }
        };
        /**
         * enable a node's checkbox
         * @name disable_checkbox(obj)
         * @param {mixed} obj an array can be used too
         * @trigger enable_checkbox.jstree
         * @plugin checkbox
         */
        this.enable_checkbox = function (obj) {
            var t1, t2, dom;
            if ($.isArray(obj)) {
                obj = obj.slice();
                for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {
                    this.enable_checkbox(obj[t1]);
                }
                return true;
            }
            obj = this.get_node(obj);
            if (!obj || obj.id === $.jstree.root) {
                return false;
            }
            dom = this.get_node(obj, true);
            if (obj.state.checkbox_disabled) {
                obj.state.checkbox_disabled = false;
                if (dom && dom.length) {
                    dom.children('.jstree-anchor').children('.jstree-checkbox').removeClass('jstree-checkbox-disabled');
                }
                /**
                 * triggered when an node's checkbox is enabled
                 * @event
                 * @name enable_checkbox.jstree
                 * @param {Object} node
                 * @plugin checkbox
                 */
                this.trigger('enable_checkbox', { 'node': obj });
            }
        };

        this.activate_node = function (obj, e) {
            if ($(e.target).hasClass('jstree-checkbox-disabled')) {
                return false;
            }
            if (this.settings.checkbox.tie_selection && (this.settings.checkbox.whole_node || $(e.target).hasClass('jstree-checkbox'))) {
                e.ctrlKey = true;
            }
            if (this.settings.checkbox.tie_selection || (!this.settings.checkbox.whole_node && !$(e.target).hasClass('jstree-checkbox'))) {
                return parent.activate_node.call(this, obj, e);
            }
            if (this.is_disabled(obj)) {
                return false;
            }
            if (this.is_checked(obj)) {
                this.uncheck_node(obj, e);
            }
            else {
                this.check_node(obj, e);
            }
            this.trigger('activate_node', { 'node': this.get_node(obj) });
        };

        /**
         * check a node (only if tie_selection in checkbox settings is false, otherwise select_node will be called internally)
         * @name check_node(obj)
         * @param {mixed} obj an array can be used to check multiple nodes
         * @trigger check_node.jstree
         * @plugin checkbox
         */
        this.check_node = function (obj, e) {
            if (this.settings.checkbox.tie_selection) { return this.select_node(obj, false, true, e); }
            var dom, t1, t2, th;
            if ($.isArray(obj)) {
                obj = obj.slice();
                for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {
                    this.check_node(obj[t1], e);
                }
                return true;
            }
            obj = this.get_node(obj);
            if (!obj || obj.id === $.jstree.root) {
                return false;
            }
            dom = this.get_node(obj, true);
            if (!obj.state.checked) {
                obj.state.checked = true;
                this._data.checkbox.selected.push(obj.id);
                if (dom && dom.length) {
                    dom.children('.jstree-anchor').addClass('jstree-checked');
                }
                /**
                 * triggered when an node is checked (only if tie_selection in checkbox settings is false)
                 * @event
                 * @name check_node.jstree
                 * @param {Object} node
                 * @param {Array} selected the current selection
                 * @param {Object} event the event (if any) that triggered this check_node
                 * @plugin checkbox
                 */
                this.trigger('check_node', { 'node': obj, 'selected': this._data.checkbox.selected, 'event': e });
            }
        };
        /**
         * uncheck a node (only if tie_selection in checkbox settings is false, otherwise deselect_node will be called internally)
         * @name uncheck_node(obj)
         * @param {mixed} obj an array can be used to uncheck multiple nodes
         * @trigger uncheck_node.jstree
         * @plugin checkbox
         */
        this.uncheck_node = function (obj, e) {
            if (this.settings.checkbox.tie_selection) { return this.deselect_node(obj, false, e); }
            var t1, t2, dom;
            if ($.isArray(obj)) {
                obj = obj.slice();
                for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {
                    this.uncheck_node(obj[t1], e);
                }
                return true;
            }
            obj = this.get_node(obj);
            if (!obj || obj.id === $.jstree.root) {
                return false;
            }
            dom = this.get_node(obj, true);
            if (obj.state.checked) {
                obj.state.checked = false;
                this._data.checkbox.selected = $.vakata.array_remove_item(this._data.checkbox.selected, obj.id);
                if (dom.length) {
                    dom.children('.jstree-anchor').removeClass('jstree-checked');
                }
                /**
                 * triggered when an node is unchecked (only if tie_selection in checkbox settings is false)
                 * @event
                 * @name uncheck_node.jstree
                 * @param {Object} node
                 * @param {Array} selected the current selection
                 * @param {Object} event the event (if any) that triggered this uncheck_node
                 * @plugin checkbox
                 */
                this.trigger('uncheck_node', { 'node': obj, 'selected': this._data.checkbox.selected, 'event': e });
            }
        };
        /**
         * checks all nodes in the tree (only if tie_selection in checkbox settings is false, otherwise select_all will be called internally)
         * @name check_all()
         * @trigger check_all.jstree, changed.jstree
         * @plugin checkbox
         */
        this.check_all = function () {
            if (this.settings.checkbox.tie_selection) { return this.select_all(); }
            var tmp = this._data.checkbox.selected.concat([]), i, j;
            this._data.checkbox.selected = this._model.data[$.jstree.root].children_d.concat();
            for (i = 0, j = this._data.checkbox.selected.length; i < j; i++) {
                if (this._model.data[this._data.checkbox.selected[i]]) {
                    this._model.data[this._data.checkbox.selected[i]].state.checked = true;
                }
            }
            this.redraw(true);
            /**
             * triggered when all nodes are checked (only if tie_selection in checkbox settings is false)
             * @event
             * @name check_all.jstree
             * @param {Array} selected the current selection
             * @plugin checkbox
             */
            this.trigger('check_all', { 'selected': this._data.checkbox.selected });
        };
        /**
         * uncheck all checked nodes (only if tie_selection in checkbox settings is false, otherwise deselect_all will be called internally)
         * @name uncheck_all()
         * @trigger uncheck_all.jstree
         * @plugin checkbox
         */
        this.uncheck_all = function () {
            if (this.settings.checkbox.tie_selection) { return this.deselect_all(); }
            var tmp = this._data.checkbox.selected.concat([]), i, j;
            for (i = 0, j = this._data.checkbox.selected.length; i < j; i++) {
                if (this._model.data[this._data.checkbox.selected[i]]) {
                    this._model.data[this._data.checkbox.selected[i]].state.checked = false;
                }
            }
            this._data.checkbox.selected = [];
            this.element.find('.jstree-checked').removeClass('jstree-checked');
            /**
             * triggered when all nodes are unchecked (only if tie_selection in checkbox settings is false)
             * @event
             * @name uncheck_all.jstree
             * @param {Object} node the previous selection
             * @param {Array} selected the current selection
             * @plugin checkbox
             */
            this.trigger('uncheck_all', { 'selected': this._data.checkbox.selected, 'node': tmp });
        };
        /**
         * checks if a node is checked (if tie_selection is on in the settings this function will return the same as is_selected)
         * @name is_checked(obj)
         * @param  {mixed}  obj
         * @return {Boolean}
         * @plugin checkbox
         */
        this.is_checked = function (obj) {
            if (this.settings.checkbox.tie_selection) { return this.is_selected(obj); }
            obj = this.get_node(obj);
            if (!obj || obj.id === $.jstree.root) { return false; }
            return obj.state.checked;
        };
        /**
         * get an array of all checked nodes (if tie_selection is on in the settings this function will return the same as get_selected)
         * @name get_checked([full])
         * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
         * @return {Array}
         * @plugin checkbox
         */
        this.get_checked = function (full) {
            if (this.settings.checkbox.tie_selection) { return this.get_selected(full); }
            return full ? $.map(this._data.checkbox.selected, $.proxy(function (i) { return this.get_node(i); }, this)) : this._data.checkbox.selected;
        };
        /**
         * get an array of all top level checked nodes (ignoring children of checked nodes) (if tie_selection is on in the settings this function will return the same as get_top_selected)
         * @name get_top_checked([full])
         * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
         * @return {Array}
         * @plugin checkbox
         */
        this.get_top_checked = function (full) {
            if (this.settings.checkbox.tie_selection) { return this.get_top_selected(full); }
            var tmp = this.get_checked(true),
                obj = {}, i, j, k, l;
            for (i = 0, j = tmp.length; i < j; i++) {
                obj[tmp[i].id] = tmp[i];
            }
            for (i = 0, j = tmp.length; i < j; i++) {
                for (k = 0, l = tmp[i].children_d.length; k < l; k++) {
                    if (obj[tmp[i].children_d[k]]) {
                        delete obj[tmp[i].children_d[k]];
                    }
                }
            }
            tmp = [];
            for (i in obj) {
                if (obj.hasOwnProperty(i)) {
                    tmp.push(i);
                }
            }
            return full ? $.map(tmp, $.proxy(function (i) { return this.get_node(i); }, this)) : tmp;
        };
        /**
         * get an array of all bottom level checked nodes (ignoring selected parents) (if tie_selection is on in the settings this function will return the same as get_bottom_selected)
         * @name get_bottom_checked([full])
         * @param  {mixed}  full if set to `true` the returned array will consist of the full node objects, otherwise - only IDs will be returned
         * @return {Array}
         * @plugin checkbox
         */
        this.get_bottom_checked = function (full) {
            if (this.settings.checkbox.tie_selection) { return this.get_bottom_selected(full); }
            var tmp = this.get_checked(true),
                obj = [], i, j;
            for (i = 0, j = tmp.length; i < j; i++) {
                if (!tmp[i].children.length) {
                    obj.push(tmp[i].id);
                }
            }
            return full ? $.map(obj, $.proxy(function (i) { return this.get_node(i); }, this)) : obj;
        };
        this.load_node = function (obj, callback) {
            var k, l, i, j, c, tmp;
            if (!$.isArray(obj) && !this.settings.checkbox.tie_selection) {
                tmp = this.get_node(obj);
                if (tmp && tmp.state.loaded) {
                    for (k = 0, l = tmp.children_d.length; k < l; k++) {
                        if (this._model.data[tmp.children_d[k]].state.checked) {
                            c = true;
                            this._data.checkbox.selected = $.vakata.array_remove_item(this._data.checkbox.selected, tmp.children_d[k]);
                        }
                    }
                }
            }
            return parent.load_node.apply(this, arguments);
        };
        this.get_state = function () {
            var state = parent.get_state.apply(this, arguments);
            if (this.settings.checkbox.tie_selection) { return state; }
            state.checkbox = this._data.checkbox.selected.slice();
            return state;
        };
        this.set_state = function (state, callback) {
            var res = parent.set_state.apply(this, arguments);
            if (res && state.checkbox) {
                if (!this.settings.checkbox.tie_selection) {
                    this.uncheck_all();
                    var _this = this;
                    $.each(state.checkbox, function (i, v) {
                        _this.check_node(v);
                    });
                }
                delete state.checkbox;
                this.set_state(state, callback);
                return false;
            }
            return res;
        };
        this.refresh = function (skip_loading, forget_state) {
            if (!this.settings.checkbox.tie_selection) {
                this._data.checkbox.selected = [];
            }
            return parent.refresh.apply(this, arguments);
        };
    };

    // include the checkbox plugin by default
    // $.jstree.defaults.plugins.push("checkbox");

    /**
     * ### Conditionalselect plugin
     *
     * This plugin allows defining a callback to allow or deny node selection by user input (activate node method).
     */

    /**
     * a callback (function) which is invoked in the instance's scope and receives two arguments - the node and the event that triggered the `activate_node` call. Returning false prevents working with the node, returning true allows invoking activate_node. Defaults to returning `true`.
     * @name $.jstree.defaults.checkbox.visible
     * @plugin checkbox
     */
    $.jstree.defaults.conditionalselect = function () { return true; };
    $.jstree.plugins.conditionalselect = function (options, parent) {
        // own function
        this.activate_node = function (obj, e) {
            if (this.settings.conditionalselect.call(this, this.get_node(obj), e)) {
                parent.activate_node.call(this, obj, e);
            }
        };
    };


    /**
     * ### Contextmenu plugin
     *
     * Shows a context menu when a node is right-clicked.
     */

    /**
     * stores all defaults for the contextmenu plugin
     * @name $.jstree.defaults.contextmenu
     * @plugin contextmenu
     */
    $.jstree.defaults.contextmenu = {
        /**
         * a boolean indicating if the node should be selected when the context menu is invoked on it. Defaults to `true`.
         * @name $.jstree.defaults.contextmenu.select_node
         * @plugin contextmenu
         */
        select_node: true,
        /**
         * a boolean indicating if the menu should be shown aligned with the node. Defaults to `true`, otherwise the mouse coordinates are used.
         * @name $.jstree.defaults.contextmenu.show_at_node
         * @plugin contextmenu
         */
        show_at_node: true,
        /**
         * an object of actions, or a function that accepts a node and a callback function and calls the callback function with an object of actions available for that node (you can also return the items too).
         *
         * Each action consists of a key (a unique name) and a value which is an object with the following properties (only label and action are required). Once a menu item is activated the `action` function will be invoked with an object containing the following keys: item - the contextmenu item definition as seen below, reference - the DOM node that was used (the tree node), element - the contextmenu DOM element, position - an object with x/y properties indicating the position of the menu.
         *
         * * `separator_before` - a boolean indicating if there should be a separator before this item
         * * `separator_after` - a boolean indicating if there should be a separator after this item
         * * `_disabled` - a boolean indicating if this action should be disabled
         * * `label` - a string - the name of the action (could be a function returning a string)
         * * `title` - a string - an optional tooltip for the item
         * * `action` - a function to be executed if this item is chosen, the function will receive 
         * * `icon` - a string, can be a path to an icon or a className, if using an image that is in the current directory use a `./` prefix, otherwise it will be detected as a class
         * * `shortcut` - keyCode which will trigger the action if the menu is open (for example `113` for rename, which equals F2)
         * * `shortcut_label` - shortcut label (like for example `F2` for rename)
         * * `submenu` - an object with the same structure as $.jstree.defaults.contextmenu.items which can be used to create a submenu - each key will be rendered as a separate option in a submenu that will appear once the current item is hovered
         *
         * @name $.jstree.defaults.contextmenu.items
         * @plugin contextmenu
         */
        items: function (o, cb) { // Could be an object directly
            return {
                "create": {
                    "separator_before": false,
                    "separator_after": true,
                    "_disabled": false, //(this.check("create_node", data.reference, {}, "last")),
                    "label": "Create",
                    "action": function (data) {
                        var inst = $.jstree.reference(data.reference),
                            obj = inst.get_node(data.reference);
                        inst.create_node(obj, {}, "last", function (new_node) {
                            setTimeout(function () { inst.edit(new_node); }, 0);
                        });
                    }
                },
                "rename": {
                    "separator_before": false,
                    "separator_after": false,
                    "_disabled": false, //(this.check("rename_node", data.reference, this.get_parent(data.reference), "")),
                    "label": "Rename",
                    /*!
                    "shortcut"			: 113,
                    "shortcut_label"	: 'F2',
                    "icon"				: "glyphicon glyphicon-leaf",
                    */
                    "action": function (data) {
                        var inst = $.jstree.reference(data.reference),
                            obj = inst.get_node(data.reference);
                        inst.edit(obj);
                    }
                },
                "remove": {
                    "separator_before": false,
                    "icon": false,
                    "separator_after": false,
                    "_disabled": false, //(this.check("delete_node", data.reference, this.get_parent(data.reference), "")),
                    "label": "Delete",
                    "action": function (data) {
                        var inst = $.jstree.reference(data.reference),
                            obj = inst.get_node(data.reference);
                        if (inst.is_selected(obj)) {
                            inst.delete_node(inst.get_selected());
                        }
                        else {
                            inst.delete_node(obj);
                        }
                    }
                },
                "ccp": {
                    "separator_before": true,
                    "icon": false,
                    "separator_after": false,
                    "label": "Edit",
                    "action": false,
                    "submenu": {
                        "cut": {
                            "separator_before": false,
                            "separator_after": false,
                            "label": "Cut",
                            "action": function (data) {
                                var inst = $.jstree.reference(data.reference),
                                    obj = inst.get_node(data.reference);
                                if (inst.is_selected(obj)) {
                                    inst.cut(inst.get_top_selected());
                                }
                                else {
                                    inst.cut(obj);
                                }
                            }
                        },
                        "copy": {
                            "separator_before": false,
                            "icon": false,
                            "separator_after": false,
                            "label": "Copy",
                            "action": function (data) {
                                var inst = $.jstree.reference(data.reference),
                                    obj = inst.get_node(data.reference);
                                if (inst.is_selected(obj)) {
                                    inst.copy(inst.get_top_selected());
                                }
                                else {
                                    inst.copy(obj);
                                }
                            }
                        },
                        "paste": {
                            "separator_before": false,
                            "icon": false,
                            "_disabled": function (data) {
                                return !$.jstree.reference(data.reference).can_paste();
                            },
                            "separator_after": false,
                            "label": "Paste",
                            "action": function (data) {
                                var inst = $.jstree.reference(data.reference),
                                    obj = inst.get_node(data.reference);
                                inst.paste(obj);
                            }
                        }
                    }
                }
            };
        }
    };

    $.jstree.plugins.contextmenu = function (options, parent) {
        this.bind = function () {
            parent.bind.call(this);

            var last_ts = 0, cto = null, ex, ey;
            this.element
                .on("contextmenu.jstree", ".jstree-anchor", $.proxy(function (e, data) {
                    if (e.target.tagName.toLowerCase() === 'input') {
                        return;
                    }
                    e.preventDefault();
                    last_ts = e.ctrlKey ? +new Date() : 0;
                    if (data || cto) {
                        last_ts = (+new Date()) + 10000;
                    }
                    if (cto) {
                        clearTimeout(cto);
                    }
                    if (!this.is_loading(e.currentTarget)) {
                        this.show_contextmenu(e.currentTarget, e.pageX, e.pageY, e);
                    }
                }, this))
                .on("click.jstree", ".jstree-anchor", $.proxy(function (e) {
                    if (this._data.contextmenu.visible && (!last_ts || (+new Date()) - last_ts > 250)) { // work around safari & macOS ctrl+click
                        $.vakata.context.hide();
                    }
                    last_ts = 0;
                }, this))
                .on("touchstart.jstree", ".jstree-anchor", function (e) {
                    if (!e.originalEvent || !e.originalEvent.changedTouches || !e.originalEvent.changedTouches[0]) {
                        return;
                    }
                    ex = e.originalEvent.changedTouches[0].clientX;
                    ey = e.originalEvent.changedTouches[0].clientY;
                    cto = setTimeout(function () {
                        $(e.currentTarget).trigger('contextmenu', true);
                    }, 750);
                })
                .on('touchmove.vakata.jstree', function (e) {
                    if (cto && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0] && (Math.abs(ex - e.originalEvent.changedTouches[0].clientX) > 50 || Math.abs(ey - e.originalEvent.changedTouches[0].clientY) > 50)) {
                        clearTimeout(cto);
                    }
                })
                .on('touchend.vakata.jstree', function (e) {
                    if (cto) {
                        clearTimeout(cto);
                    }
                });

            /*!
            if(!('oncontextmenu' in document.body) && ('ontouchstart' in document.body)) {
                var el = null, tm = null;
                this.element
                    .on("touchstart", ".jstree-anchor", function (e) {
                        el = e.currentTarget;
                        tm = +new Date();
                        $(document).one("touchend", function (e) {
                            e.target = document.elementFromPoint(e.originalEvent.targetTouches[0].pageX - window.pageXOffset, e.originalEvent.targetTouches[0].pageY - window.pageYOffset);
                            e.currentTarget = e.target;
                            tm = ((+(new Date())) - tm);
                            if(e.target === el && tm > 600 && tm < 1000) {
                                e.preventDefault();
                                $(el).trigger('contextmenu', e);
                            }
                            el = null;
                            tm = null;
                        });
                    });
            }
            */
            $(document).on("context_hide.vakata.jstree", $.proxy(function (e, data) {
                this._data.contextmenu.visible = false;
                $(data.reference).removeClass('jstree-context');
            }, this));
        };
        this.teardown = function () {
            if (this._data.contextmenu.visible) {
                $.vakata.context.hide();
            }
            parent.teardown.call(this);
        };

        /**
         * prepare and show the context menu for a node
         * @name show_contextmenu(obj [, x, y])
         * @param {mixed} obj the node
         * @param {Number} x the x-coordinate relative to the document to show the menu at
         * @param {Number} y the y-coordinate relative to the document to show the menu at
         * @param {Object} e the event if available that triggered the contextmenu
         * @plugin contextmenu
         * @trigger show_contextmenu.jstree
         */
        this.show_contextmenu = function (obj, x, y, e) {
            obj = this.get_node(obj);
            if (!obj || obj.id === $.jstree.root) { return false; }
            var s = this.settings.contextmenu,
                d = this.get_node(obj, true),
                a = d.children(".jstree-anchor"),
                o = false,
                i = false;
            if (s.show_at_node || x === undefined || y === undefined) {
                o = a.offset();
                x = o.left;
                y = o.top + this._data.core.li_height;
            }
            if (this.settings.contextmenu.select_node && !this.is_selected(obj)) {
                this.activate_node(obj, e);
            }

            i = s.items;
            if ($.isFunction(i)) {
                i = i.call(this, obj, $.proxy(function (i) {
                    this._show_contextmenu(obj, x, y, i);
                }, this));
            }
            if ($.isPlainObject(i)) {
                this._show_contextmenu(obj, x, y, i);
            }
        };
        /**
         * show the prepared context menu for a node
         * @name _show_contextmenu(obj, x, y, i)
         * @param {mixed} obj the node
         * @param {Number} x the x-coordinate relative to the document to show the menu at
         * @param {Number} y the y-coordinate relative to the document to show the menu at
         * @param {Number} i the object of items to show
         * @plugin contextmenu
         * @trigger show_contextmenu.jstree
         * @private
         */
        this._show_contextmenu = function (obj, x, y, i) {
            var d = this.get_node(obj, true),
                a = d.children(".jstree-anchor");
            $(document).one("context_show.vakata.jstree", $.proxy(function (e, data) {
                var cls = 'jstree-contextmenu jstree-' + this.get_theme() + '-contextmenu';
                $(data.element).addClass(cls);
                a.addClass('jstree-context');
            }, this));
            this._data.contextmenu.visible = true;
            $.vakata.context.show(a, { 'x': x, 'y': y }, i);
            /**
             * triggered when the contextmenu is shown for a node
             * @event
             * @name show_contextmenu.jstree
             * @param {Object} node the node
             * @param {Number} x the x-coordinate of the menu relative to the document
             * @param {Number} y the y-coordinate of the menu relative to the document
             * @plugin contextmenu
             */
            this.trigger('show_contextmenu', { "node": obj, "x": x, "y": y });
        };
    };

    // contextmenu helper
    (function ($) {
        var right_to_left = false,
            vakata_context = {
                element: false,
                reference: false,
                position_x: 0,
                position_y: 0,
                items: [],
                html: "",
                is_visible: false
            };

        $.vakata.context = {
            settings: {
                hide_onmouseleave: 0,
                icons: true
            },
            _trigger: function (event_name) {
                $(document).triggerHandler("context_" + event_name + ".vakata", {
                    "reference": vakata_context.reference,
                    "element": vakata_context.element,
                    "position": {
                        "x": vakata_context.position_x,
                        "y": vakata_context.position_y
                    }
                });
            },
            _execute: function (i) {
                i = vakata_context.items[i];
                return i && (!i._disabled || ($.isFunction(i._disabled) && !i._disabled({ "item": i, "reference": vakata_context.reference, "element": vakata_context.element }))) && i.action ? i.action.call(null, {
                    "item": i,
                    "reference": vakata_context.reference,
                    "element": vakata_context.element,
                    "position": {
                        "x": vakata_context.position_x,
                        "y": vakata_context.position_y
                    }
                }) : false;
            },
            _parse: function (o, is_callback) {
                if (!o) { return false; }
                if (!is_callback) {
                    vakata_context.html = "";
                    vakata_context.items = [];
                }
                var str = "",
                    sep = false,
                    tmp;

                if (is_callback) { str += "<" + "ul>"; }
                $.each(o, function (i, val) {
                    if (!val) { return true; }
                    vakata_context.items.push(val);
                    if (!sep && val.separator_before) {
                        str += "<" + "li class='vakata-context-separator'><" + "a href='#' " + ($.vakata.context.settings.icons ? '' : 'style="margin-left:0px;"') + ">&#160;<" + "/a><" + "/li>";
                    }
                    sep = false;
                    str += "<" + "li class='" + (val._class || "") + (val._disabled === true || ($.isFunction(val._disabled) && val._disabled({ "item": val, "reference": vakata_context.reference, "element": vakata_context.element })) ? " vakata-contextmenu-disabled " : "") + "' " + (val.shortcut ? " data-shortcut='" + val.shortcut + "' " : '') + ">";
                    str += "<" + "a href='#' rel='" + (vakata_context.items.length - 1) + "' " + (val.title ? "title='" + val.title + "'" : "") + ">";
                    if ($.vakata.context.settings.icons) {
                        str += "<" + "i ";
                        if (val.icon) {
                            if (val.icon.indexOf("/") !== -1 || val.icon.indexOf(".") !== -1) { str += " style='background:url(\"" + val.icon + "\") center center no-repeat' "; }
                            else { str += " class='" + val.icon + "' "; }
                        }
                        str += "><" + "/i><" + "span class='vakata-contextmenu-sep'>&#160;<" + "/span>";
                    }
                    str += ($.isFunction(val.label) ? val.label({ "item": i, "reference": vakata_context.reference, "element": vakata_context.element }) : val.label) + (val.shortcut ? ' <span class="vakata-contextmenu-shortcut vakata-contextmenu-shortcut-' + val.shortcut + '">' + (val.shortcut_label || '') + '</span>' : '') + "<" + "/a>";
                    if (val.submenu) {
                        tmp = $.vakata.context._parse(val.submenu, true);
                        if (tmp) { str += tmp; }
                    }
                    str += "<" + "/li>";
                    if (val.separator_after) {
                        str += "<" + "li class='vakata-context-separator'><" + "a href='#' " + ($.vakata.context.settings.icons ? '' : 'style="margin-left:0px;"') + ">&#160;<" + "/a><" + "/li>";
                        sep = true;
                    }
                });
                str = str.replace(/<li class\='vakata-context-separator'\><\/li\>$/, "");
                if (is_callback) { str += "</ul>"; }
                /**
                 * triggered on the document when the contextmenu is parsed (HTML is built)
                 * @event
                 * @plugin contextmenu
                 * @name context_parse.vakata
                 * @param {jQuery} reference the element that was right clicked
                 * @param {jQuery} element the DOM element of the menu itself
                 * @param {Object} position the x & y coordinates of the menu
                 */
                if (!is_callback) { vakata_context.html = str; $.vakata.context._trigger("parse"); }
                return str.length > 10 ? str : false;
            },
            _show_submenu: function (o) {
                o = $(o);
                if (!o.length || !o.children("ul").length) { return; }
                var e = o.children("ul"),
                    xl = o.offset().left,
                    x = xl + o.outerWidth(),
                    y = o.offset().top,
                    w = e.width(),
                    h = e.height(),
                    dw = $(window).width() + $(window).scrollLeft(),
                    dh = $(window).height() + $(window).scrollTop();
                //        -       
                if (right_to_left) {
                    o[x - (w + 10 + o.outerWidth()) < 0 ? "addClass" : "removeClass"]("vakata-context-left");
                }
                else {
                    o[x + w > dw && xl > dw - x ? "addClass" : "removeClass"]("vakata-context-right");
                }
                if (y + h + 10 > dh) {
                    e.css("bottom", "-1px");
                }

                //if does not fit - stick it to the side
                if (o.hasClass('vakata-context-right')) {
                    if (xl < w) {
                        e.css("margin-right", xl - w);
                    }
                } else {
                    if (dw - x < w) {
                        e.css("margin-left", dw - x - w);
                    }
                }

                e.show();
            },
            show: function (reference, position, data) {
                var o, e, x, y, w, h, dw, dh, cond = true;
                if (vakata_context.element && vakata_context.element.length) {
                    vakata_context.element.width('');
                }
                switch (cond) {
                    case (!position && !reference):
                        return false;
                    case (!!position && !!reference):
                        vakata_context.reference = reference;
                        vakata_context.position_x = position.x;
                        vakata_context.position_y = position.y;
                        break;
                    case (!position && !!reference):
                        vakata_context.reference = reference;
                        o = reference.offset();
                        vakata_context.position_x = o.left + reference.outerHeight();
                        vakata_context.position_y = o.top;
                        break;
                    case (!!position && !reference):
                        vakata_context.position_x = position.x;
                        vakata_context.position_y = position.y;
                        break;
                }
                if (!!reference && !data && $(reference).data('vakata_contextmenu')) {
                    data = $(reference).data('vakata_contextmenu');
                }
                if ($.vakata.context._parse(data)) {
                    vakata_context.element.html(vakata_context.html);
                }
                if (vakata_context.items.length) {
                    vakata_context.element.appendTo("body");
                    e = vakata_context.element;
                    x = vakata_context.position_x;
                    y = vakata_context.position_y;
                    w = e.width();
                    h = e.height();
                    dw = $(window).width() + $(window).scrollLeft();
                    dh = $(window).height() + $(window).scrollTop();
                    if (right_to_left) {
                        x -= (e.outerWidth() - $(reference).outerWidth());
                        if (x < $(window).scrollLeft() + 20) {
                            x = $(window).scrollLeft() + 20;
                        }
                    }
                    if (x + w + 20 > dw) {
                        x = dw - (w + 20);
                    }
                    if (y + h + 20 > dh) {
                        y = dh - (h + 20);
                    }

                    vakata_context.element
                        .css({ "left": x, "top": y })
                        .show()
                        .find('a').first().focus().parent().addClass("vakata-context-hover");
                    vakata_context.is_visible = true;
                    /**
                     * triggered on the document when the contextmenu is shown
                     * @event
                     * @plugin contextmenu
                     * @name context_show.vakata
                     * @param {jQuery} reference the element that was right clicked
                     * @param {jQuery} element the DOM element of the menu itself
                     * @param {Object} position the x & y coordinates of the menu
                     */
                    $.vakata.context._trigger("show");
                }
            },
            hide: function () {
                if (vakata_context.is_visible) {
                    vakata_context.element.hide().find("ul").hide().end().find(':focus').blur().end().detach();
                    vakata_context.is_visible = false;
                    /**
                     * triggered on the document when the contextmenu is hidden
                     * @event
                     * @plugin contextmenu
                     * @name context_hide.vakata
                     * @param {jQuery} reference the element that was right clicked
                     * @param {jQuery} element the DOM element of the menu itself
                     * @param {Object} position the x & y coordinates of the menu
                     */
                    $.vakata.context._trigger("hide");
                }
            }
        };
        $(function () {
            right_to_left = $("body").css("direction") === "rtl";
            var to = false;

            vakata_context.element = $("<ul class='vakata-context'></ul>");
            vakata_context.element
                .on("mouseenter", "li", function (e) {
                    e.stopImmediatePropagation();

                    if ($.contains(this, e.relatedTarget)) {
                        //   delegate mouseleave -
                        // $(this).find(".vakata-context-hover").removeClass("vakata-context-hover");
                        return;
                    }

                    if (to) { clearTimeout(to); }
                    vakata_context.element.find(".vakata-context-hover").removeClass("vakata-context-hover").end();

                    $(this)
                        .siblings().find("ul").hide().end().end()
                        .parentsUntil(".vakata-context", "li").addBack().addClass("vakata-context-hover");
                    $.vakata.context._show_submenu(this);
                })
                //  -   ?
                .on("mouseleave", "li", function (e) {
                    if ($.contains(this, e.relatedTarget)) { return; }
                    $(this).find(".vakata-context-hover").addBack().removeClass("vakata-context-hover");
                })
                .on("mouseleave", function (e) {
                    $(this).find(".vakata-context-hover").removeClass("vakata-context-hover");
                    if ($.vakata.context.settings.hide_onmouseleave) {
                        to = setTimeout(
                            (function (t) {
                                return function () { $.vakata.context.hide(); };
                            }(this)), $.vakata.context.settings.hide_onmouseleave);
                    }
                })
                .on("click", "a", function (e) {
                    e.preventDefault();
                    //})
                    //.on("mouseup", "a", function (e) {
                    if (!$(this).blur().parent().hasClass("vakata-context-disabled") && $.vakata.context._execute($(this).attr("rel")) !== false) {
                        $.vakata.context.hide();
                    }
                })
                .on('keydown', 'a', function (e) {
                    var o = null;
                    switch (e.which) {
                        case 13:
                        case 32:
                            e.type = "click";
                            e.preventDefault();
                            $(e.currentTarget).trigger(e);
                            break;
                        case 37:
                            if (vakata_context.is_visible) {
                                vakata_context.element.find(".vakata-context-hover").last().closest("li").first().find("ul").hide().find(".vakata-context-hover").removeClass("vakata-context-hover").end().end().children('a').focus();
                                e.stopImmediatePropagation();
                                e.preventDefault();
                            }
                            break;
                        case 38:
                            if (vakata_context.is_visible) {
                                o = vakata_context.element.find("ul:visible").addBack().last().children(".vakata-context-hover").removeClass("vakata-context-hover").prevAll("li:not(.vakata-context-separator)").first();
                                if (!o.length) { o = vakata_context.element.find("ul:visible").addBack().last().children("li:not(.vakata-context-separator)").last(); }
                                o.addClass("vakata-context-hover").children('a').focus();
                                e.stopImmediatePropagation();
                                e.preventDefault();
                            }
                            break;
                        case 39:
                            if (vakata_context.is_visible) {
                                vakata_context.element.find(".vakata-context-hover").last().children("ul").show().children("li:not(.vakata-context-separator)").removeClass("vakata-context-hover").first().addClass("vakata-context-hover").children('a').focus();
                                e.stopImmediatePropagation();
                                e.preventDefault();
                            }
                            break;
                        case 40:
                            if (vakata_context.is_visible) {
                                o = vakata_context.element.find("ul:visible").addBack().last().children(".vakata-context-hover").removeClass("vakata-context-hover").nextAll("li:not(.vakata-context-separator)").first();
                                if (!o.length) { o = vakata_context.element.find("ul:visible").addBack().last().children("li:not(.vakata-context-separator)").first(); }
                                o.addClass("vakata-context-hover").children('a').focus();
                                e.stopImmediatePropagation();
                                e.preventDefault();
                            }
                            break;
                        case 27:
                            $.vakata.context.hide();
                            e.preventDefault();
                            break;
                        default:
                            //console.log(e.which);
                            break;
                    }
                })
                .on('keydown', function (e) {
                    e.preventDefault();
                    var a = vakata_context.element.find('.vakata-contextmenu-shortcut-' + e.which).parent();
                    if (a.parent().not('.vakata-context-disabled')) {
                        a.click();
                    }
                });

            $(document)
                .on("mousedown.vakata.jstree", function (e) {
                    if (vakata_context.is_visible && !$.contains(vakata_context.element[0], e.target)) {
                        $.vakata.context.hide();
                    }
                })
                .on("context_show.vakata.jstree", function (e, data) {
                    vakata_context.element.find("li:has(ul)").children("a").addClass("vakata-context-parent");
                    if (right_to_left) {
                        vakata_context.element.addClass("vakata-context-rtl").css("direction", "rtl");
                    }
                    // also apply a RTL class?
                    vakata_context.element.find("ul").hide().end();
                });
        });
    }($));
    // $.jstree.defaults.plugins.push("contextmenu");


    /**
     * ### Drag'n'drop plugin
     *
     * Enables dragging and dropping of nodes in the tree, resulting in a move or copy operations.
     */

    /**
     * stores all defaults for the drag'n'drop plugin
     * @name $.jstree.defaults.dnd
     * @plugin dnd
     */
    $.jstree.defaults.dnd = {
        /**
         * a boolean indicating if a copy should be possible while dragging (by pressint the meta key or Ctrl). Defaults to `true`.
         * @name $.jstree.defaults.dnd.copy
         * @plugin dnd
         */
        copy: true,
        /**
         * a number indicating how long a node should remain hovered while dragging to be opened. Defaults to `500`.
         * @name $.jstree.defaults.dnd.open_timeout
         * @plugin dnd
         */
        open_timeout: 500,
        /**
         * a function invoked each time a node is about to be dragged, invoked in the tree's scope and receives the nodes about to be dragged as an argument (array) and the event that started the drag - return `false` to prevent dragging
         * @name $.jstree.defaults.dnd.is_draggable
         * @plugin dnd
         */
        is_draggable: true,
        /**
         * a boolean indicating if checks should constantly be made while the user is dragging the node (as opposed to checking only on drop), default is `true`
         * @name $.jstree.defaults.dnd.check_while_dragging
         * @plugin dnd
         */
        check_while_dragging: true,
        /**
         * a boolean indicating if nodes from this tree should only be copied with dnd (as opposed to moved), default is `false`
         * @name $.jstree.defaults.dnd.always_copy
         * @plugin dnd
         */
        always_copy: false,
        /**
         * when dropping a node "inside", this setting indicates the position the node should go to - it can be an integer or a string: "first" (same as 0) or "last", default is `0`
         * @name $.jstree.defaults.dnd.inside_pos
         * @plugin dnd
         */
        inside_pos: 0,
        /**
         * when starting the drag on a node that is selected this setting controls if all selected nodes are dragged or only the single node, default is `true`, which means all selected nodes are dragged when the drag is started on a selected node
         * @name $.jstree.defaults.dnd.drag_selection
         * @plugin dnd
         */
        drag_selection: true,
        /**
         * controls whether dnd works on touch devices. If left as boolean true dnd will work the same as in desktop browsers, which in some cases may impair scrolling. If set to boolean false dnd will not work on touch devices. There is a special third option - string "selected" which means only selected nodes can be dragged on touch devices.
         * @name $.jstree.defaults.dnd.touch
         * @plugin dnd
         */
        touch: true,
        /**
         * controls whether items can be dropped anywhere on the node, not just on the anchor, by default only the node anchor is a valid drop target. Works best with the wholerow plugin. If enabled on mobile depending on the interface it might be hard for the user to cancel the drop, since the whole tree container will be a valid drop target.
         * @name $.jstree.defaults.dnd.large_drop_target
         * @plugin dnd
         */
        large_drop_target: false,
        /**
         * controls whether a drag can be initiated from any part of the node and not just the text/icon part, works best with the wholerow plugin. Keep in mind it can cause problems with tree scrolling on mobile depending on the interface - in that case set the touch option to "selected".
         * @name $.jstree.defaults.dnd.large_drag_target
         * @plugin dnd
         */
        large_drag_target: false,
        /**
         * controls whether use HTML5 dnd api instead of classical. That will allow better integration of dnd events with other HTML5 controls.
         * @reference http://caniuse.com/#feat=dragndrop
         * @name $.jstree.defaults.dnd.use_html5
         * @plugin dnd
         */
        use_html5: false
    };
    var drg, elm;
    // TODO: now check works by checking for each node individually, how about max_children, unique, etc?
    $.jstree.plugins.dnd = function (options, parent) {
        this.init = function (el, options) {
            parent.init.call(this, el, options);
            this.settings.dnd.use_html5 = this.settings.dnd.use_html5 && ('draggable' in document.createElement('span'));
        };
        this.bind = function () {
            parent.bind.call(this);

            this.element
                .on(this.settings.dnd.use_html5 ? 'dragstart.jstree' : 'mousedown.jstree touchstart.jstree', this.settings.dnd.large_drag_target ? '.jstree-node' : '.jstree-anchor', $.proxy(function (e) {
                    if (this.settings.dnd.large_drag_target && $(e.target).closest('.jstree-node')[0] !== e.currentTarget) {
                        return true;
                    }
                    if (e.type === "touchstart" && (!this.settings.dnd.touch || (this.settings.dnd.touch === 'selected' && !$(e.currentTarget).closest('.jstree-node').children('.jstree-anchor').hasClass('jstree-clicked')))) {
                        return true;
                    }
                    var obj = this.get_node(e.target),
                        mlt = this.is_selected(obj) && this.settings.dnd.drag_selection ? this.get_top_selected().length : 1,
                        txt = (mlt > 1 ? mlt + ' ' + this.get_string('nodes') : this.get_text(e.currentTarget));
                    if (this.settings.core.force_text) {
                        txt = $.vakata.html.escape(txt);
                    }
                    if (obj && obj.id && obj.id !== $.jstree.root && (e.which === 1 || e.type === "touchstart" || e.type === "dragstart") &&
                        (this.settings.dnd.is_draggable === true || ($.isFunction(this.settings.dnd.is_draggable) && this.settings.dnd.is_draggable.call(this, (mlt > 1 ? this.get_top_selected(true) : [obj]), e)))
                    ) {
                        drg = { 'jstree': true, 'origin': this, 'obj': this.get_node(obj, true), 'nodes': mlt > 1 ? this.get_top_selected() : [obj.id] };
                        elm = e.currentTarget;
                        if (this.settings.dnd.use_html5) {
                            $.vakata.dnd._trigger('start', e, { 'helper': $(), 'element': elm, 'data': drg });
                        } else {
                            this.element.trigger('mousedown.jstree');
                            return $.vakata.dnd.start(e, drg, '<div id="jstree-dnd" class="jstree-' + this.get_theme() + ' jstree-' + this.get_theme() + '-' + this.get_theme_variant() + ' ' + (this.settings.core.themes.responsive ? ' jstree-dnd-responsive' : '') + '"><i class="jstree-icon jstree-er"></i>' + txt + '<ins class="jstree-copy" style="display:none;">+</ins></div>');
                        }
                    }
                }, this));
            if (this.settings.dnd.use_html5) {
                this.element
                    .on('dragover.jstree', function (e) {
                        e.preventDefault();
                        $.vakata.dnd._trigger('move', e, { 'helper': $(), 'element': elm, 'data': drg });
                        return false;
                    })
                    //.on('dragenter.jstree', this.settings.dnd.large_drop_target ? '.jstree-node' : '.jstree-anchor', $.proxy(function (e) {
                    //		e.preventDefault();
                    //		$.vakata.dnd._trigger('move', e, { 'helper': $(), 'element': elm, 'data': drg });
                    //		return false;
                    //	}, this))
                    .on('drop.jstree', $.proxy(function (e) {
                        e.preventDefault();
                        $.vakata.dnd._trigger('stop', e, { 'helper': $(), 'element': elm, 'data': drg });
                        return false;
                    }, this));
            }
        };
        this.redraw_node = function (obj, deep, callback, force_render) {
            obj = parent.redraw_node.apply(this, arguments);
            if (obj && this.settings.dnd.use_html5) {
                if (this.settings.dnd.large_drag_target) {
                    obj.setAttribute('draggable', true);
                } else {
                    var i, j, tmp = null;
                    for (i = 0, j = obj.childNodes.length; i < j; i++) {
                        if (obj.childNodes[i] && obj.childNodes[i].className && obj.childNodes[i].className.indexOf("jstree-anchor") !== -1) {
                            tmp = obj.childNodes[i];
                            break;
                        }
                    }
                    if (tmp) {
                        tmp.setAttribute('draggable', true);
                    }
                }
            }
            return obj;
        };
    };

    $(function () {
        // bind only once for all instances
        var lastmv = false,
            laster = false,
            lastev = false,
            opento = false,
            marker = $('<div id="jstree-marker">&#160;</div>').hide(); //.appendTo('body');

        $(document)
            .on('dnd_start.vakata.jstree', function (e, data) {
                lastmv = false;
                lastev = false;
                if (!data || !data.data || !data.data.jstree) { return; }
                marker.appendTo('body'); //.show();
            })
            .on('dnd_move.vakata.jstree', function (e, data) {
                if (opento) {
                    if (!data.event || data.event.type !== 'dragover' || data.event.target !== lastev.target) {
                        clearTimeout(opento);
                    }
                }
                if (!data || !data.data || !data.data.jstree) { return; }

                // if we are hovering the marker image do nothing (can happen on "inside" drags)
                if (data.event.target.id && data.event.target.id === 'jstree-marker') {
                    return;
                }
                lastev = data.event;

                var ins = $.jstree.reference(data.event.target),
                    ref = false,
                    off = false,
                    rel = false,
                    tmp, l, t, h, p, i, o, ok, t1, t2, op, ps, pr, ip, tm, is_copy, pn;
                // if we are over an instance
                if (ins && ins._data && ins._data.dnd) {
                    marker.attr('class', 'jstree-' + ins.get_theme() + (ins.settings.core.themes.responsive ? ' jstree-dnd-responsive' : ''));
                    is_copy = data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey)));
                    data.helper
                        .children().attr('class', 'jstree-' + ins.get_theme() + ' jstree-' + ins.get_theme() + '-' + ins.get_theme_variant() + ' ' + (ins.settings.core.themes.responsive ? ' jstree-dnd-responsive' : ''))
                        .find('.jstree-copy').first()[is_copy ? 'show' : 'hide']();

                    // if are hovering the container itself add a new root node
                    //console.log(data.event);
                    if ((data.event.target === ins.element[0] || data.event.target === ins.get_container_ul()[0]) && ins.get_container_ul().children().length === 0) {
                        ok = true;
                        for (t1 = 0, t2 = data.data.nodes.length; t1 < t2; t1++) {
                            ok = ok && ins.check((data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey))) ? "copy_node" : "move_node"), (data.data.origin && data.data.origin !== ins ? data.data.origin.get_node(data.data.nodes[t1]) : data.data.nodes[t1]), $.jstree.root, 'last', { 'dnd': true, 'ref': ins.get_node($.jstree.root), 'pos': 'i', 'origin': data.data.origin, 'is_multi': (data.data.origin && data.data.origin !== ins), 'is_foreign': (!data.data.origin) });
                            if (!ok) { break; }
                        }
                        if (ok) {
                            lastmv = { 'ins': ins, 'par': $.jstree.root, 'pos': 'last' };
                            marker.hide();
                            data.helper.find('.jstree-icon').first().removeClass('jstree-er').addClass('jstree-ok');
                            if (data.event.originalEvent && data.event.originalEvent.dataTransfer) {
                                data.event.originalEvent.dataTransfer.dropEffect = is_copy ? 'copy' : 'move';
                            }
                            return;
                        }
                    }
                    else {
                        // if we are hovering a tree node
                        ref = ins.settings.dnd.large_drop_target ? $(data.event.target).closest('.jstree-node').children('.jstree-anchor') : $(data.event.target).closest('.jstree-anchor');
                        if (ref && ref.length && ref.parent().is('.jstree-closed, .jstree-open, .jstree-leaf')) {
                            off = ref.offset();
                            rel = (data.event.pageY !== undefined ? data.event.pageY : data.event.originalEvent.pageY) - off.top;
                            h = ref.outerHeight();
                            if (rel < h / 3) {
                                o = ['b', 'i', 'a'];
                            }
                            else if (rel > h - h / 3) {
                                o = ['a', 'i', 'b'];
                            }
                            else {
                                o = rel > h / 2 ? ['i', 'a', 'b'] : ['i', 'b', 'a'];
                            }
                            $.each(o, function (j, v) {
                                switch (v) {
                                    case 'b':
                                        l = off.left - 6;
                                        t = off.top;
                                        p = ins.get_parent(ref);
                                        i = ref.parent().index();
                                        break;
                                    case 'i':
                                        ip = ins.settings.dnd.inside_pos;
                                        tm = ins.get_node(ref.parent());
                                        l = off.left - 2;
                                        t = off.top + h / 2 + 1;
                                        p = tm.id;
                                        i = ip === 'first' ? 0 : (ip === 'last' ? tm.children.length : Math.min(ip, tm.children.length));
                                        break;
                                    case 'a':
                                        l = off.left - 6;
                                        t = off.top + h;
                                        p = ins.get_parent(ref);
                                        i = ref.parent().index() + 1;
                                        break;
                                }
                                ok = true;
                                for (t1 = 0, t2 = data.data.nodes.length; t1 < t2; t1++) {
                                    op = data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey))) ? "copy_node" : "move_node";
                                    ps = i;
                                    if (op === "move_node" && v === 'a' && (data.data.origin && data.data.origin === ins) && p === ins.get_parent(data.data.nodes[t1])) {
                                        pr = ins.get_node(p);
                                        if (ps > $.inArray(data.data.nodes[t1], pr.children)) {
                                            ps -= 1;
                                        }
                                    }
                                    ok = ok && ((ins && ins.settings && ins.settings.dnd && ins.settings.dnd.check_while_dragging === false) || ins.check(op, (data.data.origin && data.data.origin !== ins ? data.data.origin.get_node(data.data.nodes[t1]) : data.data.nodes[t1]), p, ps, { 'dnd': true, 'ref': ins.get_node(ref.parent()), 'pos': v, 'origin': data.data.origin, 'is_multi': (data.data.origin && data.data.origin !== ins), 'is_foreign': (!data.data.origin) }));
                                    if (!ok) {
                                        if (ins && ins.last_error) { laster = ins.last_error(); }
                                        break;
                                    }
                                }
                                if (v === 'i' && ref.parent().is('.jstree-closed') && ins.settings.dnd.open_timeout) {
                                    opento = setTimeout((function (x, z) { return function () { x.open_node(z); }; }(ins, ref)), ins.settings.dnd.open_timeout);
                                }
                                if (ok) {
                                    pn = ins.get_node(p, true);
                                    if (!pn.hasClass('.jstree-dnd-parent')) {
                                        $('.jstree-dnd-parent').removeClass('jstree-dnd-parent');
                                        pn.addClass('jstree-dnd-parent');
                                    }
                                    lastmv = { 'ins': ins, 'par': p, 'pos': v === 'i' && ip === 'last' && i === 0 && !ins.is_loaded(tm) ? 'last' : i };
                                    marker.css({ 'left': l + 'px', 'top': t + 'px' }).show();
                                    data.helper.find('.jstree-icon').first().removeClass('jstree-er').addClass('jstree-ok');
                                    if (data.event.originalEvent && data.event.originalEvent.dataTransfer) {
                                        data.event.originalEvent.dataTransfer.dropEffect = is_copy ? 'copy' : 'move';
                                    }
                                    laster = {};
                                    o = true;
                                    return false;
                                }
                            });
                            if (o === true) { return; }
                        }
                    }
                }
                $('.jstree-dnd-parent').removeClass('jstree-dnd-parent');
                lastmv = false;
                data.helper.find('.jstree-icon').removeClass('jstree-ok').addClass('jstree-er');
                if (data.event.originalEvent && data.event.originalEvent.dataTransfer) {
                    data.event.originalEvent.dataTransfer.dropEffect = 'none';
                }
                marker.hide();
            })
            .on('dnd_scroll.vakata.jstree', function (e, data) {
                if (!data || !data.data || !data.data.jstree) { return; }
                marker.hide();
                lastmv = false;
                lastev = false;
                data.helper.find('.jstree-icon').first().removeClass('jstree-ok').addClass('jstree-er');
            })
            .on('dnd_stop.vakata.jstree', function (e, data) {
                $('.jstree-dnd-parent').removeClass('jstree-dnd-parent');
                if (opento) { clearTimeout(opento); }
                if (!data || !data.data || !data.data.jstree) { return; }
                marker.hide().detach();
                var i, j, nodes = [];
                if (lastmv) {
                    for (i = 0, j = data.data.nodes.length; i < j; i++) {
                        nodes[i] = data.data.origin ? data.data.origin.get_node(data.data.nodes[i]) : data.data.nodes[i];
                    }
                    lastmv.ins[data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (data.event.metaKey || data.event.ctrlKey))) ? 'copy_node' : 'move_node'](nodes, lastmv.par, lastmv.pos, false, false, false, data.data.origin);
                }
                else {
                    i = $(data.event.target).closest('.jstree');
                    if (i.length && laster && laster.error && laster.error === 'check') {
                        i = i.jstree(true);
                        if (i) {
                            i.settings.core.error.call(this, laster);
                        }
                    }
                }
                lastev = false;
                lastmv = false;
            })
            .on('keyup.jstree keydown.jstree', function (e, data) {
                data = $.vakata.dnd._get();
                if (data && data.data && data.data.jstree) {
                    if (e.type === "keyup" && e.which === 27) {
                        if (opento) { clearTimeout(opento); }
                        lastmv = false;
                        laster = false;
                        lastev = false;
                        opento = false;
                        marker.hide().detach();
                        $.vakata.dnd._clean();
                    } else {
                        data.helper.find('.jstree-copy').first()[data.data.origin && (data.data.origin.settings.dnd.always_copy || (data.data.origin.settings.dnd.copy && (e.metaKey || e.ctrlKey))) ? 'show' : 'hide']();
                        if (lastev) {
                            lastev.metaKey = e.metaKey;
                            lastev.ctrlKey = e.ctrlKey;
                            $.vakata.dnd._trigger('move', lastev);
                        }
                    }
                }
            });
    });

    // helpers
    (function ($) {
        $.vakata.html = {
            div: $('<div />'),
            escape: function (str) {
                return $.vakata.html.div.text(str).html();
            },
            strip: function (str) {
                return $.vakata.html.div.empty().append($.parseHTML(str)).text();
            }
        };
        // private variable
        var vakata_dnd = {
            element: false,
            target: false,
            is_down: false,
            is_drag: false,
            helper: false,
            helper_w: 0,
            data: false,
            init_x: 0,
            init_y: 0,
            scroll_l: 0,
            scroll_t: 0,
            scroll_e: false,
            scroll_i: false,
            is_touch: false
        };
        $.vakata.dnd = {
            settings: {
                scroll_speed: 10,
                scroll_proximity: 20,
                helper_left: 5,
                helper_top: 10,
                threshold: 5,
                threshold_touch: 50
            },
            _trigger: function (event_name, e, data) {
                if (data === undefined) {
                    data = $.vakata.dnd._get();
                }
                data.event = e;
                $(document).triggerHandler("dnd_" + event_name + ".vakata", data);
            },
            _get: function () {
                return {
                    "data": vakata_dnd.data,
                    "element": vakata_dnd.element,
                    "helper": vakata_dnd.helper
                };
            },
            _clean: function () {
                if (vakata_dnd.helper) { vakata_dnd.helper.remove(); }
                if (vakata_dnd.scroll_i) { clearInterval(vakata_dnd.scroll_i); vakata_dnd.scroll_i = false; }
                vakata_dnd = {
                    element: false,
                    target: false,
                    is_down: false,
                    is_drag: false,
                    helper: false,
                    helper_w: 0,
                    data: false,
                    init_x: 0,
                    init_y: 0,
                    scroll_l: 0,
                    scroll_t: 0,
                    scroll_e: false,
                    scroll_i: false,
                    is_touch: false
                };
                $(document).off("mousemove.vakata.jstree touchmove.vakata.jstree", $.vakata.dnd.drag);
                $(document).off("mouseup.vakata.jstree touchend.vakata.jstree", $.vakata.dnd.stop);
            },
            _scroll: function (init_only) {
                if (!vakata_dnd.scroll_e || (!vakata_dnd.scroll_l && !vakata_dnd.scroll_t)) {
                    if (vakata_dnd.scroll_i) { clearInterval(vakata_dnd.scroll_i); vakata_dnd.scroll_i = false; }
                    return false;
                }
                if (!vakata_dnd.scroll_i) {
                    vakata_dnd.scroll_i = setInterval($.vakata.dnd._scroll, 100);
                    return false;
                }
                if (init_only === true) { return false; }

                var i = vakata_dnd.scroll_e.scrollTop(),
                    j = vakata_dnd.scroll_e.scrollLeft();
                vakata_dnd.scroll_e.scrollTop(i + vakata_dnd.scroll_t * $.vakata.dnd.settings.scroll_speed);
                vakata_dnd.scroll_e.scrollLeft(j + vakata_dnd.scroll_l * $.vakata.dnd.settings.scroll_speed);
                if (i !== vakata_dnd.scroll_e.scrollTop() || j !== vakata_dnd.scroll_e.scrollLeft()) {
                    /**
                     * triggered on the document when a drag causes an element to scroll
                     * @event
                     * @plugin dnd
                     * @name dnd_scroll.vakata
                     * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start
                     * @param {DOM} element the DOM element being dragged
                     * @param {jQuery} helper the helper shown next to the mouse
                     * @param {jQuery} event the element that is scrolling
                     */
                    $.vakata.dnd._trigger("scroll", vakata_dnd.scroll_e);
                }
            },
            start: function (e, data, html) {
                if (e.type === "touchstart" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {
                    e.pageX = e.originalEvent.changedTouches[0].pageX;
                    e.pageY = e.originalEvent.changedTouches[0].pageY;
                    e.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);
                }
                if (vakata_dnd.is_drag) { $.vakata.dnd.stop({}); }
                try {
                    e.currentTarget.unselectable = "on";
                    e.currentTarget.onselectstart = function () { return false; };
                    if (e.currentTarget.style) {
                        e.currentTarget.style.touchAction = "none";
                        e.currentTarget.style.msTouchAction = "none";
                        e.currentTarget.style.MozUserSelect = "none";
                    }
                } catch (ignore) { }
                vakata_dnd.init_x = e.pageX;
                vakata_dnd.init_y = e.pageY;
                vakata_dnd.data = data;
                vakata_dnd.is_down = true;
                vakata_dnd.element = e.currentTarget;
                vakata_dnd.target = e.target;
                vakata_dnd.is_touch = e.type === "touchstart";
                if (html !== false) {
                    vakata_dnd.helper = $("<div id='vakata-dnd'></div>").html(html).css({
                        "display": "block",
                        "margin": "0",
                        "padding": "0",
                        "position": "absolute",
                        "top": "-2000px",
                        "lineHeight": "16px",
                        "zIndex": "10000"
                    });
                }
                $(document).on("mousemove.vakata.jstree touchmove.vakata.jstree", $.vakata.dnd.drag);
                $(document).on("mouseup.vakata.jstree touchend.vakata.jstree", $.vakata.dnd.stop);
                return false;
            },
            drag: function (e) {
                if (e.type === "touchmove" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {
                    e.pageX = e.originalEvent.changedTouches[0].pageX;
                    e.pageY = e.originalEvent.changedTouches[0].pageY;
                    e.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);
                }
                if (!vakata_dnd.is_down) { return; }
                if (!vakata_dnd.is_drag) {
                    if (
                        Math.abs(e.pageX - vakata_dnd.init_x) > (vakata_dnd.is_touch ? $.vakata.dnd.settings.threshold_touch : $.vakata.dnd.settings.threshold) ||
                        Math.abs(e.pageY - vakata_dnd.init_y) > (vakata_dnd.is_touch ? $.vakata.dnd.settings.threshold_touch : $.vakata.dnd.settings.threshold)
                    ) {
                        if (vakata_dnd.helper) {
                            vakata_dnd.helper.appendTo("body");
                            vakata_dnd.helper_w = vakata_dnd.helper.outerWidth();
                        }
                        vakata_dnd.is_drag = true;
                        $(vakata_dnd.target).one('click.vakata', false);
                        /**
                         * triggered on the document when a drag starts
                         * @event
                         * @plugin dnd
                         * @name dnd_start.vakata
                         * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start
                         * @param {DOM} element the DOM element being dragged
                         * @param {jQuery} helper the helper shown next to the mouse
                         * @param {Object} event the event that caused the start (probably mousemove)
                         */
                        $.vakata.dnd._trigger("start", e);
                    }
                    else { return; }
                }

                var d = false, w = false,
                    dh = false, wh = false,
                    dw = false, ww = false,
                    dt = false, dl = false,
                    ht = false, hl = false;

                vakata_dnd.scroll_t = 0;
                vakata_dnd.scroll_l = 0;
                vakata_dnd.scroll_e = false;
                $($(e.target).parentsUntil("body").addBack().get().reverse())
                    .filter(function () {
                        return (/^auto|scroll$/).test($(this).css("overflow")) &&
                                (this.scrollHeight > this.offsetHeight || this.scrollWidth > this.offsetWidth);
                    })
                    .each(function () {
                        var t = $(this), o = t.offset();
                        if (this.scrollHeight > this.offsetHeight) {
                            if (o.top + t.height() - e.pageY < $.vakata.dnd.settings.scroll_proximity) { vakata_dnd.scroll_t = 1; }
                            if (e.pageY - o.top < $.vakata.dnd.settings.scroll_proximity) { vakata_dnd.scroll_t = -1; }
                        }
                        if (this.scrollWidth > this.offsetWidth) {
                            if (o.left + t.width() - e.pageX < $.vakata.dnd.settings.scroll_proximity) { vakata_dnd.scroll_l = 1; }
                            if (e.pageX - o.left < $.vakata.dnd.settings.scroll_proximity) { vakata_dnd.scroll_l = -1; }
                        }
                        if (vakata_dnd.scroll_t || vakata_dnd.scroll_l) {
                            vakata_dnd.scroll_e = $(this);
                            return false;
                        }
                    });

                if (!vakata_dnd.scroll_e) {
                    d = $(document); w = $(window);
                    dh = d.height(); wh = w.height();
                    dw = d.width(); ww = w.width();
                    dt = d.scrollTop(); dl = d.scrollLeft();
                    if (dh > wh && e.pageY - dt < $.vakata.dnd.settings.scroll_proximity) { vakata_dnd.scroll_t = -1; }
                    if (dh > wh && wh - (e.pageY - dt) < $.vakata.dnd.settings.scroll_proximity) { vakata_dnd.scroll_t = 1; }
                    if (dw > ww && e.pageX - dl < $.vakata.dnd.settings.scroll_proximity) { vakata_dnd.scroll_l = -1; }
                    if (dw > ww && ww - (e.pageX - dl) < $.vakata.dnd.settings.scroll_proximity) { vakata_dnd.scroll_l = 1; }
                    if (vakata_dnd.scroll_t || vakata_dnd.scroll_l) {
                        vakata_dnd.scroll_e = d;
                    }
                }
                if (vakata_dnd.scroll_e) { $.vakata.dnd._scroll(true); }

                if (vakata_dnd.helper) {
                    ht = parseInt(e.pageY + $.vakata.dnd.settings.helper_top, 10);
                    hl = parseInt(e.pageX + $.vakata.dnd.settings.helper_left, 10);
                    if (dh && ht + 25 > dh) { ht = dh - 50; }
                    if (dw && hl + vakata_dnd.helper_w > dw) { hl = dw - (vakata_dnd.helper_w + 2); }
                    vakata_dnd.helper.css({
                        left: hl + "px",
                        top: ht + "px"
                    });
                }
                /**
                 * triggered on the document when a drag is in progress
                 * @event
                 * @plugin dnd
                 * @name dnd_move.vakata
                 * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start
                 * @param {DOM} element the DOM element being dragged
                 * @param {jQuery} helper the helper shown next to the mouse
                 * @param {Object} event the event that caused this to trigger (most likely mousemove)
                 */
                $.vakata.dnd._trigger("move", e);
                return false;
            },
            stop: function (e) {
                if (e.type === "touchend" && e.originalEvent && e.originalEvent.changedTouches && e.originalEvent.changedTouches[0]) {
                    e.pageX = e.originalEvent.changedTouches[0].pageX;
                    e.pageY = e.originalEvent.changedTouches[0].pageY;
                    e.target = document.elementFromPoint(e.originalEvent.changedTouches[0].pageX - window.pageXOffset, e.originalEvent.changedTouches[0].pageY - window.pageYOffset);
                }
                if (vakata_dnd.is_drag) {
                    /**
                     * triggered on the document when a drag stops (the dragged element is dropped)
                     * @event
                     * @plugin dnd
                     * @name dnd_stop.vakata
                     * @param {Mixed} data any data supplied with the call to $.vakata.dnd.start
                     * @param {DOM} element the DOM element being dragged
                     * @param {jQuery} helper the helper shown next to the mouse
                     * @param {Object} event the event that caused the stop
                     */
                    if (e.target !== vakata_dnd.target) {
                        $(vakata_dnd.target).off('click.vakata');
                    }
                    $.vakata.dnd._trigger("stop", e);
                }
                else {
                    if (e.type === "touchend" && e.target === vakata_dnd.target) {
                        var to = setTimeout(function () { $(e.target).click(); }, 100);
                        $(e.target).one('click', function () { if (to) { clearTimeout(to); } });
                    }
                }
                $.vakata.dnd._clean();
                return false;
            }
        };
    }($));

    // include the dnd plugin by default
    // $.jstree.defaults.plugins.push("dnd");


    /**
     * ### Massload plugin
     *
     * Adds massload functionality to jsTree, so that multiple nodes can be loaded in a single request (only useful with lazy loading).
     */

    /**
     * massload configuration
     *
     * It is possible to set this to a standard jQuery-like AJAX config.
     * In addition to the standard jQuery ajax options here you can supply functions for `data` and `url`, the functions will be run in the current instance's scope and a param will be passed indicating which node IDs need to be loaded, the return value of those functions will be used.
     *
     * You can also set this to a function, that function will receive the node IDs being loaded as argument and a second param which is a function (callback) which should be called with the result.
     *
     * Both the AJAX and the function approach rely on the same return value - an object where the keys are the node IDs, and the value is the children of that node as an array.
     *
     *	{
     *		"id1" : [{ "text" : "Child of ID1", "id" : "c1" }, { "text" : "Another child of ID1", "id" : "c2" }],
     *		"id2" : [{ "text" : "Child of ID2", "id" : "c3" }]
     *	}
     * 
     * @name $.jstree.defaults.massload
     * @plugin massload
     */
    $.jstree.defaults.massload = null;
    $.jstree.plugins.massload = function (options, parent) {
        this.init = function (el, options) {
            this._data.massload = {};
            parent.init.call(this, el, options);
        };
        this._load_nodes = function (nodes, callback, is_callback, force_reload) {
            var s = this.settings.massload,
                nodesString = JSON.stringify(nodes),
                toLoad = [],
                m = this._model.data,
                i, j, dom;
            if (!is_callback) {
                for (i = 0, j = nodes.length; i < j; i++) {
                    if (!m[nodes[i]] || ((!m[nodes[i]].state.loaded && !m[nodes[i]].state.failed) || force_reload)) {
                        toLoad.push(nodes[i]);
                        dom = this.get_node(nodes[i], true);
                        if (dom && dom.length) {
                            dom.addClass("jstree-loading").attr('aria-busy', true);
                        }
                    }
                }
                this._data.massload = {};
                if (toLoad.length) {
                    if ($.isFunction(s)) {
                        return s.call(this, toLoad, $.proxy(function (data) {
                            var i, j;
                            if (data) {
                                for (i in data) {
                                    if (data.hasOwnProperty(i)) {
                                        this._data.massload[i] = data[i];
                                    }
                                }
                            }
                            for (i = 0, j = nodes.length; i < j; i++) {
                                dom = this.get_node(nodes[i], true);
                                if (dom && dom.length) {
                                    dom.removeClass("jstree-loading").attr('aria-busy', false);
                                }
                            }
                            parent._load_nodes.call(this, nodes, callback, is_callback, force_reload);
                        }, this));
                    }
                    if (typeof s === 'object' && s && s.url) {
                        s = $.extend(true, {}, s);
                        if ($.isFunction(s.url)) {
                            s.url = s.url.call(this, toLoad);
                        }
                        if ($.isFunction(s.data)) {
                            s.data = s.data.call(this, toLoad);
                        }
                        return $.ajax(s)
                            .done($.proxy(function (data, t, x) {
                                var i, j;
                                if (data) {
                                    for (i in data) {
                                        if (data.hasOwnProperty(i)) {
                                            this._data.massload[i] = data[i];
                                        }
                                    }
                                }
                                for (i = 0, j = nodes.length; i < j; i++) {
                                    dom = this.get_node(nodes[i], true);
                                    if (dom && dom.length) {
                                        dom.removeClass("jstree-loading").attr('aria-busy', false);
                                    }
                                }
                                parent._load_nodes.call(this, nodes, callback, is_callback, force_reload);
                            }, this))
                            .fail($.proxy(function (f) {
                                parent._load_nodes.call(this, nodes, callback, is_callback, force_reload);
                            }, this));
                    }
                }
            }
            return parent._load_nodes.call(this, nodes, callback, is_callback, force_reload);
        };
        this._load_node = function (obj, callback) {
            var data = this._data.massload[obj.id],
                rslt = null, dom;
            if (data) {
                rslt = this[typeof data === 'string' ? '_append_html_data' : '_append_json_data'](
                    obj,
                    typeof data === 'string' ? $($.parseHTML(data)).filter(function () { return this.nodeType !== 3; }) : data,
                    function (status) { callback.call(this, status); }
                );
                dom = this.get_node(obj.id, true);
                if (dom && dom.length) {
                    dom.removeClass("jstree-loading").attr('aria-busy', false);
                }
                delete this._data.massload[obj.id];
                return rslt;
            }
            return parent._load_node.call(this, obj, callback);
        };
    };

    /**
     * ### Search plugin
     *
     * Adds search functionality to jsTree.
     */

    /**
     * stores all defaults for the search plugin
     * @name $.jstree.defaults.search
     * @plugin search
     */
    $.jstree.defaults.search = {
        /**
         * a jQuery-like AJAX config, which jstree uses if a server should be queried for results.
         *
         * A `str` (which is the search string) parameter will be added with the request, an optional `inside` parameter will be added if the search is limited to a node id. The expected result is a JSON array with nodes that need to be opened so that matching nodes will be revealed.
         * Leave this setting as `false` to not query the server. You can also set this to a function, which will be invoked in the instance's scope and receive 3 parameters - the search string, the callback to call with the array of nodes to load, and the optional node ID to limit the search to
         * @name $.jstree.defaults.search.ajax
         * @plugin search
         */
        ajax: false,
        /**
         * Indicates if the search should be fuzzy or not (should `chnd3` match `child node 3`). Default is `false`.
         * @name $.jstree.defaults.search.fuzzy
         * @plugin search
         */
        fuzzy: false,
        /**
         * Indicates if the search should be case sensitive. Default is `false`.
         * @name $.jstree.defaults.search.case_sensitive
         * @plugin search
         */
        case_sensitive: false,
        /**
         * Indicates if the tree should be filtered (by default) to show only matching nodes (keep in mind this can be a heavy on large trees in old browsers).
         * This setting can be changed at runtime when calling the search method. Default is `false`.
         * @name $.jstree.defaults.search.show_only_matches
         * @plugin search
         */
        show_only_matches: false,
        /**
         * Indicates if the children of matched element are shown (when show_only_matches is true)
         * This setting can be changed at runtime when calling the search method. Default is `false`.
         * @name $.jstree.defaults.search.show_only_matches_children
         * @plugin search
         */
        show_only_matches_children: false,
        /**
         * Indicates if all nodes opened to reveal the search result, should be closed when the search is cleared or a new search is performed. Default is `true`.
         * @name $.jstree.defaults.search.close_opened_onclear
         * @plugin search
         */
        close_opened_onclear: true,
        /**
         * Indicates if only leaf nodes should be included in search results. Default is `false`.
         * @name $.jstree.defaults.search.search_leaves_only
         * @plugin search
         */
        search_leaves_only: false,
        /**
         * If set to a function it wil be called in the instance's scope with two arguments - search string and node (where node will be every node in the structure, so use with caution).
         * If the function returns a truthy value the node will be considered a match (it might not be displayed if search_only_leaves is set to true and the node is not a leaf). Default is `false`.
         * @name $.jstree.defaults.search.search_callback
         * @plugin search
         */
        search_callback: false
    };

    $.jstree.plugins.search = function (options, parent) {
        this.bind = function () {
            parent.bind.call(this);

            this._data.search.str = "";
            this._data.search.dom = $();
            this._data.search.res = [];
            this._data.search.opn = [];
            this._data.search.som = false;
            this._data.search.smc = false;
            this._data.search.hdn = [];

            this.element
                .on("search.jstree", $.proxy(function (e, data) {
                    if (this._data.search.som && data.res.length) {
                        var m = this._model.data, i, j, p = [], k, l;
                        for (i = 0, j = data.res.length; i < j; i++) {
                            if (m[data.res[i]] && !m[data.res[i]].state.hidden) {
                                p.push(data.res[i]);
                                p = p.concat(m[data.res[i]].parents);
                                if (this._data.search.smc) {
                                    for (k = 0, l = m[data.res[i]].children_d.length; k < l; k++) {
                                        if (m[m[data.res[i]].children_d[k]] && !m[m[data.res[i]].children_d[k]].state.hidden) {
                                            p.push(m[data.res[i]].children_d[k]);
                                        }
                                    }
                                }
                            }
                        }
                        p = $.vakata.array_remove_item($.vakata.array_unique(p), $.jstree.root);
                        this._data.search.hdn = this.hide_all(true);
                        this.show_node(p, true);
                        this.redraw(true);
                    }
                }, this))
                .on("clear_search.jstree", $.proxy(function (e, data) {
                    if (this._data.search.som && data.res.length) {
                        this.show_node(this._data.search.hdn, true);
                        this.redraw(true);
                    }
                }, this));
        };
        /**
         * used to search the tree nodes for a given string
         * @name search(str [, skip_async])
         * @param {String} str the search string
         * @param {Boolean} skip_async if set to true server will not be queried even if configured
         * @param {Boolean} show_only_matches if set to true only matching nodes will be shown (keep in mind this can be very slow on large trees or old browsers)
         * @param {mixed} inside an optional node to whose children to limit the search
         * @param {Boolean} append if set to true the results of this search are appended to the previous search
         * @plugin search
         * @trigger search.jstree
         */
        this.search = function (str, skip_async, show_only_matches, inside, append, show_only_matches_children) {
            if (str === false || $.trim(str.toString()) === "") {
                return this.clear_search();
            }
            inside = this.get_node(inside);
            inside = inside && inside.id ? inside.id : null;
            str = str.toString();
            var s = this.settings.search,
                a = s.ajax ? s.ajax : false,
                m = this._model.data,
                f = null,
                r = [],
                p = [], i, j;
            if (this._data.search.res.length && !append) {
                this.clear_search();
            }
            if (show_only_matches === undefined) {
                show_only_matches = s.show_only_matches;
            }
            if (show_only_matches_children === undefined) {
                show_only_matches_children = s.show_only_matches_children;
            }
            if (!skip_async && a !== false) {
                if ($.isFunction(a)) {
                    return a.call(this, str, $.proxy(function (d) {
                        if (d && d.d) { d = d.d; }
                        this._load_nodes(!$.isArray(d) ? [] : $.vakata.array_unique(d), function () {
                            this.search(str, true, show_only_matches, inside, append, show_only_matches_children);
                        });
                    }, this), inside);
                }
                else {
                    a = $.extend({}, a);
                    if (!a.data) { a.data = {}; }
                    a.data.str = str;
                    if (inside) {
                        a.data.inside = inside;
                    }
                    if (this._data.search.lastRequest) {
                        this._data.search.lastRequest.abort();
                    }
                    this._data.search.lastRequest = $.ajax(a)
                        .fail($.proxy(function () {
                            this._data.core.last_error = { 'error': 'ajax', 'plugin': 'search', 'id': 'search_01', 'reason': 'Could not load search parents', 'data': JSON.stringify(a) };
                            this.settings.core.error.call(this, this._data.core.last_error);
                        }, this))
                        .done($.proxy(function (d) {
                            if (d && d.d) { d = d.d; }
                            this._load_nodes(!$.isArray(d) ? [] : $.vakata.array_unique(d), function () {
                                this.search(str, true, show_only_matches, inside, append, show_only_matches_children);
                            });
                        }, this));
                    return this._data.search.lastRequest;
                }
            }
            if (!append) {
                this._data.search.str = str;
                this._data.search.dom = $();
                this._data.search.res = [];
                this._data.search.opn = [];
                this._data.search.som = show_only_matches;
                this._data.search.smc = show_only_matches_children;
            }

            f = new $.vakata.search(str, true, { caseSensitive: s.case_sensitive, fuzzy: s.fuzzy });
            $.each(m[inside ? inside : $.jstree.root].children_d, function (ii, i) {
                var v = m[i];
                if (v.text && !v.state.hidden && (!s.search_leaves_only || (v.state.loaded && v.children.length === 0)) && ((s.search_callback && s.search_callback.call(this, str, v)) || (!s.search_callback && f.search(v.text).isMatch))) {
                    r.push(i);
                    p = p.concat(v.parents);
                }
            });
            if (r.length) {
                p = $.vakata.array_unique(p);
                for (i = 0, j = p.length; i < j; i++) {
                    if (p[i] !== $.jstree.root && m[p[i]] && this.open_node(p[i], null, 0) === true) {
                        this._data.search.opn.push(p[i]);
                    }
                }
                if (!append) {
                    this._data.search.dom = $(this.element[0].querySelectorAll('#' + $.map(r, function (v) { return "0123456789".indexOf(v[0]) !== -1 ? '\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex, '\\$&') : v.replace($.jstree.idregex, '\\$&'); }).join(', #')));
                    this._data.search.res = r;
                }
                else {
                    this._data.search.dom = this._data.search.dom.add($(this.element[0].querySelectorAll('#' + $.map(r, function (v) { return "0123456789".indexOf(v[0]) !== -1 ? '\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex, '\\$&') : v.replace($.jstree.idregex, '\\$&'); }).join(', #'))));
                    this._data.search.res = $.vakata.array_unique(this._data.search.res.concat(r));
                }
                this._data.search.dom.children(".jstree-anchor").addClass('jstree-search');
            }
            /**
             * triggered after search is complete
             * @event
             * @name search.jstree
             * @param {jQuery} nodes a jQuery collection of matching nodes
             * @param {String} str the search string
             * @param {Array} res a collection of objects represeing the matching nodes
             * @plugin search
             */
            this.trigger('search', { nodes: this._data.search.dom, str: str, res: this._data.search.res, show_only_matches: show_only_matches });
        };
        /**
         * used to clear the last search (removes classes and shows all nodes if filtering is on)
         * @name clear_search()
         * @plugin search
         * @trigger clear_search.jstree
         */
        this.clear_search = function () {
            if (this.settings.search.close_opened_onclear) {
                this.close_node(this._data.search.opn, 0);
            }
            /**
             * triggered after search is complete
             * @event
             * @name clear_search.jstree
             * @param {jQuery} nodes a jQuery collection of matching nodes (the result from the last search)
             * @param {String} str the search string (the last search string)
             * @param {Array} res a collection of objects represeing the matching nodes (the result from the last search)
             * @plugin search
             */
            this.trigger('clear_search', { 'nodes': this._data.search.dom, str: this._data.search.str, res: this._data.search.res });
            if (this._data.search.res.length) {
                this._data.search.dom = $(this.element[0].querySelectorAll('#' + $.map(this._data.search.res, function (v) {
                    return "0123456789".indexOf(v[0]) !== -1 ? '\\3' + v[0] + ' ' + v.substr(1).replace($.jstree.idregex, '\\$&') : v.replace($.jstree.idregex, '\\$&');
                }).join(', #')));
                this._data.search.dom.children(".jstree-anchor").removeClass("jstree-search");
            }
            this._data.search.str = "";
            this._data.search.res = [];
            this._data.search.opn = [];
            this._data.search.dom = $();
        };

        this.redraw_node = function (obj, deep, callback, force_render) {
            obj = parent.redraw_node.apply(this, arguments);
            if (obj) {
                if ($.inArray(obj.id, this._data.search.res) !== -1) {
                    var i, j, tmp = null;
                    for (i = 0, j = obj.childNodes.length; i < j; i++) {
                        if (obj.childNodes[i] && obj.childNodes[i].className && obj.childNodes[i].className.indexOf("jstree-anchor") !== -1) {
                            tmp = obj.childNodes[i];
                            break;
                        }
                    }
                    if (tmp) {
                        tmp.className += ' jstree-search';
                    }
                }
            }
            return obj;
        };
    };

    // helpers
    (function ($) {
        // from http://kiro.me/projects/fuse.html
        $.vakata.search = function (pattern, txt, options) {
            options = options || {};
            options = $.extend({}, $.vakata.search.defaults, options);
            if (options.fuzzy !== false) {
                options.fuzzy = true;
            }
            pattern = options.caseSensitive ? pattern : pattern.toLowerCase();
            var MATCH_LOCATION = options.location,
                MATCH_DISTANCE = options.distance,
                MATCH_THRESHOLD = options.threshold,
                patternLen = pattern.length,
                matchmask, pattern_alphabet, match_bitapScore, search;
            if (patternLen > 32) {
                options.fuzzy = false;
            }
            if (options.fuzzy) {
                matchmask = 1 << (patternLen - 1);
                pattern_alphabet = (function () {
                    var mask = {},
                        i = 0;
                    for (i = 0; i < patternLen; i++) {
                        mask[pattern.charAt(i)] = 0;
                    }
                    for (i = 0; i < patternLen; i++) {
                        mask[pattern.charAt(i)] |= 1 << (patternLen - i - 1);
                    }
                    return mask;
                }());
                match_bitapScore = function (e, x) {
                    var accuracy = e / patternLen,
                        proximity = Math.abs(MATCH_LOCATION - x);
                    if (!MATCH_DISTANCE) {
                        return proximity ? 1.0 : accuracy;
                    }
                    return accuracy + (proximity / MATCH_DISTANCE);
                };
            }
            search = function (text) {
                text = options.caseSensitive ? text : text.toLowerCase();
                if (pattern === text || text.indexOf(pattern) !== -1) {
                    return {
                        isMatch: true,
                        score: 0
                    };
                }
                if (!options.fuzzy) {
                    return {
                        isMatch: false,
                        score: 1
                    };
                }
                var i, j,
                    textLen = text.length,
                    scoreThreshold = MATCH_THRESHOLD,
                    bestLoc = text.indexOf(pattern, MATCH_LOCATION),
                    binMin, binMid,
                    binMax = patternLen + textLen,
                    lastRd, start, finish, rd, charMatch,
                    score = 1,
                    locations = [];
                if (bestLoc !== -1) {
                    scoreThreshold = Math.min(match_bitapScore(0, bestLoc), scoreThreshold);
                    bestLoc = text.lastIndexOf(pattern, MATCH_LOCATION + patternLen);
                    if (bestLoc !== -1) {
                        scoreThreshold = Math.min(match_bitapScore(0, bestLoc), scoreThreshold);
                    }
                }
                bestLoc = -1;
                for (i = 0; i < patternLen; i++) {
                    binMin = 0;
                    binMid = binMax;
                    while (binMin < binMid) {
                        if (match_bitapScore(i, MATCH_LOCATION + binMid) <= scoreThreshold) {
                            binMin = binMid;
                        } else {
                            binMax = binMid;
                        }
                        binMid = Math.floor((binMax - binMin) / 2 + binMin);
                    }
                    binMax = binMid;
                    start = Math.max(1, MATCH_LOCATION - binMid + 1);
                    finish = Math.min(MATCH_LOCATION + binMid, textLen) + patternLen;
                    rd = new Array(finish + 2);
                    rd[finish + 1] = (1 << i) - 1;
                    for (j = finish; j >= start; j--) {
                        charMatch = pattern_alphabet[text.charAt(j - 1)];
                        if (i === 0) {
                            rd[j] = ((rd[j + 1] << 1) | 1) & charMatch;
                        } else {
                            rd[j] = ((rd[j + 1] << 1) | 1) & charMatch | (((lastRd[j + 1] | lastRd[j]) << 1) | 1) | lastRd[j + 1];
                        }
                        if (rd[j] & matchmask) {
                            score = match_bitapScore(i, j - 1);
                            if (score <= scoreThreshold) {
                                scoreThreshold = score;
                                bestLoc = j - 1;
                                locations.push(bestLoc);
                                if (bestLoc > MATCH_LOCATION) {
                                    start = Math.max(1, 2 * MATCH_LOCATION - bestLoc);
                                } else {
                                    break;
                                }
                            }
                        }
                    }
                    if (match_bitapScore(i + 1, MATCH_LOCATION) > scoreThreshold) {
                        break;
                    }
                    lastRd = rd;
                }
                return {
                    isMatch: bestLoc >= 0,
                    score: score
                };
            };
            return txt === true ? { 'search': search } : search(txt);
        };
        $.vakata.search.defaults = {
            location: 0,
            distance: 100,
            threshold: 0.6,
            fuzzy: false,
            caseSensitive: false
        };
    }($));

    // include the search plugin by default
    // $.jstree.defaults.plugins.push("search");


    /**
     * ### Sort plugin
     *
     * Automatically sorts all siblings in the tree according to a sorting function.
     */

    /**
     * the settings function used to sort the nodes.
     * It is executed in the tree's context, accepts two nodes as arguments and should return `1` or `-1`.
     * @name $.jstree.defaults.sort
     * @plugin sort
     */
    $.jstree.defaults.sort = function (a, b) {
        //return this.get_type(a) === this.get_type(b) ? (this.get_text(a) > this.get_text(b) ? 1 : -1) : this.get_type(a) >= this.get_type(b);
        return this.get_text(a) > this.get_text(b) ? 1 : -1;
    };
    $.jstree.plugins.sort = function (options, parent) {
        this.bind = function () {
            parent.bind.call(this);
            this.element
                .on("model.jstree", $.proxy(function (e, data) {
                    this.sort(data.parent, true);
                }, this))
                .on("rename_node.jstree create_node.jstree", $.proxy(function (e, data) {
                    this.sort(data.parent || data.node.parent, false);
                    this.redraw_node(data.parent || data.node.parent, true);
                }, this))
                .on("move_node.jstree copy_node.jstree", $.proxy(function (e, data) {
                    this.sort(data.parent, false);
                    this.redraw_node(data.parent, true);
                }, this));
        };
        /**
         * used to sort a node's children
         * @private
         * @name sort(obj [, deep])
         * @param  {mixed} obj the node
         * @param {Boolean} deep if set to `true` nodes are sorted recursively.
         * @plugin sort
         * @trigger search.jstree
         */
        this.sort = function (obj, deep) {
            var i, j;
            obj = this.get_node(obj);
            if (obj && obj.children && obj.children.length) {
                obj.children.sort($.proxy(this.settings.sort, this));
                if (deep) {
                    for (i = 0, j = obj.children_d.length; i < j; i++) {
                        this.sort(obj.children_d[i], false);
                    }
                }
            }
        };
    };

    // include the sort plugin by default
    // $.jstree.defaults.plugins.push("sort");

    /**
     * ### State plugin
     *
     * Saves the state of the tree (selected nodes, opened nodes) on the user's computer using available options (localStorage, cookies, etc)
     */

    var to = false;
    /**
     * stores all defaults for the state plugin
     * @name $.jstree.defaults.state
     * @plugin state
     */
    $.jstree.defaults.state = {
        /**
         * A string for the key to use when saving the current tree (change if using multiple trees in your project). Defaults to `jstree`.
         * @name $.jstree.defaults.state.key
         * @plugin state
         */
        key: 'jstree',
        /**
         * A space separated list of events that trigger a state save. Defaults to `changed.jstree open_node.jstree close_node.jstree`.
         * @name $.jstree.defaults.state.events
         * @plugin state
         */
        events: 'changed.jstree open_node.jstree close_node.jstree check_node.jstree uncheck_node.jstree',
        /**
         * Time in milliseconds after which the state will expire. Defaults to 'false' meaning - no expire.
         * @name $.jstree.defaults.state.ttl
         * @plugin state
         */
        ttl: false,
        /**
         * A function that will be executed prior to restoring state with one argument - the state object. Can be used to clear unwanted parts of the state.
         * @name $.jstree.defaults.state.filter
         * @plugin state
         */
        filter: false
    };
    $.jstree.plugins.state = function (options, parent) {
        this.bind = function () {
            parent.bind.call(this);
            var bind = $.proxy(function () {
                this.element.on(this.settings.state.events, $.proxy(function () {
                    if (to) { clearTimeout(to); }
                    to = setTimeout($.proxy(function () { this.save_state(); }, this), 100);
                }, this));
                /**
                 * triggered when the state plugin is finished restoring the state (and immediately after ready if there is no state to restore).
                 * @event
                 * @name state_ready.jstree
                 * @plugin state
                 */
                this.trigger('state_ready');
            }, this);
            this.element
                .on("ready.jstree", $.proxy(function (e, data) {
                    this.element.one("restore_state.jstree", bind);
                    if (!this.restore_state()) { bind(); }
                }, this));
        };
        /**
         * save the state
         * @name save_state()
         * @plugin state
         */
        this.save_state = function () {
            var st = { 'state': this.get_state(), 'ttl': this.settings.state.ttl, 'sec': +(new Date()) };
            $.vakata.storage.set(this.settings.state.key, JSON.stringify(st));
        };
        /**
         * restore the state from the user's computer
         * @name restore_state()
         * @plugin state
         */
        this.restore_state = function () {
            var k = $.vakata.storage.get(this.settings.state.key);
            if (!!k) { try { k = JSON.parse(k); } catch (ex) { return false; } }
            if (!!k && k.ttl && k.sec && +(new Date()) - k.sec > k.ttl) { return false; }
            if (!!k && k.state) { k = k.state; }
            if (!!k && $.isFunction(this.settings.state.filter)) { k = this.settings.state.filter.call(this, k); }
            if (!!k) {
                this.element.one("set_state.jstree", function (e, data) { data.instance.trigger('restore_state', { 'state': $.extend(true, {}, k) }); });
                this.set_state(k);
                return true;
            }
            return false;
        };
        /**
         * clear the state on the user's computer
         * @name clear_state()
         * @plugin state
         */
        this.clear_state = function () {
            return $.vakata.storage.del(this.settings.state.key);
        };
    };

    (function ($, undefined) {
        $.vakata.storage = {
            // simply specifying the functions in FF throws an error
            set: function (key, val) { return window.localStorage.setItem(key, val); },
            get: function (key) { return window.localStorage.getItem(key); },
            del: function (key) { return window.localStorage.removeItem(key); }
        };
    }($));

    // include the state plugin by default
    // $.jstree.defaults.plugins.push("state");

    /**
     * ### Types plugin
     *
     * Makes it possible to add predefined types for groups of nodes, which make it possible to easily control nesting rules and icon for each group.
     */

    /**
     * An object storing all types as key value pairs, where the key is the type name and the value is an object that could contain following keys (all optional).
     *
     * * `max_children` the maximum number of immediate children this node type can have. Do not specify or set to `-1` for unlimited.
     * * `max_depth` the maximum number of nesting this node type can have. A value of `1` would mean that the node can have children, but no grandchildren. Do not specify or set to `-1` for unlimited.
     * * `valid_children` an array of node type strings, that nodes of this type can have as children. Do not specify or set to `-1` for no limits.
     * * `icon` a string - can be a path to an icon or a className, if using an image that is in the current directory use a `./` prefix, otherwise it will be detected as a class. Omit to use the default icon from your theme.
     * * `li_attr` an object of values which will be used to add HTML attributes on the resulting LI DOM node (merged with the node's own data)
     * * `a_attr` an object of values which will be used to add HTML attributes on the resulting A DOM node (merged with the node's own data)
     *
     * There are two predefined types:
     *
     * * `#` represents the root of the tree, for example `max_children` would control the maximum number of root nodes.
     * * `default` represents the default node - any settings here will be applied to all nodes that do not have a type specified.
     *
     * @name $.jstree.defaults.types
     * @plugin types
     */
    $.jstree.defaults.types = {
        'default': {}
    };
    $.jstree.defaults.types[$.jstree.root] = {};

    $.jstree.plugins.types = function (options, parent) {
        this.init = function (el, options) {
            var i, j;
            if (options && options.types && options.types['default']) {
                for (i in options.types) {
                    if (i !== "default" && i !== $.jstree.root && options.types.hasOwnProperty(i)) {
                        for (j in options.types['default']) {
                            if (options.types['default'].hasOwnProperty(j) && options.types[i][j] === undefined) {
                                options.types[i][j] = options.types['default'][j];
                            }
                        }
                    }
                }
            }
            parent.init.call(this, el, options);
            this._model.data[$.jstree.root].type = $.jstree.root;
        };
        this.refresh = function (skip_loading, forget_state) {
            parent.refresh.call(this, skip_loading, forget_state);
            this._model.data[$.jstree.root].type = $.jstree.root;
        };
        this.bind = function () {
            this.element
                .on('model.jstree', $.proxy(function (e, data) {
                    var m = this._model.data,
                        dpc = data.nodes,
                        t = this.settings.types,
                        i, j, c = 'default', k;
                    for (i = 0, j = dpc.length; i < j; i++) {
                        c = 'default';
                        if (m[dpc[i]].original && m[dpc[i]].original.type && t[m[dpc[i]].original.type]) {
                            c = m[dpc[i]].original.type;
                        }
                        if (m[dpc[i]].data && m[dpc[i]].data.jstree && m[dpc[i]].data.jstree.type && t[m[dpc[i]].data.jstree.type]) {
                            c = m[dpc[i]].data.jstree.type;
                        }
                        m[dpc[i]].type = c;
                        if (m[dpc[i]].icon === true && t[c].icon !== undefined) {
                            m[dpc[i]].icon = t[c].icon;
                        }
                        if (t[c].li_attr !== undefined && typeof t[c].li_attr === 'object') {
                            for (k in t[c].li_attr) {
                                if (t[c].li_attr.hasOwnProperty(k)) {
                                    if (k === 'id') {
                                        continue;
                                    }
                                    else if (m[dpc[i]].li_attr[k] === undefined) {
                                        m[dpc[i]].li_attr[k] = t[c].li_attr[k];
                                    }
                                    else if (k === 'class') {
                                        m[dpc[i]].li_attr['class'] = t[c].li_attr['class'] + ' ' + m[dpc[i]].li_attr['class'];
                                    }
                                }
                            }
                        }
                        if (t[c].a_attr !== undefined && typeof t[c].a_attr === 'object') {
                            for (k in t[c].a_attr) {
                                if (t[c].a_attr.hasOwnProperty(k)) {
                                    if (k === 'id') {
                                        continue;
                                    }
                                    else if (m[dpc[i]].a_attr[k] === undefined) {
                                        m[dpc[i]].a_attr[k] = t[c].a_attr[k];
                                    }
                                    else if (k === 'href' && m[dpc[i]].a_attr[k] === '#') {
                                        m[dpc[i]].a_attr['href'] = t[c].a_attr['href'];
                                    }
                                    else if (k === 'class') {
                                        m[dpc[i]].a_attr['class'] = t[c].a_attr['class'] + ' ' + m[dpc[i]].a_attr['class'];
                                    }
                                }
                            }
                        }
                    }
                    m[$.jstree.root].type = $.jstree.root;
                }, this));
            parent.bind.call(this);
        };
        this.get_json = function (obj, options, flat) {
            var i, j,
                m = this._model.data,
                opt = options ? $.extend(true, {}, options, { no_id: false }) : {},
                tmp = parent.get_json.call(this, obj, opt, flat);
            if (tmp === false) { return false; }
            if ($.isArray(tmp)) {
                for (i = 0, j = tmp.length; i < j; i++) {
                    tmp[i].type = tmp[i].id && m[tmp[i].id] && m[tmp[i].id].type ? m[tmp[i].id].type : "default";
                    if (options && options.no_id) {
                        delete tmp[i].id;
                        if (tmp[i].li_attr && tmp[i].li_attr.id) {
                            delete tmp[i].li_attr.id;
                        }
                        if (tmp[i].a_attr && tmp[i].a_attr.id) {
                            delete tmp[i].a_attr.id;
                        }
                    }
                }
            }
            else {
                tmp.type = tmp.id && m[tmp.id] && m[tmp.id].type ? m[tmp.id].type : "default";
                if (options && options.no_id) {
                    tmp = this._delete_ids(tmp);
                }
            }
            return tmp;
        };
        this._delete_ids = function (tmp) {
            if ($.isArray(tmp)) {
                for (var i = 0, j = tmp.length; i < j; i++) {
                    tmp[i] = this._delete_ids(tmp[i]);
                }
                return tmp;
            }
            delete tmp.id;
            if (tmp.li_attr && tmp.li_attr.id) {
                delete tmp.li_attr.id;
            }
            if (tmp.a_attr && tmp.a_attr.id) {
                delete tmp.a_attr.id;
            }
            if (tmp.children && $.isArray(tmp.children)) {
                tmp.children = this._delete_ids(tmp.children);
            }
            return tmp;
        };
        this.check = function (chk, obj, par, pos, more) {
            if (parent.check.call(this, chk, obj, par, pos, more) === false) { return false; }
            obj = obj && obj.id ? obj : this.get_node(obj);
            par = par && par.id ? par : this.get_node(par);
            var m = obj && obj.id ? (more && more.origin ? more.origin : $.jstree.reference(obj.id)) : null, tmp, d, i, j;
            m = m && m._model && m._model.data ? m._model.data : null;
            switch (chk) {
                case "create_node":
                case "move_node":
                case "copy_node":
                    if (chk !== 'move_node' || $.inArray(obj.id, par.children) === -1) {
                        tmp = this.get_rules(par);
                        if (tmp.max_children !== undefined && tmp.max_children !== -1 && tmp.max_children === par.children.length) {
                            this._data.core.last_error = { 'error': 'check', 'plugin': 'types', 'id': 'types_01', 'reason': 'max_children prevents function: ' + chk, 'data': JSON.stringify({ 'chk': chk, 'pos': pos, 'obj': obj && obj.id ? obj.id : false, 'par': par && par.id ? par.id : false }) };
                            return false;
                        }
                        if (tmp.valid_children !== undefined && tmp.valid_children !== -1 && $.inArray((obj.type || 'default'), tmp.valid_children) === -1) {
                            this._data.core.last_error = { 'error': 'check', 'plugin': 'types', 'id': 'types_02', 'reason': 'valid_children prevents function: ' + chk, 'data': JSON.stringify({ 'chk': chk, 'pos': pos, 'obj': obj && obj.id ? obj.id : false, 'par': par && par.id ? par.id : false }) };
                            return false;
                        }
                        if (m && obj.children_d && obj.parents) {
                            d = 0;
                            for (i = 0, j = obj.children_d.length; i < j; i++) {
                                d = Math.max(d, m[obj.children_d[i]].parents.length);
                            }
                            d = d - obj.parents.length + 1;
                        }
                        if (d <= 0 || d === undefined) { d = 1; }
                        do {
                            if (tmp.max_depth !== undefined && tmp.max_depth !== -1 && tmp.max_depth < d) {
                                this._data.core.last_error = { 'error': 'check', 'plugin': 'types', 'id': 'types_03', 'reason': 'max_depth prevents function: ' + chk, 'data': JSON.stringify({ 'chk': chk, 'pos': pos, 'obj': obj && obj.id ? obj.id : false, 'par': par && par.id ? par.id : false }) };
                                return false;
                            }
                            par = this.get_node(par.parent);
                            tmp = this.get_rules(par);
                            d++;
                        } while (par);
                    }
                    break;
            }
            return true;
        };
        /**
         * used to retrieve the type settings object for a node
         * @name get_rules(obj)
         * @param {mixed} obj the node to find the rules for
         * @return {Object}
         * @plugin types
         */
        this.get_rules = function (obj) {
            obj = this.get_node(obj);
            if (!obj) { return false; }
            var tmp = this.get_type(obj, true);
            if (tmp.max_depth === undefined) { tmp.max_depth = -1; }
            if (tmp.max_children === undefined) { tmp.max_children = -1; }
            if (tmp.valid_children === undefined) { tmp.valid_children = -1; }
            return tmp;
        };
        /**
         * used to retrieve the type string or settings object for a node
         * @name get_type(obj [, rules])
         * @param {mixed} obj the node to find the rules for
         * @param {Boolean} rules if set to `true` instead of a string the settings object will be returned
         * @return {String|Object}
         * @plugin types
         */
        this.get_type = function (obj, rules) {
            obj = this.get_node(obj);
            return (!obj) ? false : (rules ? $.extend({ 'type': obj.type }, this.settings.types[obj.type]) : obj.type);
        };
        /**
         * used to change a node's type
         * @name set_type(obj, type)
         * @param {mixed} obj the node to change
         * @param {String} type the new type
         * @plugin types
         */
        this.set_type = function (obj, type) {
            var m = this._model.data, t, t1, t2, old_type, old_icon, k, d, a;
            if ($.isArray(obj)) {
                obj = obj.slice();
                for (t1 = 0, t2 = obj.length; t1 < t2; t1++) {
                    this.set_type(obj[t1], type);
                }
                return true;
            }
            t = this.settings.types;
            obj = this.get_node(obj);
            if (!t[type] || !obj) { return false; }
            d = this.get_node(obj, true);
            if (d && d.length) {
                a = d.children('.jstree-anchor');
            }
            old_type = obj.type;
            old_icon = this.get_icon(obj);
            obj.type = type;
            if (old_icon === true || !t[old_type] || (t[old_type].icon !== undefined && old_icon === t[old_type].icon)) {
                this.set_icon(obj, t[type].icon !== undefined ? t[type].icon : true);
            }

            // remove old type props
            if (t[old_type] && t[old_type].li_attr !== undefined && typeof t[old_type].li_attr === 'object') {
                for (k in t[old_type].li_attr) {
                    if (t[old_type].li_attr.hasOwnProperty(k)) {
                        if (k === 'id') {
                            continue;
                        }
                        else if (k === 'class') {
                            m[obj.id].li_attr['class'] = (m[obj.id].li_attr['class'] || '').replace(t[old_type].li_attr[k], '');
                            if (d) { d.removeClass(t[old_type].li_attr[k]); }
                        }
                        else if (m[obj.id].li_attr[k] === t[old_type].li_attr[k]) {
                            m[obj.id].li_attr[k] = null;
                            if (d) { d.removeAttr(k); }
                        }
                    }
                }
            }
            if (t[old_type] && t[old_type].a_attr !== undefined && typeof t[old_type].a_attr === 'object') {
                for (k in t[old_type].a_attr) {
                    if (t[old_type].a_attr.hasOwnProperty(k)) {
                        if (k === 'id') {
                            continue;
                        }
                        else if (k === 'class') {
                            m[obj.id].a_attr['class'] = (m[obj.id].a_attr['class'] || '').replace(t[old_type].a_attr[k], '');
                            if (a) { a.removeClass(t[old_type].a_attr[k]); }
                        }
                        else if (m[obj.id].a_attr[k] === t[old_type].a_attr[k]) {
                            if (k === 'href') {
                                m[obj.id].a_attr[k] = '#';
                                if (a) { a.attr('href', '#'); }
                            }
                            else {
                                delete m[obj.id].a_attr[k];
                                if (a) { a.removeAttr(k); }
                            }
                        }
                    }
                }
            }

            // add new props
            if (t[type].li_attr !== undefined && typeof t[type].li_attr === 'object') {
                for (k in t[type].li_attr) {
                    if (t[type].li_attr.hasOwnProperty(k)) {
                        if (k === 'id') {
                            continue;
                        }
                        else if (m[obj.id].li_attr[k] === undefined) {
                            m[obj.id].li_attr[k] = t[type].li_attr[k];
                            if (d) {
                                if (k === 'class') {
                                    d.addClass(t[type].li_attr[k]);
                                }
                                else {
                                    d.attr(k, t[type].li_attr[k]);
                                }
                            }
                        }
                        else if (k === 'class') {
                            m[obj.id].li_attr['class'] = t[type].li_attr[k] + ' ' + m[obj.id].li_attr['class'];
                            if (d) { d.addClass(t[type].li_attr[k]); }
                        }
                    }
                }
            }
            if (t[type].a_attr !== undefined && typeof t[type].a_attr === 'object') {
                for (k in t[type].a_attr) {
                    if (t[type].a_attr.hasOwnProperty(k)) {
                        if (k === 'id') {
                            continue;
                        }
                        else if (m[obj.id].a_attr[k] === undefined) {
                            m[obj.id].a_attr[k] = t[type].a_attr[k];
                            if (a) {
                                if (k === 'class') {
                                    a.addClass(t[type].a_attr[k]);
                                }
                                else {
                                    a.attr(k, t[type].a_attr[k]);
                                }
                            }
                        }
                        else if (k === 'href' && m[obj.id].a_attr[k] === '#') {
                            m[obj.id].a_attr['href'] = t[type].a_attr['href'];
                            if (a) { a.attr('href', t[type].a_attr['href']); }
                        }
                        else if (k === 'class') {
                            m[obj.id].a_attr['class'] = t[type].a_attr['class'] + ' ' + m[obj.id].a_attr['class'];
                            if (a) { a.addClass(t[type].a_attr[k]); }
                        }
                    }
                }
            }

            return true;
        };
    };
    // include the types plugin by default
    // $.jstree.defaults.plugins.push("types");


    /**
     * ### Unique plugin
     *
     * Enforces that no nodes with the same name can coexist as siblings.
     */

    /**
     * stores all defaults for the unique plugin
     * @name $.jstree.defaults.unique
     * @plugin unique
     */
    $.jstree.defaults.unique = {
        /**
         * Indicates if the comparison should be case sensitive. Default is `false`.
         * @name $.jstree.defaults.unique.case_sensitive
         * @plugin unique
         */
        case_sensitive: false,
        /**
         * A callback executed in the instance's scope when a new node is created and the name is already taken, the two arguments are the conflicting name and the counter. The default will produce results like `New node (2)`.
         * @name $.jstree.defaults.unique.duplicate
         * @plugin unique
         */
        duplicate: function (name, counter) {
            return name + ' (' + counter + ')';
        }
    };

    $.jstree.plugins.unique = function (options, parent) {
        this.check = function (chk, obj, par, pos, more) {
            if (parent.check.call(this, chk, obj, par, pos, more) === false) { return false; }
            obj = obj && obj.id ? obj : this.get_node(obj);
            par = par && par.id ? par : this.get_node(par);
            if (!par || !par.children) { return true; }
            var n = chk === "rename_node" ? pos : obj.text,
                c = [],
                s = this.settings.unique.case_sensitive,
                m = this._model.data, i, j;
            for (i = 0, j = par.children.length; i < j; i++) {
                c.push(s ? m[par.children[i]].text : m[par.children[i]].text.toLowerCase());
            }
            if (!s) { n = n.toLowerCase(); }
            switch (chk) {
                case "delete_node":
                    return true;
                case "rename_node":
                    i = ($.inArray(n, c) === -1 || (obj.text && obj.text[s ? 'toString' : 'toLowerCase']() === n));
                    if (!i) {
                        this._data.core.last_error = { 'error': 'check', 'plugin': 'unique', 'id': 'unique_01', 'reason': 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data': JSON.stringify({ 'chk': chk, 'pos': pos, 'obj': obj && obj.id ? obj.id : false, 'par': par && par.id ? par.id : false }) };
                    }
                    return i;
                case "create_node":
                    i = ($.inArray(n, c) === -1);
                    if (!i) {
                        this._data.core.last_error = { 'error': 'check', 'plugin': 'unique', 'id': 'unique_04', 'reason': 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data': JSON.stringify({ 'chk': chk, 'pos': pos, 'obj': obj && obj.id ? obj.id : false, 'par': par && par.id ? par.id : false }) };
                    }
                    return i;
                case "copy_node":
                    i = ($.inArray(n, c) === -1);
                    if (!i) {
                        this._data.core.last_error = { 'error': 'check', 'plugin': 'unique', 'id': 'unique_02', 'reason': 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data': JSON.stringify({ 'chk': chk, 'pos': pos, 'obj': obj && obj.id ? obj.id : false, 'par': par && par.id ? par.id : false }) };
                    }
                    return i;
                case "move_node":
                    i = ((obj.parent === par.id && (!more || !more.is_multi)) || $.inArray(n, c) === -1);
                    if (!i) {
                        this._data.core.last_error = { 'error': 'check', 'plugin': 'unique', 'id': 'unique_03', 'reason': 'Child with name ' + n + ' already exists. Preventing: ' + chk, 'data': JSON.stringify({ 'chk': chk, 'pos': pos, 'obj': obj && obj.id ? obj.id : false, 'par': par && par.id ? par.id : false }) };
                    }
                    return i;
            }
            return true;
        };
        this.create_node = function (par, node, pos, callback, is_loaded) {
            if (!node || node.text === undefined) {
                if (par === null) {
                    par = $.jstree.root;
                }
                par = this.get_node(par);
                if (!par) {
                    return parent.create_node.call(this, par, node, pos, callback, is_loaded);
                }
                pos = pos === undefined ? "last" : pos;
                if (!pos.toString().match(/^(before|after)$/) && !is_loaded && !this.is_loaded(par)) {
                    return parent.create_node.call(this, par, node, pos, callback, is_loaded);
                }
                if (!node) { node = {}; }
                var tmp, n, dpc, i, j, m = this._model.data, s = this.settings.unique.case_sensitive, cb = this.settings.unique.duplicate;
                n = tmp = this.get_string('New node');
                dpc = [];
                for (i = 0, j = par.children.length; i < j; i++) {
                    dpc.push(s ? m[par.children[i]].text : m[par.children[i]].text.toLowerCase());
                }
                i = 1;
                while ($.inArray(s ? n : n.toLowerCase(), dpc) !== -1) {
                    n = cb.call(this, tmp, (++i)).toString();
                }
                node.text = n;
            }
            return parent.create_node.call(this, par, node, pos, callback, is_loaded);
        };
    };

    // include the unique plugin by default
    // $.jstree.defaults.plugins.push("unique");


    /**
     * ### Wholerow plugin
     *
     * Makes each node appear block level. Making selection easier. May cause slow down for large trees in old browsers.
     */

    var div = document.createElement('DIV');
    div.setAttribute('unselectable', 'on');
    div.setAttribute('role', 'presentation');
    div.className = 'jstree-wholerow';
    div.innerHTML = '&#160;';
    $.jstree.plugins.wholerow = function (options, parent) {
        this.bind = function () {
            parent.bind.call(this);

            this.element
                .on('ready.jstree set_state.jstree', $.proxy(function () {
                    this.hide_dots();
                }, this))
                .on("init.jstree loading.jstree ready.jstree", $.proxy(function () {
                    //div.style.height = this._data.core.li_height + 'px';
                    this.get_container_ul().addClass('jstree-wholerow-ul');
                }, this))
                .on("deselect_all.jstree", $.proxy(function (e, data) {
                    this.element.find('.jstree-wholerow-clicked').removeClass('jstree-wholerow-clicked');
                }, this))
                .on("changed.jstree", $.proxy(function (e, data) {
                    this.element.find('.jstree-wholerow-clicked').removeClass('jstree-wholerow-clicked');
                    var tmp = false, i, j;
                    for (i = 0, j = data.selected.length; i < j; i++) {
                        tmp = this.get_node(data.selected[i], true);
                        if (tmp && tmp.length) {
                            tmp.children('.jstree-wholerow').addClass('jstree-wholerow-clicked');
                        }
                    }
                }, this))
                .on("open_node.jstree", $.proxy(function (e, data) {
                    this.get_node(data.node, true).find('.jstree-clicked').parent().children('.jstree-wholerow').addClass('jstree-wholerow-clicked');
                }, this))
                .on("hover_node.jstree dehover_node.jstree", $.proxy(function (e, data) {
                    if (e.type === "hover_node" && this.is_disabled(data.node)) { return; }
                    this.get_node(data.node, true).children('.jstree-wholerow')[e.type === "hover_node" ? "addClass" : "removeClass"]('jstree-wholerow-hovered');
                }, this))
                .on("contextmenu.jstree", ".jstree-wholerow", $.proxy(function (e) {
                    if (this._data.contextmenu) {
                        e.preventDefault();
                        var tmp = $.Event('contextmenu', { metaKey: e.metaKey, ctrlKey: e.ctrlKey, altKey: e.altKey, shiftKey: e.shiftKey, pageX: e.pageX, pageY: e.pageY });
                        $(e.currentTarget).closest(".jstree-node").children(".jstree-anchor").first().trigger(tmp);
                    }
                }, this))
                /*!
                .on("mousedown.jstree touchstart.jstree", ".jstree-wholerow", function (e) {
                        if(e.target === e.currentTarget) {
                            var a = $(e.currentTarget).closest(".jstree-node").children(".jstree-anchor");
                            e.target = a[0];
                            a.trigger(e);
                        }
                    })
                */
                .on("click.jstree", ".jstree-wholerow", function (e) {
                    e.stopImmediatePropagation();
                    var tmp = $.Event('click', { metaKey: e.metaKey, ctrlKey: e.ctrlKey, altKey: e.altKey, shiftKey: e.shiftKey });
                    $(e.currentTarget).closest(".jstree-node").children(".jstree-anchor").first().trigger(tmp).focus();
                })
                .on("dblclick.jstree", ".jstree-wholerow", function (e) {
                    e.stopImmediatePropagation();
                    var tmp = $.Event('dblclick', { metaKey: e.metaKey, ctrlKey: e.ctrlKey, altKey: e.altKey, shiftKey: e.shiftKey });
                    $(e.currentTarget).closest(".jstree-node").children(".jstree-anchor").first().trigger(tmp).focus();
                })
                .on("click.jstree", ".jstree-leaf > .jstree-ocl", $.proxy(function (e) {
                    e.stopImmediatePropagation();
                    var tmp = $.Event('click', { metaKey: e.metaKey, ctrlKey: e.ctrlKey, altKey: e.altKey, shiftKey: e.shiftKey });
                    $(e.currentTarget).closest(".jstree-node").children(".jstree-anchor").first().trigger(tmp).focus();
                }, this))
                .on("mouseover.jstree", ".jstree-wholerow, .jstree-icon", $.proxy(function (e) {
                    e.stopImmediatePropagation();
                    if (!this.is_disabled(e.currentTarget)) {
                        this.hover_node(e.currentTarget);
                    }
                    return false;
                }, this))
                .on("mouseleave.jstree", ".jstree-node", $.proxy(function (e) {
                    this.dehover_node(e.currentTarget);
                }, this));
        };
        this.teardown = function () {
            if (this.settings.wholerow) {
                this.element.find(".jstree-wholerow").remove();
            }
            parent.teardown.call(this);
        };
        this.redraw_node = function (obj, deep, callback, force_render) {
            obj = parent.redraw_node.apply(this, arguments);
            if (obj) {
                var tmp = div.cloneNode(true);
                //tmp.style.height = this._data.core.li_height + 'px';
                if ($.inArray(obj.id, this._data.core.selected) !== -1) { tmp.className += ' jstree-wholerow-clicked'; }
                if (this._data.core.focused && this._data.core.focused === obj.id) { tmp.className += ' jstree-wholerow-hovered'; }
                obj.insertBefore(tmp, obj.childNodes[0]);
            }
            return obj;
        };
    };
    // include the wholerow plugin by default
    // $.jstree.defaults.plugins.push("wholerow");
    if (document.registerElement && Object && Object.create) {
        var proto = Object.create(HTMLElement.prototype);
        proto.createdCallback = function () {
            var c = { core: {}, plugins: [] }, i;
            for (i in $.jstree.plugins) {
                if ($.jstree.plugins.hasOwnProperty(i) && this.attributes[i]) {
                    c.plugins.push(i);
                    if (this.getAttribute(i) && JSON.parse(this.getAttribute(i))) {
                        c[i] = JSON.parse(this.getAttribute(i));
                    }
                }
            }
            for (i in $.jstree.defaults.core) {
                if ($.jstree.defaults.core.hasOwnProperty(i) && this.attributes[i]) {
                    c.core[i] = JSON.parse(this.getAttribute(i)) || this.getAttribute(i);
                }
            }
            $(this).jstree(c);
        };
        // proto.attributeChangedCallback = function (name, previous, value) { };
        try {
            document.registerElement("vakata-jstree", { prototype: proto });
        } catch (ignore) { }
    }

}));

//#endregion End jsTree

//#region Globalize

/*!
 * Globalize
 *
 * http://github.com/jquery/globalize
 *
 * Copyright Software Freedom Conservancy, Inc.
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 */

(function (window, undefined) {

    var Globalize,
		// private variables
		regexHex,
		regexInfinity,
		regexParseFloat,
		regexTrim,
		// private JavaScript utility functions
		arrayIndexOf,
		endsWith,
		extend,
		isArray,
		isFunction,
		isObject,
		startsWith,
		trim,
		truncate,
		zeroPad,
		// private Globalization utility functions
		appendPreOrPostMatch,
		expandFormat,
		formatDate,
		formatNumber,
		getTokenRegExp,
		getEra,
		getEraYear,
		parseExact,
		parseNegativePattern;

    // Global variable (Globalize) or CommonJS module (globalize)
    Globalize = function (cultureSelector) {
        return new Globalize.prototype.init(cultureSelector);
    };

    if (typeof require !== "undefined" &&
		typeof exports !== "undefined" &&
		typeof module !== "undefined") {
        // Assume CommonJS
        module.exports = Globalize;
    } else {
        // Export as global variable
        window.Globalize = Globalize;
    }

    Globalize.cultures = {};

    Globalize.prototype = {
        constructor: Globalize,
        init: function (cultureSelector) {
            this.cultures = Globalize.cultures;
            this.cultureSelector = cultureSelector;

            return this;
        }
    };
    Globalize.prototype.init.prototype = Globalize.prototype;

    // 1. When defining a culture, all fields are required except the ones stated as optional.
    // 2. Each culture should have a ".calendars" object with at least one calendar named "standard"
    //    which serves as the default calendar in use by that culture.
    // 3. Each culture should have a ".calendar" object which is the current calendar being used,
    //    it may be dynamically changed at any time to one of the calendars in ".calendars".
    Globalize.cultures["default"] = {
        // A unique name for the culture in the form <language code>-<country/region code>
        name: "en",
        // the name of the culture in the english language
        englishName: "English",
        // the name of the culture in its own language
        nativeName: "English",
        // whether the culture uses right-to-left text
        isRTL: false,
        // "language" is used for so-called "specific" cultures.
        // For example, the culture "es-CL" means "Spanish, in Chili".
        // It represents the Spanish-speaking culture as it is in Chili,
        // which might have different formatting rules or even translations
        // than Spanish in Spain. A "neutral" culture is one that is not
        // specific to a region. For example, the culture "es" is the generic
        // Spanish culture, which may be a more generalized version of the language
        // that may or may not be what a specific culture expects.
        // For a specific culture like "es-CL", the "language" field refers to the
        // neutral, generic culture information for the language it is using.
        // This is not always a simple matter of the string before the dash.
        // For example, the "zh-Hans" culture is netural (Simplified Chinese).
        // And the "zh-SG" culture is Simplified Chinese in Singapore, whose lanugage
        // field is "zh-CHS", not "zh".
        // This field should be used to navigate from a specific culture to it's
        // more general, neutral culture. If a culture is already as general as it
        // can get, the language may refer to itself.
        language: "en",
        // numberFormat defines general number formatting rules, like the digits in
        // each grouping, the group separator, and how negative numbers are displayed.
        numberFormat: {
            // [negativePattern]
            // Note, numberFormat.pattern has no "positivePattern" unlike percent and currency,
            // but is still defined as an array for consistency with them.
            //   negativePattern: one of "(n)|-n|- n|n-|n -"
            pattern: ["-n"],
            // number of decimal places normally shown
            decimals: 2,
            // string that separates number groups, as in 1,000,000
            ",": ",",
            // string that separates a number from the fractional portion, as in 1.99
            ".": ".",
            // array of numbers indicating the size of each number group.
            // TODO: more detailed description and example
            groupSizes: [3],
            // symbol used for positive numbers
            "+": "+",
            // symbol used for negative numbers
            "-": "-",
            // symbol used for NaN (Not-A-Number)
            "NaN": "NaN",
            // symbol used for Negative Infinity
            negativeInfinity: "-Infinity",
            // symbol used for Positive Infinity
            positiveInfinity: "Infinity",
            percent: {
                // [negativePattern, positivePattern]
                //   negativePattern: one of "-n %|-n%|-%n|%-n|%n-|n-%|n%-|-% n|n %-|% n-|% -n|n- %"
                //   positivePattern: one of "n %|n%|%n|% n"
                pattern: ["-n %", "n %"],
                // number of decimal places normally shown
                decimals: 2,
                // array of numbers indicating the size of each number group.
                // TODO: more detailed description and example
                groupSizes: [3],
                // string that separates number groups, as in 1,000,000
                ",": ",",
                // string that separates a number from the fractional portion, as in 1.99
                ".": ".",
                // symbol used to represent a percentage
                symbol: "%"
            },
            currency: {
                // [negativePattern, positivePattern]
                //   negativePattern: one of "($n)|-$n|$-n|$n-|(n$)|-n$|n-$|n$-|-n $|-$ n|n $-|$ n-|$ -n|n- $|($ n)|(n $)"
                //   positivePattern: one of "$n|n$|$ n|n $"
                pattern: ["($n)", "$n"],
                // number of decimal places normally shown
                decimals: 2,
                // array of numbers indicating the size of each number group.
                // TODO: more detailed description and example
                groupSizes: [3],
                // string that separates number groups, as in 1,000,000
                ",": ",",
                // string that separates a number from the fractional portion, as in 1.99
                ".": ".",
                // symbol used to represent currency
                symbol: "$"
            }
        },
        // calendars defines all the possible calendars used by this culture.
        // There should be at least one defined with name "standard", and is the default
        // calendar used by the culture.
        // A calendar contains information about how dates are formatted, information about
        // the calendar's eras, a standard set of the date formats,
        // translations for day and month names, and if the calendar is not based on the Gregorian
        // calendar, conversion functions to and from the Gregorian calendar.
        calendars: {
            standard: {
                // name that identifies the type of calendar this is
                name: "Gregorian_USEnglish",
                // separator of parts of a date (e.g. "/" in 11/05/1955)
                "/": "/",
                // separator of parts of a time (e.g. ":" in 05:44 PM)
                ":": ":",
                // the first day of the week (0 = Sunday, 1 = Monday, etc)
                firstDay: 0,
                days: {
                    // full day names
                    names: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                    // abbreviated day names
                    namesAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                    // shortest day names
                    namesShort: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]
                },
                months: {
                    // full month names (13 months for lunar calendards -- 13th month should be "" if not lunar)
                    names: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December", ""],
                    // abbreviated month names
                    namesAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", ""]
                },
                // AM and PM designators in one of these forms:
                // The usual view, and the upper and lower case versions
                //   [ standard, lowercase, uppercase ]
                // The culture does not use AM or PM (likely all standard date formats use 24 hour time)
                //   null
                AM: ["AM", "am", "AM"],
                PM: ["PM", "pm", "PM"],
                eras: [
					// eras in reverse chronological order.
					// name: the name of the era in this culture (e.g. A.D., C.E.)
					// start: when the era starts in ticks (gregorian, gmt), null if it is the earliest supported era.
					// offset: offset in years from gregorian calendar
					{
					    "name": "A.D.",
					    "start": null,
					    "offset": 0
					}
                ],
                // when a two digit year is given, it will never be parsed as a four digit
                // year greater than this year (in the appropriate era for the culture)
                // Set it as a full year (e.g. 2029) or use an offset format starting from
                // the current year: "+19" would correspond to 2029 if the current year 2010.
                twoDigitYearMax: 2029,
                // set of predefined date and time patterns used by the culture
                // these represent the format someone in this culture would expect
                // to see given the portions of the date that are shown.
                patterns: {
                    // short date pattern
                    d: "M/d/yyyy",
                    // long date pattern
                    D: "dddd, MMMM dd, yyyy",
                    // short time pattern
                    t: "h:mm tt",
                    // long time pattern
                    T: "h:mm:ss tt",
                    // long date, short time pattern
                    f: "dddd, MMMM dd, yyyy h:mm tt",
                    // long date, long time pattern
                    F: "dddd, MMMM dd, yyyy h:mm:ss tt",
                    // month/day pattern
                    M: "MMMM dd",
                    // month/year pattern
                    Y: "yyyy MMMM",
                    // S is a sortable format that does not vary by culture
                    S: "yyyy\u0027-\u0027MM\u0027-\u0027dd\u0027T\u0027HH\u0027:\u0027mm\u0027:\u0027ss"
                }
                // optional fields for each calendar:
                /*
				monthsGenitive:
					Same as months but used when the day preceeds the month.
					Omit if the culture has no genitive distinction in month names.
					For an explaination of genitive months, see http://blogs.msdn.com/michkap/archive/2004/12/25/332259.aspx
				convert:
					Allows for the support of non-gregorian based calendars. This convert object is used to
					to convert a date to and from a gregorian calendar date to handle parsing and formatting.
					The two functions:
						fromGregorian( date )
							Given the date as a parameter, return an array with parts [ year, month, day ]
							corresponding to the non-gregorian based year, month, and day for the calendar.
						toGregorian( year, month, day )
							Given the non-gregorian year, month, and day, return a new Date() object
							set to the corresponding date in the gregorian calendar.
				*/
            }
        },
        // For localized strings
        messages: {}
    };

    Globalize.cultures["default"].calendar = Globalize.cultures["default"].calendars.standard;

    Globalize.cultures.en = Globalize.cultures["default"];

    Globalize.cultureSelector = "en";

    //
    // private variables
    //

    regexHex = /^0x[a-f0-9]+$/i;
    regexInfinity = /^[+\-]?infinity$/i;
    regexParseFloat = /^[+\-]?\d*\.?\d*(e[+\-]?\d+)?$/;
    regexTrim = /^\s+|\s+$/g;

    //
    // private JavaScript utility functions
    //

    arrayIndexOf = function (array, item) {
        if (array.indexOf) {
            return array.indexOf(item);
        }
        for (var i = 0, length = array.length; i < length; i++) {
            if (array[i] === item) {
                return i;
            }
        }
        return -1;
    };

    endsWith = function (value, pattern) {
        return value.substr(value.length - pattern.length) === pattern;
    };

    extend = function () {
        var options, name, src, copy, copyIsArray, clone,
			target = arguments[0] || {},
			i = 1,
			length = arguments.length,
			deep = false;

        // Handle a deep copy situation
        if (typeof target === "boolean") {
            deep = target;
            target = arguments[1] || {};
            // skip the boolean and the target
            i = 2;
        }

        // Handle case when target is a string or something (possible in deep copy)
        if (typeof target !== "object" && !isFunction(target)) {
            target = {};
        }

        for (; i < length; i++) {
            // Only deal with non-null/undefined values
            if ((options = arguments[i]) != null) {
                // Extend the base object
                for (name in options) {
                    src = target[name];
                    copy = options[name];

                    // Prevent never-ending loop
                    if (target === copy) {
                        continue;
                    }

                    // Recurse if we're merging plain objects or arrays
                    if (deep && copy && (isObject(copy) || (copyIsArray = isArray(copy)))) {
                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && isArray(src) ? src : [];

                        } else {
                            clone = src && isObject(src) ? src : {};
                        }

                        // Never move original objects, clone them
                        target[name] = extend(deep, clone, copy);

                        // Don't bring in undefined values
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }

        // Return the modified object
        return target;
    };

    isArray = Array.isArray || function (obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
    };

    isFunction = function (obj) {
        return Object.prototype.toString.call(obj) === "[object Function]";
    };

    isObject = function (obj) {
        return Object.prototype.toString.call(obj) === "[object Object]";
    };

    startsWith = function (value, pattern) {
        return value.indexOf(pattern) === 0;
    };

    trim = function (value) {
        return (value + "").replace(regexTrim, "");
    };

    truncate = function (value) {
        if (isNaN(value)) {
            return NaN;
        }
        return Math[value < 0 ? "ceil" : "floor"](value);
    };

    zeroPad = function (str, count, left) {
        var l;
        for (l = str.length; l < count; l += 1) {
            str = (left ? ("0" + str) : (str + "0"));
        }
        return str;
    };

    //
    // private Globalization utility functions
    //

    appendPreOrPostMatch = function (preMatch, strings) {
        // appends pre- and post- token match strings while removing escaped characters.
        // Returns a single quote count which is used to determine if the token occurs
        // in a string literal.
        var quoteCount = 0,
			escaped = false;
        for (var i = 0, il = preMatch.length; i < il; i++) {
            var c = preMatch.charAt(i);
            switch (c) {
                case "\'":
                    if (escaped) {
                        strings.push("\'");
                    }
                    else {
                        quoteCount++;
                    }
                    escaped = false;
                    break;
                case "\\":
                    if (escaped) {
                        strings.push("\\");
                    }
                    escaped = !escaped;
                    break;
                default:
                    strings.push(c);
                    escaped = false;
                    break;
            }
        }
        return quoteCount;
    };

    expandFormat = function (cal, format) {
        // expands unspecified or single character date formats into the full pattern.
        format = format || "F";
        var pattern,
			patterns = cal.patterns,
			len = format.length;
        if (len === 1) {
            pattern = patterns[format];
            if (!pattern) {
                throw "Invalid date format string \'" + format + "\'.";
            }
            format = pattern;
        }
        else if (len === 2 && format.charAt(0) === "%") {
            // %X escape format -- intended as a custom format string that is only one character, not a built-in format.
            format = format.charAt(1);
        }
        return format;
    };

    formatDate = function (value, format, culture) {
        var cal = culture.calendar,
			convert = cal.convert,
			ret;

        if (!format || !format.length || format === "i") {
            if (culture && culture.name.length) {
                if (convert) {
                    // non-gregorian calendar, so we cannot use built-in toLocaleString()
                    ret = formatDate(value, cal.patterns.F, culture);
                }
                else {
                    var eraDate = new Date(value.getTime()),
						era = getEra(value, cal.eras);
                    eraDate.setFullYear(getEraYear(value, cal, era));
                    ret = eraDate.toLocaleString();
                }
            }
            else {
                ret = value.toString();
            }
            return ret;
        }

        var eras = cal.eras,
			sortable = format === "s";
        format = expandFormat(cal, format);

        // Start with an empty string
        ret = [];
        var hour,
			zeros = ["0", "00", "000"],
			foundDay,
			checkedDay,
			dayPartRegExp = /([^d]|^)(d|dd)([^d]|$)/g,
			quoteCount = 0,
			tokenRegExp = getTokenRegExp(),
			converted;

        function padZeros(num, c) {
            var r, s = num + "";
            if (c > 1 && s.length < c) {
                r = (zeros[c - 2] + s);
                return r.substr(r.length - c, c);
            }
            else {
                r = s;
            }
            return r;
        }

        function hasDay() {
            if (foundDay || checkedDay) {
                return foundDay;
            }
            foundDay = dayPartRegExp.test(format);
            checkedDay = true;
            return foundDay;
        }

        function getPart(date, part) {
            if (converted) {
                return converted[part];
            }
            switch (part) {
                case 0:
                    return date.getFullYear();
                case 1:
                    return date.getMonth();
                case 2:
                    return date.getDate();
                default:
                    throw "Invalid part value " + part;
            }
        }

        if (!sortable && convert) {
            converted = convert.fromGregorian(value);
        }

        for (; ;) {
            // Save the current index
            var index = tokenRegExp.lastIndex,
				// Look for the next pattern
				ar = tokenRegExp.exec(format);

            // Append the text before the pattern (or the end of the string if not found)
            var preMatch = format.slice(index, ar ? ar.index : format.length);
            quoteCount += appendPreOrPostMatch(preMatch, ret);

            if (!ar) {
                break;
            }

            // do not replace any matches that occur inside a string literal.
            if (quoteCount % 2) {
                ret.push(ar[0]);
                continue;
            }

            var current = ar[0],
				clength = current.length;

            switch (current) {
                case "ddd":
                    //Day of the week, as a three-letter abbreviation
                case "dddd":
                    // Day of the week, using the full name
                    var names = (clength === 3) ? cal.days.namesAbbr : cal.days.names;
                    ret.push(names[value.getDay()]);
                    break;
                case "d":
                    // Day of month, without leading zero for single-digit days
                case "dd":
                    // Day of month, with leading zero for single-digit days
                    foundDay = true;
                    ret.push(
						padZeros(getPart(value, 2), clength)
					);
                    break;
                case "MMM":
                    // Month, as a three-letter abbreviation
                case "MMMM":
                    // Month, using the full name
                    var part = getPart(value, 1);
                    ret.push(
						(cal.monthsGenitive && hasDay()) ?
						(cal.monthsGenitive[clength === 3 ? "namesAbbr" : "names"][part]) :
						(cal.months[clength === 3 ? "namesAbbr" : "names"][part])
					);
                    break;
                case "M":
                    // Month, as digits, with no leading zero for single-digit months
                case "MM":
                    // Month, as digits, with leading zero for single-digit months
                    ret.push(
						padZeros(getPart(value, 1) + 1, clength)
					);
                    break;
                case "y":
                    // Year, as two digits, but with no leading zero for years less than 10
                case "yy":
                    // Year, as two digits, with leading zero for years less than 10
                case "yyyy":
                    // Year represented by four full digits
                    part = converted ? converted[0] : getEraYear(value, cal, getEra(value, eras), sortable);
                    if (clength < 4) {
                        part = part % 100;
                    }
                    ret.push(
						padZeros(part, clength)
					);
                    break;
                case "h":
                    // Hours with no leading zero for single-digit hours, using 12-hour clock
                case "hh":
                    // Hours with leading zero for single-digit hours, using 12-hour clock
                    hour = value.getHours() % 12;
                    if (hour === 0) hour = 12;
                    ret.push(
						padZeros(hour, clength)
					);
                    break;
                case "H":
                    // Hours with no leading zero for single-digit hours, using 24-hour clock
                case "HH":
                    // Hours with leading zero for single-digit hours, using 24-hour clock
                    ret.push(
						padZeros(value.getHours(), clength)
					);
                    break;
                case "m":
                    // Minutes with no leading zero for single-digit minutes
                case "mm":
                    // Minutes with leading zero for single-digit minutes
                    ret.push(
						padZeros(value.getMinutes(), clength)
					);
                    break;
                case "s":
                    // Seconds with no leading zero for single-digit seconds
                case "ss":
                    // Seconds with leading zero for single-digit seconds
                    ret.push(
						padZeros(value.getSeconds(), clength)
					);
                    break;
                case "t":
                    // One character am/pm indicator ("a" or "p")
                case "tt":
                    // Multicharacter am/pm indicator
                    part = value.getHours() < 12 ? (cal.AM ? cal.AM[0] : " ") : (cal.PM ? cal.PM[0] : " ");
                    ret.push(clength === 1 ? part.charAt(0) : part);
                    break;
                case "f":
                    // Deciseconds
                case "ff":
                    // Centiseconds
                case "fff":
                    // Milliseconds
                    ret.push(
						padZeros(value.getMilliseconds(), 3).substr(0, clength)
					);
                    break;
                case "z":
                    // Time zone offset, no leading zero
                case "zz":
                    // Time zone offset with leading zero
                    hour = value.getTimezoneOffset() / 60;
                    ret.push(
						(hour <= 0 ? "+" : "-") + padZeros(Math.floor(Math.abs(hour)), clength)
					);
                    break;
                case "zzz":
                    // Time zone offset with leading zero
                    hour = value.getTimezoneOffset() / 60;
                    ret.push(
						(hour <= 0 ? "+" : "-") + padZeros(Math.floor(Math.abs(hour)), 2) +
						// Hard coded ":" separator, rather than using cal.TimeSeparator
						// Repeated here for consistency, plus ":" was already assumed in date parsing.
						":" + padZeros(Math.abs(value.getTimezoneOffset() % 60), 2)
					);
                    break;
                case "g":
                case "gg":
                    if (cal.eras) {
                        ret.push(
							cal.eras[getEra(value, eras)].name
						);
                    }
                    break;
                case "/":
                    ret.push(cal["/"]);
                    break;
                default:
                    throw "Invalid date format pattern \'" + current + "\'.";
            }
        }
        return ret.join("");
    };

    // formatNumber
    (function () {
        var expandNumber;

        expandNumber = function (number, precision, formatInfo) {
            var groupSizes = formatInfo.groupSizes,
				curSize = groupSizes[0],
				curGroupIndex = 1,
				factor = Math.pow(10, precision),
				rounded = Math.round(number * factor) / factor;

            if (!isFinite(rounded)) {
                rounded = number;
            }
            number = rounded;

            var numberString = number + "",
				right = "",
				split = numberString.split(/e/i),
				exponent = split.length > 1 ? parseInt(split[1], 10) : 0;
            numberString = split[0];
            split = numberString.split(".");
            numberString = split[0];
            right = split.length > 1 ? split[1] : "";

            var l;
            if (exponent > 0) {
                right = zeroPad(right, exponent, false);
                numberString += right.slice(0, exponent);
                right = right.substr(exponent);
            }
            else if (exponent < 0) {
                exponent = -exponent;
                numberString = zeroPad(numberString, exponent + 1, true);
                right = numberString.slice(-exponent, numberString.length) + right;
                numberString = numberString.slice(0, -exponent);
            }

            if (precision > 0) {
                right = formatInfo["."] +
					((right.length > precision) ? right.slice(0, precision) : zeroPad(right, precision));
            }
            else {
                right = "";
            }

            var stringIndex = numberString.length - 1,
				sep = formatInfo[","],
				ret = "";

            while (stringIndex >= 0) {
                if (curSize === 0 || curSize > stringIndex) {
                    return numberString.slice(0, stringIndex + 1) + (ret.length ? (sep + ret + right) : right);
                }
                ret = numberString.slice(stringIndex - curSize + 1, stringIndex + 1) + (ret.length ? (sep + ret) : "");

                stringIndex -= curSize;

                if (curGroupIndex < groupSizes.length) {
                    curSize = groupSizes[curGroupIndex];
                    curGroupIndex++;
                }
            }

            return numberString.slice(0, stringIndex + 1) + sep + ret + right;
        };

        formatNumber = function (value, format, culture) {
            if (!isFinite(value)) {
                if (value === Infinity) {
                    return culture.numberFormat.positiveInfinity;
                }
                if (value === -Infinity) {
                    return culture.numberFormat.negativeInfinity;
                }
                return culture.numberFormat.NaN;
            }
            if (!format || format === "i") {
                return culture.name.length ? value.toLocaleString() : value.toString();
            }
            format = format || "D";

            var nf = culture.numberFormat,
				number = Math.abs(value),
				precision = -1,
				pattern;
            if (format.length > 1) precision = parseInt(format.slice(1), 10);

            var current = format.charAt(0).toUpperCase(),
				formatInfo;

            switch (current) {
                case "D":
                    pattern = "n";
                    number = truncate(number);
                    if (precision !== -1) {
                        number = zeroPad("" + number, precision, true);
                    }
                    if (value < 0) number = "-" + number;
                    break;
                case "N":
                    formatInfo = nf;
                    /* falls through */
                case "C":
                    formatInfo = formatInfo || nf.currency;
                    /* falls through */
                case "P":
                    formatInfo = formatInfo || nf.percent;
                    pattern = value < 0 ? formatInfo.pattern[0] : (formatInfo.pattern[1] || "n");
                    if (precision === -1) precision = formatInfo.decimals;
                    number = expandNumber(number * (current === "P" ? 100 : 1), precision, formatInfo);
                    break;
                default:
                    throw "Bad number format specifier: " + current;
            }

            var patternParts = /n|\$|-|%/g,
				ret = "";
            for (; ;) {
                var index = patternParts.lastIndex,
					ar = patternParts.exec(pattern);

                ret += pattern.slice(index, ar ? ar.index : pattern.length);

                if (!ar) {
                    break;
                }

                switch (ar[0]) {
                    case "n":
                        ret += number;
                        break;
                    case "$":
                        ret += nf.currency.symbol;
                        break;
                    case "-":
                        // don't make 0 negative
                        if (/[1-9]/.test(number)) {
                            ret += nf["-"];
                        }
                        break;
                    case "%":
                        ret += nf.percent.symbol;
                        break;
                }
            }

            return ret;
        };

    }());

    getTokenRegExp = function () {
        // regular expression for matching date and time tokens in format strings.
        return (/\/|dddd|ddd|dd|d|MMMM|MMM|MM|M|yyyy|yy|y|hh|h|HH|H|mm|m|ss|s|tt|t|fff|ff|f|zzz|zz|z|gg|g/g);
    };

    getEra = function (date, eras) {
        if (!eras) return 0;
        var start, ticks = date.getTime();
        for (var i = 0, l = eras.length; i < l; i++) {
            start = eras[i].start;
            if (start === null || ticks >= start) {
                return i;
            }
        }
        return 0;
    };

    getEraYear = function (date, cal, era, sortable) {
        var year = date.getFullYear();
        if (!sortable && cal.eras) {
            // convert normal gregorian year to era-shifted gregorian
            // year by subtracting the era offset
            year -= cal.eras[era].offset;
        }
        return year;
    };

    // parseExact
    (function () {
        var expandYear,
			getDayIndex,
			getMonthIndex,
			getParseRegExp,
			outOfRange,
			toUpper,
			toUpperArray;

        expandYear = function (cal, year) {
            // expands 2-digit year into 4 digits.
            if (year < 100) {
                var now = new Date(),
					era = getEra(now),
					curr = getEraYear(now, cal, era),
					twoDigitYearMax = cal.twoDigitYearMax;
                twoDigitYearMax = typeof twoDigitYearMax === "string" ? new Date().getFullYear() % 100 + parseInt(twoDigitYearMax, 10) : twoDigitYearMax;
                year += curr - (curr % 100);
                if (year > twoDigitYearMax) {
                    year -= 100;
                }
            }
            return year;
        };

        getDayIndex = function (cal, value, abbr) {
            var ret,
				days = cal.days,
				upperDays = cal._upperDays;
            if (!upperDays) {
                cal._upperDays = upperDays = [
					toUpperArray(days.names),
					toUpperArray(days.namesAbbr),
					toUpperArray(days.namesShort)
                ];
            }
            value = toUpper(value);
            if (abbr) {
                ret = arrayIndexOf(upperDays[1], value);
                if (ret === -1) {
                    ret = arrayIndexOf(upperDays[2], value);
                }
            }
            else {
                ret = arrayIndexOf(upperDays[0], value);
            }
            return ret;
        };

        getMonthIndex = function (cal, value, abbr) {
            var months = cal.months,
				monthsGen = cal.monthsGenitive || cal.months,
				upperMonths = cal._upperMonths,
				upperMonthsGen = cal._upperMonthsGen;
            if (!upperMonths) {
                cal._upperMonths = upperMonths = [
					toUpperArray(months.names),
					toUpperArray(months.namesAbbr)
                ];
                cal._upperMonthsGen = upperMonthsGen = [
					toUpperArray(monthsGen.names),
					toUpperArray(monthsGen.namesAbbr)
                ];
            }
            value = toUpper(value);
            var i = arrayIndexOf(abbr ? upperMonths[1] : upperMonths[0], value);
            if (i < 0) {
                i = arrayIndexOf(abbr ? upperMonthsGen[1] : upperMonthsGen[0], value);
            }
            return i;
        };

        getParseRegExp = function (cal, format) {
            // converts a format string into a regular expression with groups that
            // can be used to extract date fields from a date string.
            // check for a cached parse regex.
            var re = cal._parseRegExp;
            if (!re) {
                cal._parseRegExp = re = {};
            }
            else {
                var reFormat = re[format];
                if (reFormat) {
                    return reFormat;
                }
            }

            // expand single digit formats, then escape regular expression characters.
            var expFormat = expandFormat(cal, format).replace(/([\^\$\.\*\+\?\|\[\]\(\)\{\}])/g, "\\\\$1"),
				regexp = ["^"],
				groups = [],
				index = 0,
				quoteCount = 0,
				tokenRegExp = getTokenRegExp(),
				match;

            // iterate through each date token found.
            while ((match = tokenRegExp.exec(expFormat)) !== null) {
                var preMatch = expFormat.slice(index, match.index);
                index = tokenRegExp.lastIndex;

                // don't replace any matches that occur inside a string literal.
                quoteCount += appendPreOrPostMatch(preMatch, regexp);
                if (quoteCount % 2) {
                    regexp.push(match[0]);
                    continue;
                }

                // add a regex group for the token.
                var m = match[0],
					len = m.length,
					add;
                switch (m) {
                    case "dddd": case "ddd":
                    case "MMMM": case "MMM":
                    case "gg": case "g":
                        add = "(\\D+)";
                        break;
                    case "tt": case "t":
                        add = "(\\D*)";
                        break;
                    case "yyyy":
                    case "fff":
                    case "ff":
                    case "f":
                        add = "(\\d{" + len + "})";
                        break;
                    case "dd": case "d":
                    case "MM": case "M":
                    case "yy": case "y":
                    case "HH": case "H":
                    case "hh": case "h":
                    case "mm": case "m":
                    case "ss": case "s":
                        add = "(\\d\\d?)";
                        break;
                    case "zzz":
                        add = "([+-]?\\d\\d?:\\d{2})";
                        break;
                    case "zz": case "z":
                        add = "([+-]?\\d\\d?)";
                        break;
                    case "/":
                        add = "(\\/)";
                        break;
                    default:
                        throw "Invalid date format pattern \'" + m + "\'.";
                }
                if (add) {
                    regexp.push(add);
                }
                groups.push(match[0]);
            }
            appendPreOrPostMatch(expFormat.slice(index), regexp);
            regexp.push("$");

            // allow whitespace to differ when matching formats.
            var regexpStr = regexp.join("").replace(/\s+/g, "\\s+"),
				parseRegExp = { "regExp": regexpStr, "groups": groups };

            // cache the regex for this format.
            return re[format] = parseRegExp;
        };

        outOfRange = function (value, low, high) {
            return value < low || value > high;
        };

        toUpper = function (value) {
            // "he-IL" has non-breaking space in weekday names.
            return value.split("\u00A0").join(" ").toUpperCase();
        };

        toUpperArray = function (arr) {
            var results = [];
            for (var i = 0, l = arr.length; i < l; i++) {
                results[i] = toUpper(arr[i]);
            }
            return results;
        };

        parseExact = function (value, format, culture) {
            // try to parse the date string by matching against the format string
            // while using the specified culture for date field names.
            value = trim(value);
            var cal = culture.calendar,
				// convert date formats into regular expressions with groupings.
				// use the regexp to determine the input format and extract the date fields.
				parseInfo = getParseRegExp(cal, format),
				match = new RegExp(parseInfo.regExp).exec(value);
            if (match === null) {
                return null;
            }
            // found a date format that matches the input.
            var groups = parseInfo.groups,
				era = null, year = null, month = null, date = null, weekDay = null,
				hour = 0, hourOffset, min = 0, sec = 0, msec = 0, tzMinOffset = null,
				pmHour = false;
            // iterate the format groups to extract and set the date fields.
            for (var j = 0, jl = groups.length; j < jl; j++) {
                var matchGroup = match[j + 1];
                if (matchGroup) {
                    var current = groups[j],
						clength = current.length,
						matchInt = parseInt(matchGroup, 10);
                    switch (current) {
                        case "dd": case "d":
                            // Day of month.
                            date = matchInt;
                            // check that date is generally in valid range, also checking overflow below.
                            if (outOfRange(date, 1, 31)) return null;
                            break;
                        case "MMM": case "MMMM":
                            month = getMonthIndex(cal, matchGroup, clength === 3);
                            if (outOfRange(month, 0, 11)) return null;
                            break;
                        case "M": case "MM":
                            // Month.
                            month = matchInt - 1;
                            if (outOfRange(month, 0, 11)) return null;
                            break;
                        case "y": case "yy":
                        case "yyyy":
                            year = clength < 4 ? expandYear(cal, matchInt) : matchInt;
                            if (outOfRange(year, 0, 9999)) return null;
                            break;
                        case "h": case "hh":
                            // Hours (12-hour clock).
                            hour = matchInt;
                            if (hour === 12) hour = 0;
                            if (outOfRange(hour, 0, 11)) return null;
                            break;
                        case "H": case "HH":
                            // Hours (24-hour clock).
                            hour = matchInt;
                            if (outOfRange(hour, 0, 23)) return null;
                            break;
                        case "m": case "mm":
                            // Minutes.
                            min = matchInt;
                            if (outOfRange(min, 0, 59)) return null;
                            break;
                        case "s": case "ss":
                            // Seconds.
                            sec = matchInt;
                            if (outOfRange(sec, 0, 59)) return null;
                            break;
                        case "tt": case "t":
                            // AM/PM designator.
                            // see if it is standard, upper, or lower case PM. If not, ensure it is at least one of
                            // the AM tokens. If not, fail the parse for this format.
                            pmHour = cal.PM && (matchGroup === cal.PM[0] || matchGroup === cal.PM[1] || matchGroup === cal.PM[2]);
                            if (
								!pmHour && (
									!cal.AM || (matchGroup !== cal.AM[0] && matchGroup !== cal.AM[1] && matchGroup !== cal.AM[2])
								)
							) return null;
                            break;
                        case "f":
                            // Deciseconds.
                        case "ff":
                            // Centiseconds.
                        case "fff":
                            // Milliseconds.
                            msec = matchInt * Math.pow(10, 3 - clength);
                            if (outOfRange(msec, 0, 999)) return null;
                            break;
                        case "ddd":
                            // Day of week.
                        case "dddd":
                            // Day of week.
                            weekDay = getDayIndex(cal, matchGroup, clength === 3);
                            if (outOfRange(weekDay, 0, 6)) return null;
                            break;
                        case "zzz":
                            // Time zone offset in +/- hours:min.
                            var offsets = matchGroup.split(/:/);
                            if (offsets.length !== 2) return null;
                            hourOffset = parseInt(offsets[0], 10);
                            if (outOfRange(hourOffset, -12, 13)) return null;
                            var minOffset = parseInt(offsets[1], 10);
                            if (outOfRange(minOffset, 0, 59)) return null;
                            tzMinOffset = (hourOffset * 60) + (startsWith(matchGroup, "-") ? -minOffset : minOffset);
                            break;
                        case "z": case "zz":
                            // Time zone offset in +/- hours.
                            hourOffset = matchInt;
                            if (outOfRange(hourOffset, -12, 13)) return null;
                            tzMinOffset = hourOffset * 60;
                            break;
                        case "g": case "gg":
                            var eraName = matchGroup;
                            if (!eraName || !cal.eras) return null;
                            eraName = trim(eraName.toLowerCase());
                            for (var i = 0, l = cal.eras.length; i < l; i++) {
                                if (eraName === cal.eras[i].name.toLowerCase()) {
                                    era = i;
                                    break;
                                }
                            }
                            // could not find an era with that name
                            if (era === null) return null;
                            break;
                    }
                }
            }
            var result = new Date(), defaultYear, convert = cal.convert;
            defaultYear = convert ? convert.fromGregorian(result)[0] : result.getFullYear();
            if (year === null) {
                year = defaultYear;
            }
            else if (cal.eras) {
                // year must be shifted to normal gregorian year
                // but not if year was not specified, its already normal gregorian
                // per the main if clause above.
                year += cal.eras[(era || 0)].offset;
            }
            // set default day and month to 1 and January, so if unspecified, these are the defaults
            // instead of the current day/month.
            if (month === null) {
                month = 0;
            }
            if (date === null) {
                date = 1;
            }
            // now have year, month, and date, but in the culture's calendar.
            // convert to gregorian if necessary
            if (convert) {
                result = convert.toGregorian(year, month, date);
                // conversion failed, must be an invalid match
                if (result === null) return null;
            }
            else {
                // have to set year, month and date together to avoid overflow based on current date.
                result.setFullYear(year, month, date);
                // check to see if date overflowed for specified month (only checked 1-31 above).
                if (result.getDate() !== date) return null;
                // invalid day of week.
                if (weekDay !== null && result.getDay() !== weekDay) {
                    return null;
                }
            }
            // if pm designator token was found make sure the hours fit the 24-hour clock.
            if (pmHour && hour < 12) {
                hour += 12;
            }
            result.setHours(hour, min, sec, msec);
            if (tzMinOffset !== null) {
                // adjust timezone to utc before applying local offset.
                var adjustedMin = result.getMinutes() - (tzMinOffset + result.getTimezoneOffset());
                // Safari limits hours and minutes to the range of -127 to 127.  We need to use setHours
                // to ensure both these fields will not exceed this range.	adjustedMin will range
                // somewhere between -1440 and 1500, so we only need to split this into hours.
                result.setHours(result.getHours() + parseInt(adjustedMin / 60, 10), adjustedMin % 60);
            }
            return result;
        };
    }());

    parseNegativePattern = function (value, nf, negativePattern) {
        var neg = nf["-"],
			pos = nf["+"],
			ret;
        switch (negativePattern) {
            case "n -":
                neg = " " + neg;
                pos = " " + pos;
                /* falls through */
            case "n-":
                if (endsWith(value, neg)) {
                    ret = ["-", value.substr(0, value.length - neg.length)];
                }
                else if (endsWith(value, pos)) {
                    ret = ["+", value.substr(0, value.length - pos.length)];
                }
                break;
            case "- n":
                neg += " ";
                pos += " ";
                /* falls through */
            case "-n":
                if (startsWith(value, neg)) {
                    ret = ["-", value.substr(neg.length)];
                }
                else if (startsWith(value, pos)) {
                    ret = ["+", value.substr(pos.length)];
                }
                break;
            case "(n)":
                if (startsWith(value, "(") && endsWith(value, ")")) {
                    ret = ["-", value.substr(1, value.length - 2)];
                }
                break;
        }
        return ret || ["", value];
    };

    //
    // public instance functions
    //

    Globalize.prototype.findClosestCulture = function (cultureSelector) {
        return Globalize.findClosestCulture.call(this, cultureSelector);
    };

    Globalize.prototype.format = function (value, format, cultureSelector) {
        return Globalize.format.call(this, value, format, cultureSelector);
    };

    Globalize.prototype.localize = function (key, cultureSelector) {
        return Globalize.localize.call(this, key, cultureSelector);
    };

    Globalize.prototype.parseInt = function (value, radix, cultureSelector) {
        return Globalize.parseInt.call(this, value, radix, cultureSelector);
    };

    Globalize.prototype.parseFloat = function (value, radix, cultureSelector) {
        return Globalize.parseFloat.call(this, value, radix, cultureSelector);
    };

    Globalize.prototype.culture = function (cultureSelector) {
        return Globalize.culture.call(this, cultureSelector);
    };

    //
    // public singleton functions
    //

    Globalize.addCultureInfo = function (cultureName, baseCultureName, info) {

        var base = {},
			isNew = false;

        if (typeof cultureName !== "string") {
            // cultureName argument is optional string. If not specified, assume info is first
            // and only argument. Specified info deep-extends current culture.
            info = cultureName;
            cultureName = this.culture().name;
            base = this.cultures[cultureName];
        } else if (typeof baseCultureName !== "string") {
            // baseCultureName argument is optional string. If not specified, assume info is second
            // argument. Specified info deep-extends specified culture.
            // If specified culture does not exist, create by deep-extending default
            info = baseCultureName;
            isNew = (this.cultures[cultureName] == null);
            base = this.cultures[cultureName] || this.cultures["default"];
        } else {
            // cultureName and baseCultureName specified. Assume a new culture is being created
            // by deep-extending an specified base culture
            isNew = true;
            base = this.cultures[baseCultureName];
        }

        this.cultures[cultureName] = extend(true, {},
			base,
			info
		);
        // Make the standard calendar the current culture if it's a new culture
        if (isNew) {
            this.cultures[cultureName].calendar = this.cultures[cultureName].calendars.standard;
        }
    };

    Globalize.findClosestCulture = function (name) {
        var match;
        if (!name) {
            return this.findClosestCulture(this.cultureSelector) || this.cultures["default"];
        }
        if (typeof name === "string") {
            name = name.split(",");
        }
        if (isArray(name)) {
            var lang,
				cultures = this.cultures,
				list = name,
				i, l = list.length,
				prioritized = [];
            for (i = 0; i < l; i++) {
                name = trim(list[i]);
                var pri, parts = name.split(";");
                lang = trim(parts[0]);
                if (parts.length === 1) {
                    pri = 1;
                }
                else {
                    name = trim(parts[1]);
                    if (name.indexOf("q=") === 0) {
                        name = name.substr(2);
                        pri = parseFloat(name);
                        pri = isNaN(pri) ? 0 : pri;
                    }
                    else {
                        pri = 1;
                    }
                }
                prioritized.push({ lang: lang, pri: pri });
            }
            prioritized.sort(function (a, b) {
                if (a.pri < b.pri) {
                    return 1;
                } else if (a.pri > b.pri) {
                    return -1;
                }
                return 0;
            });
            // exact match
            for (i = 0; i < l; i++) {
                lang = prioritized[i].lang;
                match = cultures[lang];
                if (match) {
                    return match;
                }
            }

            // neutral language match
            for (i = 0; i < l; i++) {
                lang = prioritized[i].lang;
                do {
                    var index = lang.lastIndexOf("-");
                    if (index === -1) {
                        break;
                    }
                    // strip off the last part. e.g. en-US => en
                    lang = lang.substr(0, index);
                    match = cultures[lang];
                    if (match) {
                        return match;
                    }
                }
                while (1);
            }

            // last resort: match first culture using that language
            for (i = 0; i < l; i++) {
                lang = prioritized[i].lang;
                for (var cultureKey in cultures) {
                    var culture = cultures[cultureKey];
                    if (culture.language == lang) {
                        return culture;
                    }
                }
            }
        }
        else if (typeof name === "object") {
            return name;
        }
        return match || null;
    };

    Globalize.format = function (value, format, cultureSelector) {
        var culture = this.findClosestCulture(cultureSelector);
        if (value instanceof Date) {
            value = formatDate(value, format, culture);
        }
        else if (typeof value === "number") {
            value = formatNumber(value, format, culture);
        }
        return value;
    };

    Globalize.localize = function (key, cultureSelector) {
        return this.findClosestCulture(cultureSelector).messages[key] ||
			this.cultures["default"].messages[key];
    };

    Globalize.parseDate = function (value, formats, culture) {
        culture = this.findClosestCulture(culture);

        var date, prop, patterns;
        if (formats) {
            if (typeof formats === "string") {
                formats = [formats];
            }
            if (formats.length) {
                for (var i = 0, l = formats.length; i < l; i++) {
                    var format = formats[i];
                    if (format) {
                        date = parseExact(value, format, culture);
                        if (date) {
                            break;
                        }
                    }
                }
            }
        } else {
            patterns = culture.calendar.patterns;
            for (prop in patterns) {
                date = parseExact(value, patterns[prop], culture);
                if (date) {
                    break;
                }
            }
        }

        return date || null;
    };

    Globalize.parseInt = function (value, radix, cultureSelector) {
        return truncate(Globalize.parseFloat(value, radix, cultureSelector));
    };

    Globalize.parseFloat = function (value, radix, cultureSelector) {
        // radix argument is optional
        if (typeof radix !== "number") {
            cultureSelector = radix;
            radix = 10;
        }

        var culture = this.findClosestCulture(cultureSelector);
        var ret = NaN,
			nf = culture.numberFormat;

        if (value.indexOf(culture.numberFormat.currency.symbol) > -1) {
            // remove currency symbol
            value = value.replace(culture.numberFormat.currency.symbol, "");
            // replace decimal seperator
            value = value.replace(culture.numberFormat.currency["."], culture.numberFormat["."]);
        }

        //Remove percentage character from number string before parsing
        if (value.indexOf(culture.numberFormat.percent.symbol) > -1) {
            value = value.replace(culture.numberFormat.percent.symbol, "");
        }

        // remove spaces: leading, trailing and between - and number. Used for negative currency pt-BR
        value = value.replace(/ /g, "");

        // allow infinity or hexidecimal
        if (regexInfinity.test(value)) {
            ret = parseFloat(value);
        }
        else if (!radix && regexHex.test(value)) {
            ret = parseInt(value, 16);
        }
        else {

            // determine sign and number
            var signInfo = parseNegativePattern(value, nf, nf.pattern[0]),
				sign = signInfo[0],
				num = signInfo[1];

            // #44 - try parsing as "(n)"
            if (sign === "" && nf.pattern[0] !== "(n)") {
                signInfo = parseNegativePattern(value, nf, "(n)");
                sign = signInfo[0];
                num = signInfo[1];
            }

            // try parsing as "-n"
            if (sign === "" && nf.pattern[0] !== "-n") {
                signInfo = parseNegativePattern(value, nf, "-n");
                sign = signInfo[0];
                num = signInfo[1];
            }

            sign = sign || "+";

            // determine exponent and number
            var exponent,
				intAndFraction,
				exponentPos = num.indexOf("e");
            if (exponentPos < 0) exponentPos = num.indexOf("E");
            if (exponentPos < 0) {
                intAndFraction = num;
                exponent = null;
            }
            else {
                intAndFraction = num.substr(0, exponentPos);
                exponent = num.substr(exponentPos + 1);
            }
            // determine decimal position
            var integer,
				fraction,
				decSep = nf["."],
				decimalPos = intAndFraction.indexOf(decSep);
            if (decimalPos < 0) {
                integer = intAndFraction;
                fraction = null;
            }
            else {
                integer = intAndFraction.substr(0, decimalPos);
                fraction = intAndFraction.substr(decimalPos + decSep.length);
            }
            // handle groups (e.g. 1,000,000)
            var groupSep = nf[","];
            integer = integer.split(groupSep).join("");
            var altGroupSep = groupSep.replace(/\u00A0/g, " ");
            if (groupSep !== altGroupSep) {
                integer = integer.split(altGroupSep).join("");
            }
            // build a natively parsable number string
            var p = sign + integer;
            if (fraction !== null) {
                p += "." + fraction;
            }
            if (exponent !== null) {
                // exponent itself may have a number patternd
                var expSignInfo = parseNegativePattern(exponent, nf, "-n");
                p += "e" + (expSignInfo[0] || "+") + expSignInfo[1];
            }
            if (regexParseFloat.test(p)) {
                ret = parseFloat(p);
            }
        }
        return ret;
    };

    Globalize.culture = function (cultureSelector) {
        // setter
        if (typeof cultureSelector !== "undefined") {
            this.cultureSelector = cultureSelector;
        }
        // getter
        return this.findClosestCulture(cultureSelector) || this.cultures["default"];
    };

}(this));

//#endregion End Globalize

//#region cookie

/*!
 * JavaScript Cookie v2.0.4
 * https://github.com/js-cookie/js-cookie
 *
 * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
 * Released under the MIT license
 */
(function (factory) {
	if (typeof define === 'function' && define.amd) {
		define(factory);
	} else if (typeof exports === 'object') {
		module.exports = factory();
	} else {
		var _OldCookies = window.Cookies;
		var api = window.Cookies = factory();
		api.noConflict = function () {
			window.Cookies = _OldCookies;
			return api;
		};
	}
}(function () {
	function extend () {
		var i = 0;
		var result = {};
		for (; i < arguments.length; i++) {
			var attributes = arguments[ i ];
			for (var key in attributes) {
				result[key] = attributes[key];
			}
		}
		return result;
	}

	function init (converter) {
		function api (key, value, attributes) {
			var result;

			// Write

			if (arguments.length > 1) {
				attributes = extend({
					path: '/'
				}, api.defaults, attributes);

				if (typeof attributes.expires === 'number') {
					var expires = new Date();
					expires.setMilliseconds(expires.getMilliseconds() + attributes.expires * 864e+5);
					attributes.expires = expires;
				}

				try {
					result = JSON.stringify(value);
					if (/^[\{\[]/.test(result)) {
						value = result;
					}
				} catch (e) {}

				value = encodeURIComponent(String(value));
				value = value.replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);

				key = encodeURIComponent(String(key));
				key = key.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent);
				key = key.replace(/[\(\)]/g, escape);

				return (document.cookie = [
					key, '=', value,
					attributes.expires && '; expires=' + attributes.expires.toUTCString(), // use expires attribute, max-age is not supported by IE
					attributes.path    && '; path=' + attributes.path,
					attributes.domain  && '; domain=' + attributes.domain,
					attributes.secure ? '; secure' : ''
				].join(''));
			}

			// Read

			if (!key) {
				result = {};
			}

			// To prevent the for loop in the first place assign an empty array
			// in case there are no cookies at all. Also prevents odd result when
			// calling "get()"
			var cookies = document.cookie ? document.cookie.split('; ') : [];
			var rdecode = /(%[0-9A-Z]{2})+/g;
			var i = 0;

			for (; i < cookies.length; i++) {
				var parts = cookies[i].split('=');
				var name = parts[0].replace(rdecode, decodeURIComponent);
				var cookie = parts.slice(1).join('=');

				if (cookie.charAt(0) === '"') {
					cookie = cookie.slice(1, -1);
				}

				try {
					cookie = converter && converter(cookie, name) || cookie.replace(rdecode, decodeURIComponent);

					if (this.json) {
						try {
							cookie = JSON.parse(cookie);
						} catch (e) {}
					}

					if (key === name) {
						result = cookie;
						break;
					}

					if (!key) {
						result[name] = cookie;
					}
				} catch (e) {}
			}

			return result;
		}

		api.get = api.set = api;
		api.getJSON = function () {
			return api.apply({
				json: true
			}, [].slice.call(arguments));
		};
		api.defaults = {};

		api.remove = function (key, attributes) {
			api(key, '', extend(attributes, {
				expires: -1
			}));
		};

		api.withConverter = init;

		return api;
	}

	return init();
}));

//#endregion End cookie

//#region Paging

/**
 * @license jQuery paging plugin v1.1.0 02/05/2013
 * http://www.xarg.org/2011/09/jquery-pagination-revised/
 *
 * Copyright (c) 2011, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * 
 * [2015-11-05] Changed how onFormat and onSelect callbacks are invoked. Instead of passing data that is accessible using 'this',
 *              the data was passed as a parameter. This was required to avoid conflicts with how TypeScript uses 'this'.
 **/

(function ($, window, undefined) {


    $["fn"]["paging"] = function (number, opts) {

        var self = this,
        Paging = {

            "setOptions": function (opts) {

                function parseFormat(format) {

                    var gndx = 0, group = 0, num = 1, res = {
                        fstack: [], // format stack
                        asterisk: 0, // asterisk?
                        inactive: 0, // fill empty pages with inactives up to w?
                        blockwide: 5, // width of number block
                        current: 3, // position of current element in number block
                        rights: 0, // num of rights
                        lefts: 0 // num of lefts
                    }, tok, pattern = /[*<>pq\[\]().-]|[nc]+!?/g;

                    var known = {
                        "[": "first",
                        "]": "last",
                        "<": "prev",
                        ">": "next",
                        "q": "left",
                        "p": "right",
                        "-": "fill",
                        ".": "leap"
                    }, count = {};

                    while ((tok = pattern["exec"](format))) {

                        tok = String(tok);

                        if (undefined === known[tok]) {

                            if ("(" === tok) {
                                group = ++gndx;
                            } else if (")" === tok) {
                                group = 0;
                            } else if (num) {

                                if ("*" === tok) {
                                    res.asterisk = 1;
                                    res.inactive = 0;
                                } else {
                                    // number block is the only thing left here
                                    res.asterisk = 0;
                                    res.inactive = "!" === tok.charAt(tok.length - 1);
                                    res.blockwide = tok["length"] - res.inactive;
                                    if (!(res.current = 1 + tok.indexOf("c"))) {
                                        res.current = (1 + res.blockwide) >> 1;
                                    }
                                }

                                res.fstack[res.fstack.length] = ({
                                    ftype: "block",	// type
                                    fgroup: 0,		// group
                                    fpos: 0		// pos
                                });
                                num = 0;
                            }

                        } else {

                            res.fstack[res.fstack.length] = ({
                                ftype: known[tok], // type
                                fgroup: group,      // group
                                fpos: undefined === count[tok] ? count[tok] = 1 : ++count[tok] // pos
                            });

                            if ("q" === tok)
                                ++res.lefts;
                            else if ("p" === tok)
                                ++res.rights;
                        }
                    }
                    return res;
                }

                this.opts = $.extend(this.opts || {
                    "lapping": 0,	// number of elements overlap
                    "perpage": 10,	// number of elements per page
                    "page": 1,	// current page
                    "refresh": {
                        "interval": 10,
                        "url": null
                    },	// refresh callback information

                    "format": "",	// visual format string

                    "onLock": null, // empty callback. set it if you want to lock the entire pagination

                    "onFormat": function (type) {	// callback for every format element

                        /** EXAMPLE **

        switch (type) {

            case 'block':

                if (!this.active)
                    return '<span class="disabled">' + this.value + '</span>';
                else if (this.value != this.page)
                    return '<em><a href="#' + this.value + '">' + this.value + '</a></em>';
                return '<span class="current">' + this.value + '</span>';

            case 'right':
            case 'left':

                if (!this.active) {
                    return "";
                }
                return '<a href="#' + this.value + '">' + this.value + '</a>';

            case 'next':

                if (this.active) {
                    return '<a href="#' + this.value + '" class="next">Next &raquo;</a>';
                }
                return '<span class="disabled">Next &raquo;</span>';

            case 'prev':

                if (this.active) {
                    return '<a href="#' + this.value + '" class="prev">&laquo; Previous</a>';
                }
                return '<span class="disabled">&laquo; Previous</span>';

            case 'first':

                if (this.active) {
                    return '<a href="#' + this.value + '" class="first">|&lt;</a>';
                }
                return '<span class="disabled">|&lt;</span>';

            case 'last':

                if (this.active) {
                    return '<a href="#' + this.value + '" class="prev">&gt;|</a>';
                }
                return '<span class="disabled">&gt;|</span>';

            case 'fill':
                if (this.active) {
                    return "...";
                }
        }
        return ""; // return nothing for missing branches

        **/
                    },
                    "onSelect": function (page) {	// callback for page selection

                        /** EXAMPLE SLICE **

var data = this.slice;

content.slice(prev[0], prev[1]).css('display', 'none');
content.slice(data[0], data[1]).css('display', 'block');

prev = data;

**/


                        /** EXAMPLE AJAX **

$.ajax({
    "url": '/data.php?start=' + this.slice[0] + '&end=' + this.slice[1] + '&page=' + page,
    "success": function(data) {
        // content replace
    }
});

 **/

                        // Return code indicates if the link of the clicked format element should be followed (otherwise only the click-event is used)
                        return true;
                    },
                    "onRefresh": function (json) {// callback for new data of refresh api

                        /** EXAMPLE **
        if (json.number) {
            Paging.setNumber(json.number);
        }

        if (json.options) {
            Paging.setOptions(json.options);
        }

        Paging.setPage(); // Call with empty params to reload the paginator
        **/
                    }
                }, opts || {});

                this.opts["lapping"] |= 0;
                this.opts["perpage"] |= 0;
                if (this.opts["page"] !== null) this.opts["page"] |= 0;

                // If the number of elements per page is less then 1, set it to default
                if (this.opts["perpage"] < 1) {
                    this.opts["perpage"] = 10;
                }

                if (this.interval) window.clearInterval(this.interval);

                if (this.opts["refresh"]["url"]) {

                    this.interval = window.setInterval(function (o) {

                        $["ajax"]({
                            "url": o.opts["refresh"]["url"],
                            "success": function (data) {

                                if (typeof (data) === "string") {

                                    try {
                                        data = $["parseJSON"](data);
                                    } catch (o) {
                                        return;
                                    }
                                }
                                o.opts["onRefresh"](data);
                            }
                        });

                    }, 1000 * this.opts["refresh"]["interval"], this);
                }

                this.format = parseFormat(this.opts["format"]);
                return this;
            },

            "setNumber": function (number) {
                this.number = (undefined === number || number < 0) ? -1 : number;
                return this;
            },

            "setPage": function (page) {

                if (undefined === page) {

                    if (page = this.opts["page"], null === page) {
                        return this;
                    }

                } else if (this.opts["page"] == page) {
                    return this;
                }

                this.opts["page"] = (page |= 0);

                if (null !== this.opts["onLock"]) {
                    this.opts["onLock"].call(null, page);
                    return this;
                }

                var number = this.number;
                var opts = this.opts;

                var rStart, rStop;

                var pages, buffer;

                var groups = 1, format = this.format;

                var data, tmp, node, lapping;

                var count = format.fstack["length"], i = count;


                // If the lapping is greater than perpage, reduce it to perpage - 1 to avoid endless loops
                if (opts["perpage"] <= opts["lapping"]) {
                    opts["lapping"] = opts["perpage"] - 1;
                }

                lapping = number <= opts["lapping"] ? 0 : opts["lapping"] | 0;


                // If the number is negative, the value doesn"t matter, we loop endlessly with a constant width
                if (number < 0) {

                    number = -1;
                    pages = -1;

                    rStart = Math.max(1, page - format.current + 1 - lapping);
                    rStop = rStart + format.blockwide;

                } else {

                    // Calculate the number of pages
                    pages = 1 + Math.ceil((number - opts["perpage"]) / (opts["perpage"] - lapping));

                    // If current page is negative, start at the end and
                    // Set the current page into a valid range, includes 0, which is set to 1
                    page = Math.max(1, Math.min(page < 0 ? 1 + pages + page : page, pages));

                    // Do we need to print all numbers?
                    if (format.asterisk) {
                        rStart = 1;
                        rStop = 1 + pages;

                        // Disable :first and :last for asterisk mode as we see all buttons
                        format.current = page;
                        format.blockwide = pages;

                    } else {

                        // If no, start at the best position and stop at max width or at num of pages
                        rStart = Math.max(1, Math.min(page - format.current, pages - format.blockwide) + 1);
                        rStop = format.inactive ? rStart + format.blockwide : Math.min(rStart + format.blockwide, 1 + pages);
                    }
                }

                while (i--) {

                    tmp = 0; // default everything is visible
                    node = format.fstack[i];

                    switch (node.ftype) {

                        case "left":
                            tmp = (node.fpos < rStart);
                            break;
                        case "right":
                            tmp = (rStop <= pages - format.rights + node.fpos);
                            break;

                        case "first":
                            tmp = (format.current < page);
                            break;
                        case "last":
                            tmp = (format.blockwide < format.current + pages - page);
                            break;

                        case "prev":
                            tmp = (1 < page);
                            break;
                        case "next":
                            tmp = (page < pages);
                            break;
                    }
                    groups |= tmp << node.fgroup; // group visible?
                }

                data = {
                    "number": number,	// number of elements
                    "lapping": lapping,	// overlapping
                    "pages": pages,	// number of pages
                    "perpage": opts["perpage"], // number of elements per page
                    "page": page,		// current page
                    "slice": [			// two element array with bounds of the current page selection
                    (tmp = page * (opts["perpage"] - lapping) + lapping) - opts["perpage"], // Lower bound
                    Math.min(tmp, number) // Upper bound
                    ]
                };

                buffer = "";

                function buffer_append(opts, data, type) {

                    type = String(opts["onFormat"].call(self, data, type));

                    if (data["value"])
                        buffer += type.replace(/<a/i, '<a data-page="' + data["value"] + '"');
                    else
                        buffer += type
                }

                while (++i < count) {

                    node = format.fstack[i];

                    tmp = (groups >> node.fgroup & 1);

                    switch (node.ftype) {
                        case "block":
                            for (; rStart < rStop; ++rStart) {

                                data["value"] = rStart;
                                data["pos"] = 1 + format.blockwide - rStop + rStart;

                                data["active"] = rStart <= pages || number < 0;     // true if infinity series and rStart <= pages
                                data["first"] = 1 === rStart;                      // check if it is the first page
                                data["last"] = rStart == pages && 0 < number;     // false if infinity series or rStart != pages

                                buffer_append(opts, data, node.ftype);
                            }
                            continue;

                        case "left":
                            data["value"] = node.fpos;
                            data["active"] = node.fpos < rStart; // Don't take group-visibility into account!
                            break;

                        case "right":
                            data["value"] = pages - format.rights + node.fpos;
                            data["active"] = rStop <= data["value"]; // Don't take group-visibility into account!
                            break;

                        case "first":
                            data["value"] = 1;
                            data["active"] = tmp && 1 < page;
                            break;

                        case "prev":
                            data["value"] = Math.max(1, page - 1);
                            data["active"] = tmp && 1 < page;
                            break;

                        case "last":
                            if ((data["active"] = (number < 0))) {
                                data["value"] = 1 + page;
                            } else {
                                data["value"] = pages;
                                data["active"] = tmp && page < pages;
                            }
                            break;

                        case "next":
                            if ((data["active"] = (number < 0))) {
                                data["value"] = 1 + page;
                            } else {
                                data["value"] = Math.min(1 + page, pages);
                                data["active"] = tmp && page < pages;
                            }
                            break;

                        case "leap":
                        case "fill":
                            data["pos"] = node.fpos;
                            data["active"] = tmp; // tmp is true by default and changes only for group behaviour
                            buffer_append(opts, data, node.ftype);
                            continue;
                    }

                    data["pos"] = node.fpos;
                    data["last"] = /* void */
                    data["first"] = undefined;

                    buffer_append(opts, data, node.ftype);
                }

                if (self.length) {

                    $("a", self["html"](buffer)).click(function (ev) {
                        ev["preventDefault"]();

                        var obj = this;

                        do {

                            if ('a' === obj["nodeName"].toLowerCase()) {
                                break;
                            }

                        } while ((obj = obj["parentNode"]));

                        Paging["setPage"]($(obj).data("page"));

                        if (Paging.locate) {
                            window.location = obj["href"];
                        }
                    });

                    this.locate = opts["onSelect"].call(self, {
                        "number": number,
                        "lapping": lapping,
                        "pages": pages,
                        "slice": data["slice"]
                    }, page);
                }
                return this;
            }
        };

        return Paging
        ["setNumber"](number)
        ["setOptions"](opts)
        ["setPage"]();
    }

}(jQuery, this));

//#endregion End Paging

//#region Splitter

/*
 * jQuery.splitter.js - two-pane splitter window plugin
 *
 * version 1.6 (2010/01/03)
 * version 1.61 (2012/05/09) -- Fixes by Roger Martin
 *  * Added check in window resize event handler to run only when the target is the window. This fixes a breaking
 *    change introduced in jQuery 1.6.
 *  * Added support for IE 9+
 * version 1.62 (2012/05/16) -- Fixes by Roger Martin
 *  * Included bottom padding of body and html elements when calculating height. This elimates vertical scroll bar and thus a need for overflow:none on the body element
 * version 1.63 (2012/08/12) -- Fixes by Roger Martin
 *  * Changed curCSS to css (curCSS was removed in jQuery 1.8)
 * version 1.64 (2013/01/08) -- Fixes by Roger Martin
 *  * sizeLeft and sizeRight was being ignored when cookie option was used
 * version 1.65 (2013/01/09) -- Fixes by Roger Martin
 *  * Fixed issue where scrollbars were still appearing in IE.
 * version 1.66 (2015/10/16) -- Fixes by Roger Martin
    Removed references to $.browser
 * version 1.67 (2015/10/28) -- Fixes by Roger Martin
    Changed references to $.cookie to Gs.Vars.Cookies (Gs.Vars.Cookies is defined by noConflict() in Gs.Utils.Init. Change required by upgrade from jQuery cookies plugin to JavaScript Cookie)
 * version 1.68 (2016/01/11) -- Fixes by Roger Martin
    Changed z-index of splitter bar from 100 to 2 (required to prevent it from showing through the dialogs from the ribbon toolbar)
 * version 1.69 (2016/10/10) -- Fixes by Roger Martin
    Replaced jQuery bind() and unbind() functions with on() and off().
 *
 * Dual licensed under the MIT and GPL licenses:
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 */

/**
 * The splitter() plugin implements a two-pane resizable splitter window.
 * The selected elements in the jQuery object are converted to a splitter;
 * each selected element should have two child elements, used for the panes
 * of the splitter. The plugin adds a third child element for the splitbar.
 *
 * For more details see: http://www.methvin.com/splitter/
 *
 *
 * @example $('#MySplitter').splitter();
 * @desc Create a vertical splitter with default settings
 *
 * @example $('#MySplitter').splitter({type: 'h', accessKey: 'M'});
 * @desc Create a horizontal splitter resizable via Alt+Shift+M
 *
 * @name splitter
 * @type jQuery
 * @param Object options Options for the splitter (not required)
 * @cat Plugins/Splitter
 * @return jQuery
 * @author Dave Methvin (dave.methvin@gmail.com)
 */
; (function ($) {

    var splitterCounter = 0;

    $.fn.splitter = function (args) {
        args = args || {};
        return this.each(function () {
            if ($(this).is(".splitter"))	// already a splitter
                return;
            var zombie;		// left-behind splitbar for outline resizes
            function setBarState(state) {
                bar.removeClass(opts.barStateClasses).addClass(state);
            }
            function startSplitMouse(evt) {
                if (evt.which != 1)
                    return;		// left button only
                bar.removeClass(opts.barHoverClass);
                if (opts.outline) {
                    zombie = zombie || bar.clone(false).insertAfter(A);
                    bar.removeClass(opts.barDockedClass);
                }
                setBarState(opts.barActiveClass)
                // Safari selects A/B text on a move; iframes capture mouse events so hide them
                panes.css("-webkit-user-select", "none").find("iframe").addClass(opts.iframeClass);
                A._posSplit = A[0][opts.pxSplit] - evt[opts.eventPos];
                $(document)
             .on("mousemove" + opts.eventNamespace, doSplitMouse)
             .on("mouseup" + opts.eventNamespace, endSplitMouse);
            }
            function doSplitMouse(evt) {
                var pos = A._posSplit + evt[opts.eventPos],
             range = Math.max(0, Math.min(pos, splitter._DA - bar._DA)),
             limit = Math.max(A._min, splitter._DA - B._max,
                     Math.min(pos, A._max, splitter._DA - bar._DA - B._min));
                if (opts.outline) {
                    // Let docking splitbar be dragged to the dock position, even if min width applies
                    if ((opts.dockPane == A && pos < Math.max(A._min, bar._DA)) ||
                    (opts.dockPane == B && pos > Math.min(pos, A._max, splitter._DA - bar._DA - B._min))) {
                        bar.addClass(opts.barDockedClass).css(opts.origin, range);
                    }
                    else {
                        bar.removeClass(opts.barDockedClass).css(opts.origin, limit);
                    }
                    bar._DA = bar[0][opts.pxSplit];
                } else
                    resplit(pos);
                setBarState(pos == limit ? opts.barActiveClass : opts.barLimitClass);
            }
            function endSplitMouse(evt) {
                setBarState(opts.barNormalClass);
                bar.addClass(opts.barHoverClass);
                var pos = A._posSplit + evt[opts.eventPos];
                if (opts.outline) {
                    zombie.remove(); zombie = null;
                    resplit(pos);
                }
                panes.css("-webkit-user-select", "text").find("iframe").removeClass(opts.iframeClass);
                $(document)
             .off("mousemove" + opts.eventNamespace + " mouseup" + opts.eventNamespace);
            }
            function resplit(pos) {
                bar._DA = bar[0][opts.pxSplit];		// bar size may change during dock
                // Constrain new splitbar position to fit pane size and docking limits
                if ((opts.dockPane == A && pos < Math.max(A._min, bar._DA)) ||
                (opts.dockPane == B && pos > Math.min(pos, A._max, splitter._DA - bar._DA - B._min))) {
                    bar.addClass(opts.barDockedClass);
                    bar._DA = bar[0][opts.pxSplit];
                    pos = opts.dockPane == A ? 0 : splitter._DA - bar._DA;
                    if (bar._pos == null)
                        bar._pos = A[0][opts.pxSplit];
                }
                else {
                    bar.removeClass(opts.barDockedClass);
                    bar._DA = bar[0][opts.pxSplit];
                    bar._pos = null;
                    pos = Math.max(A._min, splitter._DA - B._max,
                     Math.min(pos, A._max, splitter._DA - bar._DA - B._min));
                }
                // Resize/position the two panes
                bar.css(opts.origin, pos).css(opts.fixed, splitter._DF);
                A.css(opts.origin, 0).css(opts.split, pos).css(opts.fixed, splitter._DF);
                B.css(opts.origin, pos + bar._DA)
             .css(opts.split, splitter._DA - bar._DA - pos).css(opts.fixed, splitter._DF);
                for (i = 0; i <= splitterCounter; i++) {
                    panes.trigger("resize" + eventNamespaceBase + i);
                }
            }
            function dimSum(jq, dims) {
                // Opera returns -1 for missing min/max width, turn into 0
                var sum = 0;
                for (var i = 1; i < arguments.length; i++)
                    sum += Math.max(parseInt(jq.css(arguments[i]), 10) || 0, 0);
                return sum;
            }

            // Determine settings based on incoming opts, element classes, and defaults
            var vh = (args.splitHorizontal ? 'h' : args.splitVertical ? 'v' : args.type) || 'v';
            var eventNamespaceBase = ".splitter";
            var opts = $.extend({
                // Defaults here allow easy use with ThemeRoller
                splitterClass: "splitter gsp-ui-widget gsp-ui-widget-content",
                paneClass: "splitter-pane",
                barClass: "splitter-bar",
                barNormalClass: "gsp-ui-state-default",			// splitbar normal
                barHoverClass: "gsp-ui-state-hover",			// splitbar mouse hover
                barActiveClass: "gsp-ui-state-highlight",		// splitbar being moved
                barLimitClass: "gsp-ui-state-error",			// splitbar at limit
                iframeClass: "splitter-iframe-hide",		// hide iframes during split
                eventNamespace: eventNamespaceBase + (++splitterCounter),
                pxPerKey: 8,			// splitter px moved per keypress
                tabIndex: 0,			// tab order indicator
                accessKey: ''			// accessKey for splitbar
            }, {
                // user can override
                v: {					// Vertical splitters:
                    keyLeft: 39, keyRight: 37, cursor: "e-resize",
                    barStateClass: "splitter-bar-vertical",
                    barDockedClass: "splitter-bar-vertical-docked"
                },
                h: {					// Horizontal splitters:
                    keyTop: 40, keyBottom: 38, cursor: "n-resize",
                    barStateClass: "splitter-bar-horizontal",
                    barDockedClass: "splitter-bar-horizontal-docked"
                }
            }[vh], args, {
                // user cannot override
                v: {					// Vertical splitters:
                    type: 'v', eventPos: "pageX", origin: "left",
                    split: "width", pxSplit: "offsetWidth", side1: "Left", side2: "Right",
                    fixed: "height", pxFixed: "offsetHeight", side3: "Top", side4: "Bottom"
                },
                h: {					// Horizontal splitters:
                    type: 'h', eventPos: "pageY", origin: "top",
                    split: "height", pxSplit: "offsetHeight", side1: "Top", side2: "Bottom",
                    fixed: "width", pxFixed: "offsetWidth", side3: "Left", side4: "Right"
                }
            }[vh]);
            opts.barStateClasses = [opts.barNormalClass, opts.barHoverClass, opts.barActiveClass, opts.barLimitClass].join(' ');

            // Create jQuery object closures for splitter and both panes
            var splitter = $(this).css({ position: "relative" }).addClass(opts.splitterClass);
            var panes = $(">*", splitter[0]).addClass(opts.paneClass).css({
                position: "absolute", 			// positioned inside splitter container
                "z-index": "1",					// splitbar is positioned above
                "-moz-outline-style": "none"	// don't show dotted outline
            });
            var A = $(panes[0]), B = $(panes[1]);	// A = left/top, B = right/bottom
            opts.dockPane = opts.dock && (/right|bottom/.test(opts.dock) ? B : A);

            // Focuser element, provides keyboard support; title is shown by Opera accessKeys
            var focuser = $('<a href="javascript:void(0)"></a>')
         .attr({ accessKey: opts.accessKey, tabIndex: opts.tabIndex, title: opts.splitbarClass })
         .on("focus" + opts.eventNamespace,
             function () { this.focus(); bar.addClass(opts.barActiveClass) })
         .on("keydown" + opts.eventNamespace, function (e) {
             var key = e.which || e.keyCode;
             var dir = key == opts["key" + opts.side1] ? 1 : key == opts["key" + opts.side2] ? -1 : 0;
             if (dir)
                 resplit(A[0][opts.pxSplit] + dir * opts.pxPerKey, false);
         })
         .on("blur" + opts.eventNamespace,
             function () { bar.removeClass(opts.barActiveClass) });

            // Splitbar element
            var bar = $('<div></div>')
         .insertAfter(A).addClass(opts.barClass).addClass(opts.barStateClass)
         .append(focuser).attr({ unselectable: "on" })
         .css({
             position: "absolute", "user-select": "none", "-webkit-user-select": "none",
             "-khtml-user-select": "none", "-moz-user-select": "none", "z-index": "2"  //[RDM] Changed z-index from 100 to 2
         })
         .on("mousedown" + opts.eventNamespace, startSplitMouse)
         .on("mouseover" + opts.eventNamespace, function () {
             $(this).addClass(opts.barHoverClass);
         })
         .on("mouseout" + opts.eventNamespace, function () {
             $(this).removeClass(opts.barHoverClass);
         });
            // Use our cursor unless the style specifies a non-default cursor
            if (/^(auto|default|)$/.test(bar.css("cursor")))
                bar.css("cursor", opts.cursor);

            // Cache several dimensions for speed, rather than re-querying constantly
            // These are saved on the A/B/bar/splitter jQuery vars, which are themselves cached
            // DA=dimension adjustable direction, PBF=padding/border fixed, PBA=padding/border adjustable
            bar._DA = bar[0][opts.pxSplit];
            splitter._PBF = dimSum(splitter, "border" + opts.side3 + "Width", "border" + opts.side4 + "Width");
            splitter._PBA = dimSum(splitter, "border" + opts.side1 + "Width", "border" + opts.side2 + "Width");
            A._pane = opts.side1;
            B._pane = opts.side2;
            $.each([A, B], function () {
                this._splitter_style = this.style;
                this._min = opts["min" + this._pane] || dimSum(this, "min-" + opts.split);
                this._max = opts["max" + this._pane] || dimSum(this, "max-" + opts.split) || 9999;
                this._init = opts["size" + this._pane] === true ?
             parseInt($.css(this[0], opts.split), 10) : opts["size" + this._pane]; //[RDM] Changed curCSS to css (curCSS was removed in jQuery 1.8)
            });

            // Determine initial position, get from cookie if specified
            var initPos = A._init;
            if (!isNaN(B._init))	// recalc initial B size as an offset from the top or left side
                initPos = splitter[0][opts.pxSplit] - splitter._PBA - B._init - bar._DA;
            if (opts.cookie) {
                if (!Gs.Vars.Cookies)
                    alert('jQuery.splitter(): jQuery cookie plugin required');
                var cookieVal = parseInt(Gs.Vars.Cookies.get(opts.cookie), 10);
                if (!isNaN(cookieVal))
                    initPos = cookieVal; //[RDM] Overwrite initPos only when we found a cookie (instead of always)
                $(window).on("unload" + opts.eventNamespace, function () {
                    var state = String(bar.css(opts.origin));	// current location of splitbar
                    Gs.Vars.Cookies.set(opts.cookie, state, {
                        expires: opts.cookieExpires || 365,
                        path: opts.cookiePath || document.location.pathname
                    });
                });
            }
            if (isNaN(initPos))	// King Solomon's algorithm
                initPos = Math.round((splitter[0][opts.pxSplit] - splitter._PBA - bar._DA) / 2);

            // Resize event propagation and splitter sizing
            if (opts.anchorToWindow)
                opts.resizeTo = window;
            if (opts.resizeTo) {
                splitter._hadjust = dimSum(splitter, "borderTopWidth", "borderBottomWidth", "marginBottom", "paddingBottom");
                splitter._hadjust += dimSum($('body'), 'paddingBottom'); // Added by Roger
                splitter._hadjust += dimSum($('html'), 'paddingBottom'); // Added by Roger
                splitter._hadjust += 1; // [RDM] Need a fudge factor of one extra pixel to prevent scrollbars in IE & Chrome
                splitter._hmin = Math.max(dimSum(splitter, "minHeight"), 20);
                $(window).on("resize" + opts.eventNamespace, function (e) {
                    if (e.target == window) {
                        var top = splitter.offset().top;
                        var eh = $(opts.resizeTo).height();
                        splitter.css("height", Math.max(eh - top - splitter._hadjust - 0, splitter._hmin) + "px");
                        splitter.trigger("resize" + opts.eventNamespace);
                    }
                }).trigger("resize" + opts.eventNamespace);
            }
            else if (opts.resizeToWidth) {
                $(window).on("resize" + opts.eventNamespace, function (e) {
                    if (e.target == window) {
                        splitter.trigger("resize" + opts.eventNamespace);
                    }
                });
            }

            // Docking support
            if (opts.dock) {
                splitter
             .on("toggleDock" + opts.eventNamespace, function () {
                 var pw = opts.dockPane[0][opts.pxSplit];
                 splitter.trigger(pw ? "dock" + opts.eventNamespace : "undock" + opts.eventNamespace);
             })
             .on("dock" + opts.eventNamespace, function () {
                 var pw = A[0][opts.pxSplit];
                 if (!pw) return;
                 bar._pos = pw;
                 var x = {};
                 x[opts.origin] = opts.dockPane == A ? 0 :
                     splitter[0][opts.pxSplit] - splitter._PBA - bar[0][opts.pxSplit];
                 bar.animate(x, opts.dockSpeed || 1, opts.dockEasing, function () {
                     bar.addClass(opts.barDockedClass);
                     resplit(x[opts.origin]);
                 });
             })
             .on("undock" + opts.eventNamespace, function () {
                 var pw = opts.dockPane[0][opts.pxSplit];
                 if (pw) return;
                 var x = {}; x[opts.origin] = bar._pos + "px";
                 bar.removeClass(opts.barDockedClass)
                     .animate(x, opts.undockSpeed || opts.dockSpeed || 1, opts.undockEasing || opts.dockEasing, function () {
                         resplit(bar._pos);
                         bar._pos = null;
                     });
             });
                if (opts.dockKey)
                    $('<a title="' + opts.splitbarClass + ' toggle dock" href="javascript:void(0)"></a>')
                 .attr({ accessKey: opts.dockKey, tabIndex: -1 }).appendTo(bar)
                 .on("focus", function () {
                     splitter.trigger("toggleDock" + opts.eventNamespace); this.blur();
                 });
                bar.on("dblclick", function () { splitter.trigger("toggleDock" + opts.eventNamespace); });
            }


            // Resize event handler; triggered immediately to set initial position
            splitter
         .on("destroy" + opts.eventNamespace, function () {
             $([window, document]).off(opts.eventNamespace);
             bar.off().remove();
             panes.removeClass(opts.paneClass);
             splitter
                 .removeClass(opts.splitterClass)
                 .add(panes)
                     .off(opts.eventNamespace)
                     .attr("style", function (el) {
                         return this._splitter_style || "";	//TODO: save style
                     });
             splitter = bar = focuser = panes = A = B = opts = args = null;
         })
         .on("resize" + opts.eventNamespace, function (e, size) {
             // Custom events bubble in jQuery 1.3; avoid recursion
             if (e.target != this) return;
             // Determine new width/height of splitter container
             splitter._DF = splitter[0][opts.pxFixed] - splitter._PBF;
             splitter._DA = splitter[0][opts.pxSplit] - splitter._PBA;
             // Bail if splitter isn't visible or content isn't there yet
             if (splitter._DF <= 0 || splitter._DA <= 0) return;
             // Re-divvy the adjustable dimension; maintain size of the preferred pane
             resplit(!isNaN(size) ? size : (!(opts.sizeRight || opts.sizeBottom) ? A[0][opts.pxSplit] :
                 splitter._DA - B[0][opts.pxSplit] - bar._DA));
             setBarState(opts.barNormalClass);
         })
         .trigger("resize" + opts.eventNamespace, [initPos]);
        });
    };

})(jQuery);

//#endregion End Splitter

//#region autoSuggest

/*
* AutoSuggest
* Copyright 2009-2010 Drew Wilson
* www.drewwilson.com
* http://code.drewwilson.com/entry/autosuggest-jquery-plugin
*
* Version 1.4   -   Updated: Mar. 23, 2010
* 1.4.1 [2015-11-25] Added support for minChars = 0
* 1.4.2 [2016-01-22]
*    #117: Fixed issue where autosuggest popup doesn't disappear when user tabs or hits enter in input field
*    #116: Fixed issue where autosuggest doesn't reset on blur (perhaps was intentional behavior but not what we want in GS)
*    #114: Fixed issue where autosuggest popup shows a value that is already in the list
*
* This Plug-In will auto-complete or auto-suggest completed search queries
* for you as you type. You can add multiple selections and remove them on
* the fly. It supports keybord navigation (UP + DOWN + RETURN), as well
* as multiple AutoSuggest fields on the same page.
*
* Inspied by the Autocomplete plugin by: Jrn Zaefferer
* and the Facelist plugin by: Ian Tearle (iantearle.com)
*
* This AutoSuggest jQuery plug-in is dual licensed under the MIT and GPL licenses:
*   http://www.opensource.org/licenses/mit-license.php
*   http://www.gnu.org/licenses/gpl.html
*/

(function ($) {
    $.fn.autoSuggest = function (data, options) {
        var defaults = {
            asHtmlID: false,
            startText: "Enter Name Here",
            emptyText: "No Results Found",
            preFill: {},
            limitText: "No More Selections Are Allowed",
            selectedItemProp: "value", //name of object property
            selectedValuesProp: "value", //name of object property
            searchObjProps: "value", //comma separated list of object property names
            queryParam: "q",
            retrieveLimit: false, //number for 'limit' param on ajax request
            extraParams: "",
            matchCase: false,
            minChars: 1,
            keyDelay: 400,
            resultsHighlight: true,
            neverSubmit: false,
            selectionLimit: false,
            showResultList: true,
            start: function () { },
            selectionClick: function (elem) { },
            selectionAdded: function (elem) { },
            selectionRemoved: function (elem) { elem.remove(); },
            formatList: false, //callback function
            beforeRetrieve: function (string) { return string; },
            retrieveComplete: function (data) { return data; },
            resultClick: function (data) { },
            resultsComplete: function () { }
        };
        var opts = $.extend(defaults, options);

        var d_type = "object";
        var d_count = 0;
        if (typeof data == "string") {
            d_type = "string";
            var req_string = data;
        } else {
            var org_data = data;
            for (k in data) if (data.hasOwnProperty(k)) d_count++;
        }
        if ((d_type == "object" && d_count > 0) || d_type == "string") {
            return this.each(function (x) {
                if (!opts.asHtmlID) {
                    x = x + "" + Math.floor(Math.random() * 100); //this ensures there will be unique IDs on the page if autoSuggest() is called multiple times
                    var x_id = "as-input-" + x;
                } else {
                    x = opts.asHtmlID;
                    var x_id = x;
                }
                opts.start.call(this);
                var input = $(this);
                input.attr("autocomplete", "off").addClass("as-input").attr("id", x_id).val(opts.startText);
                var input_focus = false;

                // Setup basic elements and render them to the DOM
                input.wrap('<ul class="as-selections" id="as-selections-' + x + '"></ul>').wrap('<li class="as-original" id="as-original-' + x + '"></li>');
                var selections_holder = $("#as-selections-" + x);
                var org_li = $("#as-original-" + x);
                var results_holder = $('<div class="as-results" id="as-results-' + x + '"></div>').hide();
                var results_ul = $('<ul class="as-list"></ul>');
                var values_input = $('<input type="hidden" class="as-values" name="as_values_' + x + '" id="as-values-' + x + '" />');
                var prefill_value = "";
                if (typeof opts.preFill == "string") {
                    var vals = opts.preFill.split(",");
                    for (var i = 0; i < vals.length; i++) {
                        var v_data = {};
                        v_data[opts.selectedValuesProp] = vals[i];
                        if (vals[i] != "") {
                            add_selected_item(v_data, "000" + i);
                        }
                    }
                    prefill_value = opts.preFill;
                } else {
                    prefill_value = "";
                    var prefill_count = 0;
                    for (k in opts.preFill) if (opts.preFill.hasOwnProperty(k)) prefill_count++;
                    if (prefill_count > 0) {
                        for (var i = 0; i < prefill_count; i++) {
                            var new_v = opts.preFill[i][opts.selectedValuesProp];
                            if (new_v == undefined) { new_v = ""; }
                            prefill_value = prefill_value + new_v + ",";
                            if (new_v != "") {
                                add_selected_item(opts.preFill[i], "000" + i);
                            }
                        }
                    }
                }
                if (prefill_value != "") {
                    input.val("");
                    var lastChar = prefill_value.substring(prefill_value.length - 1);
                    if (lastChar != ",") { prefill_value = prefill_value + ","; }
                    values_input.val("," + prefill_value);
                    $("li.as-selection-item", selections_holder).addClass("blur").removeClass("selected");
                }
                input.after(values_input);
                selections_holder.click(function () {
                    input_focus = true;
                    input.focus();
                }).mousedown(function () { input_focus = false; }).after(results_holder);

                var timeout = null;
                var prev = "";
                var totalSelections = 0;
                var tab_press = false;

                // Handle input field events
                input.focus(function () {
                    if ($(this).val() == opts.startText && values_input.val() == "") {
                        $(this).val("");
                    } else if (input_focus) {
                        $("li.as-selection-item", selections_holder).removeClass("blur");
                        if ($(this).val() != "") {
                            results_ul.css("width", selections_holder.outerWidth());
                            results_holder.show();
                        }
                    }
                    input_focus = true;
                    if (opts.minChars === 0) { // [GSP] Add support for minChars = 0
                        lastKeyPressCode = 0;
                        keyChange();
                    }
                    return true;
                }).blur(function () {
                    if (input_focus) {
                        $("li.as-selection-item", selections_holder).addClass("blur").removeClass("selected");
                        results_holder.hide();
                    }
                    $(this).val(opts.startText);
                }).keydown(function (e) {
                    // track last key pressed
                    lastKeyPressCode = e.keyCode;
                    first_focus = false;
                    switch (e.keyCode) {
                        case 38: // up
                            e.preventDefault();
                            moveSelection("up");
                            break;
                        case 40: // down
                            e.preventDefault();
                            moveSelection("down");
                            break;
                        case 8:  // delete
                            if (input.val() == "") {
                                var last = values_input.val().split(",");
                                last = last[last.length - 2];
                                selections_holder.children().not(org_li.prev()).removeClass("selected");
                                if (org_li.prev().hasClass("selected")) {
                                    values_input.val(values_input.val().replace("," + last + ",", ","));
                                    opts.selectionRemoved.call(this, org_li.prev());
                                } else {
                                    opts.selectionClick.call(this, org_li.prev());
                                    org_li.prev().addClass("selected");
                                }
                            }
                            if (input.val().length == 1) {
                                results_holder.hide();
                                prev = "";
                            }
                            if ($(":visible", results_holder).length > 0) {
                                if (timeout) { clearTimeout(timeout); }
                                timeout = setTimeout(function () { keyChange(); }, opts.keyDelay);
                            }
                            break;
                        case 9: case 188: case 13:  // tab or comma or enter [GSP] Added case 13 because we want enter behavior same as tab & comma
                            var active = $("li.active:first", results_holder);
                            if (active.length > 0) {
                                // An item in the drop down is selected. Use that.
                                tab_press = false;
                                active.click().removeClass("active"); //[GSP] Added removeClass("active") so that subsequent 'enter' presses can submit data when used in Jeditable
                                if (opts.neverSubmit || active.length > 0) {
                                    e.preventDefault();
                                }
                            } else {
                                // If text has been entered, use that.
                                tab_press = true;
                                var i_input = input.val().replace(/(,)/g, "");
                                if (i_input != "" && values_input.val().search("," + i_input + ",") < 0 && i_input.length >= opts.minChars) {
                                    e.preventDefault();
                                    var n_data = {};
                                    n_data[opts.selectedItemProp] = i_input;
                                    n_data[opts.selectedValuesProp] = i_input;
                                    var lis = $("li", selections_holder).length;
                                    add_selected_item(n_data, "00" + (lis + 1));
                                    input.val("");
                                }
                            }
                            results_holder.hide();
                            break;
                        case 27: // [GSP] Added case for escape to clear input
                            results_holder.hide();
                            input.val("");
                            break;
                        default:
                            if (opts.showResultList) {
                                if (opts.selectionLimit && $("li.as-selection-item", selections_holder).length >= opts.selectionLimit) {
                                    results_ul.html('<li class="as-message">' + opts.limitText + '</li>');
                                    results_holder.show();
                                } else {
                                    if (timeout) { clearTimeout(timeout); }
                                    timeout = setTimeout(function () { keyChange(); }, opts.keyDelay);
                                }
                            }
                            break;
                    }
                });

                function keyChange() {
                    // ignore if the following keys are pressed: [del] [shift] [capslock]
                    if (lastKeyPressCode == 46 || (lastKeyPressCode > 8 && lastKeyPressCode < 32)) { return results_holder.hide(); }
                    var string = input.val().replace(/[\\]+|[\/]+/g, "");
                    if (string.length > 0 && string == prev) return; // [GSP] Added 'string.length > 0' check to enable support for minChars = 0
                    prev = string;
                    if (string.length >= opts.minChars) {
                        selections_holder.addClass("loading");
                        if (d_type == "string") {
                            var limit = "";
                            if (opts.retrieveLimit) {
                                limit = "&limit=" + encodeURIComponent(opts.retrieveLimit);
                            }
                            if (opts.beforeRetrieve) {
                                string = opts.beforeRetrieve.call(this, string);
                            }
                            $.getJSON(req_string + "?" + opts.queryParam + "=" + encodeURIComponent(string) + limit + opts.extraParams, function (data) {
                                d_count = 0;
                                var new_data = opts.retrieveComplete.call(this, data);
                                for (k in new_data) if (new_data.hasOwnProperty(k)) d_count++;
                                processData(new_data, string);
                            });
                        } else {
                            if (opts.beforeRetrieve) {
                                string = opts.beforeRetrieve.call(this, string);
                            }
                            processData(org_data, string);
                        }
                    } else {
                        selections_holder.removeClass("loading");
                        results_holder.hide();
                    }
                }
                var num_count = 0;
                function processData(data, query) {
                    if (!opts.matchCase) { query = query.toLowerCase(); }
                    var matchCount = 0;
                    results_holder.html(results_ul.html("")).hide();
                    for (var i = 0; i < d_count; i++) {
                        var num = i;
                        num_count++;
                        var forward = false;
                        if (opts.searchObjProps == "value") {
                            var str = data[num].value;
                        } else {
                            var str = "";
                            var names = opts.searchObjProps.split(",");
                            for (var y = 0; y < names.length; y++) {
                                var name = $.trim(names[y]);
                                str = str + data[num][name] + " ";
                            }
                        }
                        if (str) {
                            if (!opts.matchCase) { str = str.toLowerCase(); }

                            //[GSP] Refactored to make more readable and added optional space after comma (issue# 114)
                            var foundInServerData = str.search(query) >= 0;

                            var tagMatchFromServer = data[num][opts.selectedValuesProp];
                            var re = new RegExp(",\\s*" + tagMatchFromServer + ",");
                            var foundInTagList = values_input.val().search(re) >= 0;

                            if (foundInServerData && !foundInTagList) {
                                forward = true;
                            }
                        }
                        if (forward) {
                            var formatted = $('<li class="as-result-item" id="as-result-item-' + num + '"></li>').click(function () {
                                var raw_data = $(this).data("data");
                                var number = raw_data.num;
                                if ($("#as-selection-" + number, selections_holder).length <= 0 && !tab_press) {
                                    var data = raw_data.attributes;
                                    input.val("").focus();
                                    prev = "";
                                    add_selected_item(data, number);
                                    opts.resultClick.call(this, raw_data);
                                    results_holder.hide();
                                }
                                tab_press = false;
                            }).mousedown(function () { input_focus = false; }).mouseover(function () {
                                $("li", results_ul).removeClass("active");
                                $(this).addClass("active");
                            }).data("data", { attributes: data[num], num: num_count });
                            var this_data = $.extend({}, data[num]);
                            if (!opts.matchCase) {
                                var regx = new RegExp("(?![^&;]+;)(?!<[^<>]*)(" + query + ")(?![^<>]*>)(?![^&;]+;)", "gi");
                            } else {
                                var regx = new RegExp("(?![^&;]+;)(?!<[^<>]*)(" + query + ")(?![^<>]*>)(?![^&;]+;)", "g");
                            }

                            if (opts.resultsHighlight && query.length > 0) { // [GSP] Highlight only when user has typed at least one character (req'd when adding support for minChars = 0)
                                this_data[opts.selectedItemProp] = this_data[opts.selectedItemProp].replace(regx, "<em>$1</em>");
                            }
                            if (!opts.formatList) {
                                formatted = formatted.html(this_data[opts.selectedItemProp]);
                            } else {
                                formatted = opts.formatList.call(this, this_data, formatted);
                            }
                            results_ul.append(formatted);
                            delete this_data;
                            matchCount++;
                            if (opts.retrieveLimit && opts.retrieveLimit == matchCount) { break; }
                        }
                    }
                    selections_holder.removeClass("loading");
                    if (matchCount <= 0) {
                        results_ul.html('<li class="as-message">' + opts.emptyText + '</li>');
                    }
                    results_ul.css("width", selections_holder.outerWidth());
                    results_holder.show();
                    opts.resultsComplete.call(this);
                }

                function add_selected_item(data, num) {
                    if (values_input.val() === '') {
                        values_input.val(','); // [GSP] Search algorithm requires our tag list always start with a comma
                    }
                    values_input.val(values_input.val() + data[opts.selectedValuesProp] + ",");
                    var item = $('<li class="as-selection-item" id="as-selection-' + num + '"></li>').click(function () {
                        opts.selectionClick.call(this, $(this));
                        selections_holder.children().removeClass("selected");
                        $(this).addClass("selected");
                    }).mousedown(function () { input_focus = false; });
                    var close = $('<a class="as-close">&times;</a>').click(function () {
                        values_input.val(values_input.val().replace("," + data[opts.selectedValuesProp] + ",", ","));
                        opts.selectionRemoved.call(this, item);
                        input_focus = true;
                        input.focus();
                        return false;
                    });
                    org_li.before(item.html(data[opts.selectedItemProp]).prepend(close));
                    opts.selectionAdded.call(this, org_li.prev());
                }

                function moveSelection(direction) {
                    if ($(":visible", results_holder).length > 0) {
                        var lis = $("li", results_holder);
                        if (direction == "down") {
                            var start = lis.eq(0);
                        } else {
                            var start = lis.filter(":last");
                        }
                        var active = $("li.active:first", results_holder);
                        if (active.length > 0) {
                            if (direction == "down") {
                                start = active.next();
                            } else {
                                start = active.prev();
                            }
                        }
                        lis.removeClass("active");
                        start.addClass("active");
                    }
                }

            });
        }
    }
})(jQuery);

//#endregion End autoSuggest

//#region menubar 

// 2013-03-11 https://github.com/rdogmartin/jquery-ui/blob/menubar/ui/jquery.ui.menubar.js
// This is a branch from https://github.com/jquery/jquery-ui/blob/menubar/ui/jquery.ui.menubar.js with these changes:

// * 2013-03-11: Replaced show() with slideDown(200) in _open function
// * 2013-03-11: Added open delay to prevent inadvertently opening menu when mouse is quickly passing over menu button
// * 2015-09-17: Removed the click.menubar event binding when autoExpand option is true (which is how Gallery Server uses it).
//               The presence of this binding was causing the menu to close immediately after opening on touchscreens, since touching 
//               the menu button triggered these events:  mouseenter, focus, click, and the final click was toggling the menu back to a closed state. 

/*
 * jQuery UI Menubar @VERSION
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Menubar
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *	jquery.ui.position.js
 *	jquery.ui.menu.js
 */
(function ($) {

    // TODO when mixing clicking menus and keyboard navigation, focus handling is broken
    // there has to be just one item that has tabindex
    $.widget("ui.menubar", {
        version: "@VERSION",
        options: {
            autoExpand: false,
            buttons: false,
            items: "li",
            menuElement: "ul",
            menuIcon: false,
            position: {
                my: "left top",
                at: "left bottom"
            }
        },
        _create: function () {
            var that = this;
            this.menuItems = this.element.children(this.options.items);
            this.items = this.menuItems.children("button, a");

            this.menuItems
				.addClass("ui-menubar-item")
				.attr("role", "presentation");
            // let only the first item receive focus
            this.items.slice(1).attr("tabIndex", -1);

            this.element
				.addClass("ui-menubar ui-widget-header ui-helper-clearfix")
				.attr("role", "menubar");
            this._focusable(this.items);
            this._hoverable(this.items);
            this.items.siblings(this.options.menuElement)
				.menu({
				    position: {
				        within: this.options.position.within
				    },
				    select: function (event, ui) {
				        ui.item.parents("ul.ui-menu:last").hide();
				        that._close();
				        // TODO what is this targetting? there's probably a better way to access it
				        $(event.target).prev().focus();
				        that._trigger("select", event, ui);
				    },
				    menus: that.options.menuElement
				})
				.hide()
				.attr({
				    "aria-hidden": "true",
				    "aria-expanded": "false"
				})
				// TODO use _on
				.bind("keydown.menubar", function (event) {
				    var menu = $(this);
				    if (menu.is(":hidden")) {
				        return;
				    }
				    switch (event.keyCode) {
				        case $.ui.keyCode.LEFT:
				            that.previous(event);
				            event.preventDefault();
				            break;
				        case $.ui.keyCode.RIGHT:
				            that.next(event);
				            event.preventDefault();
				            break;
				    }
				});
            this.items.each(function () {
                var input = $(this),
					// TODO menu var is only used on two places, doesn't quite justify the .each
					menu = input.next(that.options.menuElement);

                // might be a non-menu button
                if (menu.length) {
                    // TODO use _on
                    var eventsToTriggerOpen = 'focus.menubar mouseenter.menubar' + (that.options.autoExpand ? '' : ' click.menubar');
                    input.bind(eventsToTriggerOpen, function (event) {
                        // ignore triggered focus event
                        if (event.type === "focus" && !event.originalEvent) {
                            return;
                        }
                        event.preventDefault();
                        // TODO can we simplify or extractthis check? especially the last two expressions
                        // there's a similar active[0] == menu[0] check in _open
                        if (event.type === "click" && menu.is(":visible") && that.active && that.active[0] === menu[0]) {
                            that._close();
                            return;
                        }
                        if ((that.open && event.type === "mouseenter") || event.type === "click" || that.options.autoExpand) {
                            if (that.options.autoExpand) {
                                clearTimeout(that.closeTimer);
                            }

                            if (that.options.autoExpand) {
                                // Expand after a slight delay, which we'll cancel if the mouse leaves the element
                                // before the delay is up. This prevents inadvertently opening the menu when the mouse
                                // is just passing through the area.
                                that.openTimer = window.setTimeout(function () {
                                    that._open(event, menu);
                                }, 200);
                            } else {
                                that._open(event, menu);
                            }
                        }
                    })
					// TODO use _on
					.bind("keydown", function (event) {
					    switch (event.keyCode) {
					        case $.ui.keyCode.SPACE:
					        case $.ui.keyCode.UP:
					        case $.ui.keyCode.DOWN:
					            that._open(event, $(this).next());
					            event.preventDefault();
					            break;
					        case $.ui.keyCode.LEFT:
					            that.previous(event);
					            event.preventDefault();
					            break;
					        case $.ui.keyCode.RIGHT:
					            that.next(event);
					            event.preventDefault();
					            break;
					    }
					})
					.attr("aria-haspopup", "true");

                    // TODO review if these options (menuIcon and buttons) are a good choice, maybe they can be merged
                    if (that.options.menuIcon) {
                        input.addClass("ui-state-default").append("<span class='ui-button-icon-secondary ui-icon ui-icon-triangle-1-s'></span>");
                        input.removeClass("ui-button-text-only").addClass("ui-button-text-icon-secondary");
                    }
                } else {
                    // TODO use _on
                    input.bind("click.menubar mouseenter.menubar", function (event) {
                        if ((that.open && event.type === "mouseenter") || event.type === "click") {
                            that._close();
                        }
                    });
                }

                input
					.addClass("ui-button ui-widget ui-button-text-only ui-menubar-link")
					.attr("role", "menuitem")
					.wrapInner("<span class='ui-button-text'></span>");

                if (that.options.buttons) {
                    input.removeClass("ui-menubar-link").addClass("ui-state-default");
                }
            });
            that._on({
                keydown: function (event) {
                    if (event.keyCode === $.ui.keyCode.ESCAPE && that.active && that.active.menu("collapse", event) !== true) {
                        var active = that.active;
                        that.active.blur();
                        that._close(event);
                        active.prev().focus();
                    }
                },
                focusin: function (event) {
                    clearTimeout(that.closeTimer);
                },
                focusout: function (event) {
                    clearTimeout(that.openTimer);
                    that.closeTimer = setTimeout(function () {
                        that._close(event);
                    }, 150);
                },
                "mouseleave .ui-menubar-item": function (event) {
                    if (that.options.autoExpand) {
                        clearTimeout(that.openTimer);
                        that.closeTimer = setTimeout(function () {
                            that._close(event);
                        }, 150);
                    }
                },
                "mouseenter .ui-menubar-item": function (event) {
                    clearTimeout(that.closeTimer);
                }
            });

            // Keep track of open submenus
            this.openSubmenus = 0;
        },

        _destroy: function () {
            this.menuItems
				.removeClass("ui-menubar-item")
				.removeAttr("role");

            this.element
				.removeClass("ui-menubar ui-widget-header ui-helper-clearfix")
				.removeAttr("role")
				.unbind(".menubar");

            this.items
				.unbind(".menubar")
				.removeClass("ui-button ui-widget ui-button-text-only ui-menubar-link ui-state-default")
				.removeAttr("role")
				.removeAttr("aria-haspopup")
				// TODO unwrap?
				.children("span.ui-button-text").each(function (i, e) {
				    var item = $(this);
				    item.parent().html(item.html());
				})
				.end()
				.children(".ui-icon").remove();

            this.element.find(":ui-menu")
				.menu("destroy")
				.show()
				.removeAttr("aria-hidden")
				.removeAttr("aria-expanded")
				.removeAttr("tabindex")
				.unbind(".menubar");
        },

        _close: function () {
            if (!this.active || !this.active.length) {
                return;
            }
            this.active
				.menu("collapseAll")
				.hide()
				.attr({
				    "aria-hidden": "true",
				    "aria-expanded": "false"
				});
            this.active
				.prev()
				.removeClass("ui-state-active")
				.removeAttr("tabIndex");
            this.active = null;
            this.open = false;
            this.openSubmenus = 0;
        },

        _open: function (event, menu) {
            // on a single-button menubar, ignore reopening the same menu
            if (this.active && this.active[0] === menu[0]) {
                return;
            }
            // TODO refactor, almost the same as _close above, but don't remove tabIndex
            if (this.active) {
                this.active
					.menu("collapseAll")
					.hide()
					.attr({
					    "aria-hidden": "true",
					    "aria-expanded": "false"
					});
                this.active
					.prev()
					.removeClass("ui-state-active");
            }
            // set tabIndex -1 to have the button skipped on shift-tab when menu is open (it gets focus)
            var button = menu.prev().addClass("ui-state-active").attr("tabIndex", -1);
            this.active = menu
				.slideDown(200) // Replace show() with slideDown()
				.position($.extend({
				    of: button
				}, this.options.position))
				.removeAttr("aria-hidden")
				.attr("aria-expanded", "true")
				.menu("focus", event, menu.children(".ui-menu-item").first())
				// TODO need a comment here why both events are triggered
				.focus()
				.focusin();
            this.open = true;
        },

        next: function (event) {
            if (this.open && this.active.data("menu").active.has(".ui-menu").length) {
                // Track number of open submenus and prevent moving to next menubar item
                this.openSubmenus++;
                return;
            }
            this.openSubmenus = 0;
            this._move("next", "first", event);
        },

        previous: function (event) {
            if (this.open && this.openSubmenus) {
                // Track number of open submenus and prevent moving to previous menubar item
                this.openSubmenus--;
                return;
            }
            this.openSubmenus = 0;
            this._move("prev", "last", event);
        },

        _move: function (direction, filter, event) {
            var next,
				wrapItem;
            if (this.open) {
                next = this.active.closest(".ui-menubar-item")[direction + "All"](this.options.items).first().children(".ui-menu").eq(0);
                wrapItem = this.menuItems[filter]().children(".ui-menu").eq(0);
            } else {
                if (event) {
                    next = $(event.target).closest(".ui-menubar-item")[direction + "All"](this.options.items).children(".ui-menubar-link").eq(0);
                    wrapItem = this.menuItems[filter]().children(".ui-menubar-link").eq(0);
                } else {
                    next = wrapItem = this.menuItems.children("a").eq(0);
                }
            }

            if (next.length) {
                if (this.open) {
                    this._open(event, next);
                } else {
                    next.removeAttr("tabIndex")[0].focus();
                }
            } else {
                if (this.open) {
                    this._open(event, wrapItem);
                } else {
                    wrapItem.removeAttr("tabIndex")[0].focus();
                }
            }
        }
    });

}(jQuery));

//#endregion End menubar

//#region RateIt
/*
		RateIt
		version 1.0.9
		10/31/2012
		http://rateit.codeplex.com
		Twitter: @gjunge

*/
(function ($) {
    $.fn.rateit = function (p1, p2) {
        //quick way out.
        var options = {}; var mode = 'init';
        var capitaliseFirstLetter = function (string) {
            return string.charAt(0).toUpperCase() + string.substr(1);
        };

        if (this.length == 0) return this;


        var tp1 = $.type(p1);
        if (tp1 == 'object' || p1 === undefined || p1 == null) {
            options = $.extend({}, $.fn.rateit.defaults, p1); //wants to init new rateit plugin(s).
        }
        else if (tp1 == 'string' && p2 === undefined) {
            return this.data('rateit' + capitaliseFirstLetter(p1)); //wants to get a value.
        }
        else if (tp1 == 'string') {
            mode = 'setvalue'
        }

        return this.each(function () {
            var item = $(this);

            //shorten all the item.data('rateit-XXX'), will save space in closure compiler, will be like item.data('XXX') will become x('XXX')
            var itemdata = function (key, value) {
                arguments[0] = 'rateit' + capitaliseFirstLetter(key);
                return item.data.apply(item, arguments); ////Fix for WI: 523
            };

            //add the rate it class.
            if (!item.hasClass('rateit')) item.addClass('rateit');

            var ltr = item.css('direction') != 'rtl';

            // set value mode
            if (mode == 'setvalue') {
                if (!itemdata('init')) throw 'Can\'t set value before init';


                //if readonly now and it wasn't readonly, remove the eventhandlers.
                if (p1 == 'readonly' && !itemdata('readonly')) {
                    item.find('.rateit-range').off();
                    itemdata('wired', false);
                }
                if (p1 == 'value' && p2 == null) p2 = itemdata('min'); //when we receive a null value, reset the score to its min value.

                if (itemdata('backingfld')) {
                    //if we have a backing field, check which fields we should update. 
                    //In case of input[type=range], although we did read its attributes even in browsers that don't support it (using fld.attr())
                    //we only update it in browser that support it (&& fld[0].min only works in supporting browsers), not only does it save us from checking if it is range input type, it also is unnecessary.
                    var fld = $(itemdata('backingfld'));
                    if (p1 == 'value') fld.val(p2);
                    if (p1 == 'min' && fld[0].min) fld[0].min = p2;
                    if (p1 == 'max' && fld[0].max) fld[0].max = p2;
                    if (p1 == 'step' && fld[0].step) fld[0].step = p2;
                }

                itemdata(p1, p2);
            }

            //init rateit plugin
            if (!itemdata('init')) {

                //get our values, either from the data-* html5 attribute or from the options.
                itemdata('min', itemdata('min') || options.min);
                itemdata('max', itemdata('max') || options.max);
                itemdata('step', itemdata('step') || options.step);
                itemdata('readonly', itemdata('readonly') !== undefined ? itemdata('readonly') : options.readonly);
                itemdata('resetable', itemdata('resetable') !== undefined ? itemdata('resetable') : options.resetable);
                itemdata('backingfld', itemdata('backingfld') || options.backingfld);
                itemdata('starwidth', itemdata('starwidth') || options.starwidth);
                itemdata('starheight', itemdata('starheight') || options.starheight);
                itemdata('value', itemdata('value') || options.value || options.min);
                itemdata('ispreset', itemdata('ispreset') !== undefined ? itemdata('ispreset') : options.ispreset);
                //are we LTR or RTL?

                if (itemdata('backingfld')) {
                    //if we have a backing field, hide it, and get its value, and override defaults if range.
                    var fld = $(itemdata('backingfld'));
                    itemdata('value', fld.hide().val());

                    if (fld.attr('disabled') || fld.attr('readonly'))
                        itemdata('readonly', true); //http://rateit.codeplex.com/discussions/362055 , if a backing field is disabled or readonly at instantiation, make rateit readonly.


                    if (fld[0].nodeName == 'INPUT') {
                        if (fld[0].type == 'range' || fld[0].type == 'text') { //in browsers not support the range type, it defaults to text

                            itemdata('min', parseInt(fld.attr('min')) || itemdata('min')); //if we would have done fld[0].min it wouldn't have worked in browsers not supporting the range type.
                            itemdata('max', parseInt(fld.attr('max')) || itemdata('max'));
                            itemdata('step', parseInt(fld.attr('step')) || itemdata('step'));
                        }
                    }
                    if (fld[0].nodeName == 'SELECT' && fld[0].options.length > 1) {
                        itemdata('min', Number(fld[0].options[0].value));
                        itemdata('max', Number(fld[0].options[fld[0].length - 1].value));
                        itemdata('step', Number(fld[0].options[1].value) - Number(fld[0].options[0].value));
                    }
                }

                //Create the necessary tags.
                item.append('<div class="rateit-reset"></div><div class="rateit-range"><div class="rateit-selected" style="height:' + itemdata('starheight') + 'px"></div><div class="rateit-hover" style="height:' + itemdata('starheight') + 'px"></div></div>');

                //if we are in RTL mode, we have to change the float of the "reset button"
                if (!ltr) {
                    item.find('.rateit-reset').css('float', 'right');
                    item.find('.rateit-selected').addClass('rateit-selected-rtl');
                    item.find('.rateit-hover').addClass('rateit-hover-rtl');
                }

                itemdata('init', true);
            }


            //set the range element to fit all the stars.
            var range = item.find('.rateit-range');
            range.width(itemdata('starwidth') * (itemdata('max') - itemdata('min'))).height(itemdata('starheight'));

            //add/remove the preset class
            var presetclass = 'rateit-preset' + ((ltr) ? '' : '-rtl');
            if (itemdata('ispreset'))
                item.find('.rateit-selected').addClass(presetclass);
            else
                item.find('.rateit-selected').removeClass(presetclass);

            //set the value if we have it.
            if (itemdata('value') != null) {
                var score = (itemdata('value') - itemdata('min')) * itemdata('starwidth');
                item.find('.rateit-selected').width(score);
            }

            var resetbtn = item.find('.rateit-reset');
            if (resetbtn.data('wired') !== true) {
                resetbtn.click(function () {
                    itemdata('value', itemdata('min'));
                    range.find('.rateit-hover').hide().width(0);
                    range.find('.rateit-selected').width(0).show();
                    if (itemdata('backingfld')) $(itemdata('backingfld')).val(itemdata('min'));
                    item.trigger('reset');
                }).data('wired', true);

            }


            var calcRawScore = function (element, event) {
                var pageX = (event.changedTouches) ? event.changedTouches[0].pageX : event.pageX;

                var offsetx = pageX - $(element).offset().left;
                if (!ltr) offsetx = range.width() - offsetx;
                if (offsetx > range.width()) offsetx = range.width();
                if (offsetx < 0) offsetx = 0;

                return score = Math.ceil(offsetx / itemdata('starwidth') * (1 / itemdata('step')));
            };


            //

            if (!itemdata('readonly')) {
                //if we are not read only, add all the events

                //if we have a reset button, set the event handler.
                if (!itemdata('resetable'))
                    resetbtn.hide();

                //when the mouse goes over the range div, we set the "hover" stars.
                if (!itemdata('wired')) {
                    range.on('touchmove touchend', touchHandler); //bind touch events
                    range.mousemove(function (e) {
                        var score = calcRawScore(this, e);
                        var w = score * itemdata('starwidth') * itemdata('step');
                        var h = range.find('.rateit-hover');
                        if (h.data('width') != w) {
                            range.find('.rateit-selected').hide();
                            h.width(w).show().data('width', w);
                            var data = [(score * itemdata('step')) + itemdata('min')];
                            item.trigger('hover', data).trigger('over', data);
                        }
                    });
                    //when the mouse leaves the range, we have to hide the hover stars, and show the current value.
                    range.mouseleave(function (e) {
                        range.find('.rateit-hover').hide().width(0).data('width', '');
                        item.trigger('hover', [null]).trigger('over', [null]);
                        range.find('.rateit-selected').show();
                    });
                    //when we click on the range, we have to set the value, hide the hover.
                    range.mouseup(function (e) {
                        var score = calcRawScore(this, e);

                        var newvalue = (score * itemdata('step')) + itemdata('min');
                        itemdata('value', newvalue);
                        if (itemdata('backingfld')) {
                            $(itemdata('backingfld')).val(newvalue);
                        }
                        if (itemdata('ispreset')) { //if it was a preset value, unset that.
                            range.find('.rateit-selected').removeClass(presetclass);
                            itemdata('ispreset', false);
                        }
                        range.find('.rateit-hover').hide();
                        range.find('.rateit-selected').width(score * itemdata('starwidth') * itemdata('step')).show();
                        item.trigger('hover', [null]).trigger('over', [null]).trigger('rated', [newvalue]);
                    });

                    itemdata('wired', true);
                }
                if (itemdata('resetable')) {
                    resetbtn.show();
                }
            }
            else {
                resetbtn.hide();
            }
        });
    };

    //touch converter http://ross.posterous.com/2008/08/19/iphone-touch-events-in-javascript/
    function touchHandler(event) {

        var touches = event.originalEvent.changedTouches,
						first = touches[0],
						type = "";
        switch (event.type) {
            case "touchmove": type = "mousemove"; break;
            case "touchend": type = "mouseup"; break;
            default: return;
        }

        var simulatedEvent = document.createEvent("MouseEvent");
        simulatedEvent.initMouseEvent(type, true, true, window, 1,
													first.screenX, first.screenY,
													first.clientX, first.clientY, false,
													false, false, false, 0/*left*/, null);

        first.target.dispatchEvent(simulatedEvent);
        event.preventDefault();
    };

    //some default values.
    $.fn.rateit.defaults = { min: 0, max: 5, step: 0.5, starwidth: 16, starheight: 16, readonly: false, resetable: true, ispreset: false };

    //invoke it on all div.rateit elements. This could be removed if not wanted.
    //$(function () { $('div.rateit').rateit(); });

})(jQuery);

//#endregion End RateIt

//#region supersized

/*
	supersized.3.2.7.js
	Supersized - Fullscreen Slideshow jQuery Plugin
	Version : 3.2.7
	Site	: www.buildinternet.com/project/supersized
	
	Author	: Sam Dunn
	Company : One Mighty Roar (www.onemightyroar.com)
	License : MIT License / GPL License

*/

(function ($) {

    $.supersized = function (options) {

        // If caller requested the api variable, return it. It is unfortunately a global variable, so this isn't really necessary, but TypeScript
        // doesn't like it when you invoke variables that aren't properly defined, so we added this function.
        if (options === 'getApi') {
            return api;
        }

        /* Variables
	----------------------------*/
        var base = this;

        base.init = function () {
            // Combine options and vars
            $.supersized.vars = $.extend($.supersized.vars, $.supersized.themeVars);
            $.supersized.vars.options = $.extend({}, $.supersized.defaultOptions, $.supersized.themeOptions, options);
            base.options = $.supersized.vars.options;

            base._build();
        };


        /* Build Elements
----------------------------*/
        base._build = function () {
            // Add in slide markers
            var thisSlide = 0,
				slideSet = '',
		markers = '',
		markerContent,
		thumbMarkers = '',
		thumbImage;


            // Hide current page contents and add Supersized Elements
            $('body').children(':visible').hide().addClass('supersized_hidden');
            $('body').append($($.supersized.vars.options.html_template), '<div id="supersized-loader"></div><ul id="supersized"></ul>');

            var el = '#supersized';
            // Access to jQuery and DOM versions of element
            base.$el = $(el);
            base.el = el;
            vars = $.supersized.vars;
            vars.$container = base.$el;
            // Add a reverse reference to the DOM object
            base.$el.data("supersized", base);
            api = base.$el.data('supersized');


            while (thisSlide <= base.options.slides.length - 1) {
                //Determine slide link content
                switch (base.options.slide_links) {
                    case 'num':
                        markerContent = thisSlide;
                        break;
                    case 'name':
                        markerContent = base.options.slides[thisSlide].title;
                        break;
                    case 'blank':
                        markerContent = '';
                        break;
                }

                slideSet = slideSet + '<li class="slide-' + thisSlide + '"></li>';

                if (thisSlide == base.options.start_slide - 1) {
                    // Slide links
                    if (base.options.slide_links) markers = markers + '<li class="slide-link-' + thisSlide + ' current-slide"><a>' + markerContent + '</a></li>';
                    // Slide Thumbnail Links
                    if (base.options.thumb_links) {
                        base.options.slides[thisSlide].thumb ? thumbImage = base.options.slides[thisSlide].thumb : thumbImage = base.options.slides[thisSlide].image;
                        thumbMarkers = thumbMarkers + '<li class="thumb' + thisSlide + ' current-thumb"><img src="' + thumbImage + '"/></li>';
                    };
                } else {
                    // Slide links
                    if (base.options.slide_links) markers = markers + '<li class="slide-link-' + thisSlide + '" ><a>' + markerContent + '</a></li>';
                    // Slide Thumbnail Links
                    if (base.options.thumb_links) {
                        base.options.slides[thisSlide].thumb ? thumbImage = base.options.slides[thisSlide].thumb : thumbImage = base.options.slides[thisSlide].image;
                        thumbMarkers = thumbMarkers + '<li class="thumb' + thisSlide + '"><img src="' + thumbImage + '"/></li>';
                    };
                }
                thisSlide++;
            }

            if (base.options.slide_links) $(vars.slide_list).html(markers);
            if (base.options.thumb_links && vars.thumb_tray.length) {
                $(vars.thumb_tray).append('<ul id="' + vars.thumb_list.replace('#', '') + '">' + thumbMarkers + '</ul>');
            }

            $(base.el).append(slideSet);

            // Add in thumbnails
            if (base.options.thumbnail_navigation) {
                // Load previous thumbnail
                vars.current_slide - 1 < 0 ? prevThumb = base.options.slides.length - 1 : prevThumb = vars.current_slide - 1;
                $(vars.prev_thumb).show().html($("<img/>").attr("src", base.options.slides[prevThumb].image));

                // Load next thumbnail
                vars.current_slide == base.options.slides.length - 1 ? nextThumb = 0 : nextThumb = vars.current_slide + 1;
                $(vars.next_thumb).show().html($("<img/>").attr("src", base.options.slides[nextThumb].image));
            }

            base._start(); // Get things started
        };


        /* Initialize
----------------------------*/
        base._start = function () {

            // Determine if starting slide random
            if (base.options.start_slide) {
                vars.current_slide = base.options.start_slide - 1;
            } else {
                vars.current_slide = Math.floor(Math.random() * base.options.slides.length);	// Generate random slide number
            }

            // If links should open in new window
            var linkTarget = base.options.new_window ? ' target="_blank"' : '';

            // Set slideshow quality (Supported only in FF and IE, no Webkit)
            if (base.options.performance == 3) {
                base.$el.addClass('speed'); 		// Faster transitions
            } else if ((base.options.performance == 1) || (base.options.performance == 2)) {
                base.$el.addClass('quality');	// Higher image quality
            }

            // Shuffle slide order if needed		
            if (base.options.random) {
                arr = base.options.slides;
                for (var j, x, i = arr.length; i; j = parseInt(Math.random() * i), x = arr[--i], arr[i] = arr[j], arr[j] = x);	// Fisher-Yates shuffle algorithm (jsfromhell.com/array/shuffle)
                base.options.slides = arr;
            }

            /*-----Load initial set of images-----*/

            if (base.options.slides.length > 1) {
                if (base.options.slides.length > 2) {
                    // Set previous image
                    vars.current_slide - 1 < 0 ? loadPrev = base.options.slides.length - 1 : loadPrev = vars.current_slide - 1;	// If slide is 1, load last slide as previous
                    var imageLink = (base.options.slides[loadPrev].url) ? "href='" + base.options.slides[loadPrev].url + "'" : "";

                    var imgPrev = $('<img src="' + base.options.slides[loadPrev].image + '"/>');
                    var slidePrev = base.el + ' li:eq(' + loadPrev + ')';
                    imgPrev.appendTo(slidePrev).wrap('<a ' + imageLink + linkTarget + '></a>').parent().parent().addClass('image-loading prevslide');

                    imgPrev.load(function () {
                        $(this).data('origWidth', $(this).width()).data('origHeight', $(this).height());
                        base.resizeNow();	// Resize background image
                    });	// End Load
                }
            } else {
                // Slideshow turned off if there is only one slide
                //base.options.slideshow = 0; //[RDM] Commented out because this disables buttons when there is only one slide
            }

            // Set current image
            imageLink = (api.getField('url')) ? "href='" + api.getField('url') + "'" : "";
            var img = $('<img src="' + api.getField('image') + '"/>');

            var slideCurrent = base.el + ' li:eq(' + vars.current_slide + ')';
            img.appendTo(slideCurrent).wrap('<a ' + imageLink + linkTarget + '></a>').parent().parent().addClass('image-loading activeslide').css('visibility', 'visible');

            img.load(function () {
                base._origDim($(this));
                base.resizeNow();	// Resize background image
                base.launch();
                if (typeof theme != 'undefined' && typeof theme._init == "function") theme._init();	// Load Theme
            });

            if (base.options.slides.length > 1) {
                // Set next image
                vars.current_slide == base.options.slides.length - 1 ? loadNext = 0 : loadNext = vars.current_slide + 1;	// If slide is last, load first slide as next
                imageLink = (base.options.slides[loadNext].url) ? "href='" + base.options.slides[loadNext].url + "'" : "";

                var imgNext = $('<img src="' + base.options.slides[loadNext].image + '"/>');
                var slideNext = base.el + ' li:eq(' + loadNext + ')';
                imgNext.appendTo(slideNext).wrap('<a ' + imageLink + linkTarget + '></a>').parent().parent().addClass('image-loading');

                imgNext.load(function () {
                    $(this).data('origWidth', $(this).width()).data('origHeight', $(this).height());
                    base.resizeNow();	// Resize background image
                });	// End Load
            }
            /*-----End load initial images-----*/

            //  Hide elements to be faded in
            base.$el.css('visibility', 'hidden');
            $('.load-item').hide();

        };


        /* Launch Supersized
		----------------------------*/
        base.launch = function () {

            //base.$el.css('visibility', 'visible');
            $('#supersized-loader').remove();		//Hide loading animation

            // Call theme function for before slide transition
            if (typeof theme != 'undefined' && typeof theme.beforeAnimation == "function") theme.beforeAnimation('next');
            $('.load-item').show();

            // Keyboard Navigation
            if (base.options.keyboard_nav) {
                $(document.documentElement).on('keyup.supersized', function (event) {

                    if (vars.in_animation) return false;		// Abort if currently animating
                    if ($(document.activeElement).is("input, textarea")) return false; // Abort if active element is an input or a textarea.

                    // Left Arrow or Down Arrow
                    if ((event.keyCode == 37) || (event.keyCode == 40)) {
                        clearInterval(vars.slideshow_interval);	// Stop slideshow, prevent buildup
                        base.prevSlide();

                        // Right Arrow or Up Arrow
                    } else if ((event.keyCode == 39) || (event.keyCode == 38)) {
                        clearInterval(vars.slideshow_interval);	// Stop slideshow, prevent buildup
                        base.nextSlide();

                        // Spacebar	
                    } else if (event.keyCode == 32 && !vars.hover_pause) {
                        clearInterval(vars.slideshow_interval);	// Stop slideshow, prevent buildup
                        base.playToggle();
                    }

                });
            }

            // Pause when hover on image
            if (base.options.slideshow && base.options.pause_hover) {
                $(base.el).hover(function () {
                    if (vars.in_animation) return false;		// Abort if currently animating
                    vars.hover_pause = true;	// Mark slideshow paused from hover
                    if (!vars.is_paused) {
                        vars.hover_pause = 'resume';	// It needs to resume afterwards
                        base.playToggle();
                    }
                }, function () {
                    if (vars.hover_pause == 'resume') {
                        base.playToggle();
                        vars.hover_pause = false;
                    }
                });
            }

            if (base.options.slide_links) {
                // Slide marker clicked
                $(vars.slide_list + '> li').click(function () {

                    index = $(vars.slide_list + '> li').index(this);
                    targetSlide = index + 1;

                    base.goTo(targetSlide);
                    return false;

                });
            }

            // Thumb marker clicked
            if (base.options.thumb_links) {
                $(vars.thumb_list + '> li').click(function () {

                    index = $(vars.thumb_list + '> li').index(this);
                    targetSlide = index + 1;

                    api.goTo(targetSlide);
                    return false;

                });
            }

            // Start slideshow if enabled
            if (base.options.slideshow && base.options.slides.length > 1) {

                // Start slideshow if autoplay enabled
                if (base.options.autoplay && base.options.slides.length > 1) {
                    vars.slideshow_interval = setInterval(base.nextSlide, base.options.slide_interval);	// Initiate slide interval
                } else {
                    vars.is_paused = true;	// Mark as paused
                }

                //Prevent navigation items from being dragged					
                $('.load-item img').bind("contextmenu mousedown", function () {
                    return false;
                });

            }

            // Adjust image when browser is resized
            $(window).resize(function () {
                base.resizeNow();
            });

        };


        /* Resize Images
----------------------------*/
        base.resizeNow = function () {

            return base.$el.each(function () {
                //  Resize each image seperately
                $('img', base.el).each(function () {

                    thisSlide = $(this);
                    var ratio = (thisSlide.data('origHeight') / thisSlide.data('origWidth')).toFixed(2);	// Define image ratio

                    // Gather browser size
                    var browserwidth = base.$el.width(),
						browserheight = base.$el.height(),
						offset;

                    /*-----Resize Image-----*/
                    if (base.options.fit_always) {	// Fit always is enabled
                        if ((browserheight / browserwidth) > ratio) {
                            resizeWidth();
                        } else {
                            resizeHeight();
                        }
                    } else {	// Normal Resize
                        if ((browserheight <= base.options.min_height) && (browserwidth <= base.options.min_width)) {	// If window smaller than minimum width and height

                            if ((browserheight / browserwidth) > ratio) {
                                base.options.fit_landscape && ratio < 1 ? resizeWidth(true) : resizeHeight(true);	// If landscapes are set to fit
                            } else {
                                base.options.fit_portrait && ratio >= 1 ? resizeHeight(true) : resizeWidth(true);		// If portraits are set to fit
                            }

                        } else if (browserwidth <= base.options.min_width) {		// If window only smaller than minimum width

                            if ((browserheight / browserwidth) > ratio) {
                                base.options.fit_landscape && ratio < 1 ? resizeWidth(true) : resizeHeight();	// If landscapes are set to fit
                            } else {
                                base.options.fit_portrait && ratio >= 1 ? resizeHeight() : resizeWidth(true);		// If portraits are set to fit
                            }

                        } else if (browserheight <= base.options.min_height) {	// If window only smaller than minimum height

                            if ((browserheight / browserwidth) > ratio) {
                                base.options.fit_landscape && ratio < 1 ? resizeWidth() : resizeHeight(true);	// If landscapes are set to fit
                            } else {
                                base.options.fit_portrait && ratio >= 1 ? resizeHeight(true) : resizeWidth();		// If portraits are set to fit
                            }

                        } else {	// If larger than minimums

                            if ((browserheight / browserwidth) > ratio) {
                                base.options.fit_landscape && ratio < 1 ? resizeWidth() : resizeHeight();	// If landscapes are set to fit
                            } else {
                                base.options.fit_portrait && ratio >= 1 ? resizeHeight() : resizeWidth();		// If portraits are set to fit
                            }

                        }
                    }
                    /*-----End Image Resize-----*/


                    /*-----Resize Functions-----*/

                    function resizeWidth(minimum) {
                        if (minimum) {	// If minimum height needs to be considered
                            if (thisSlide.width() < browserwidth || thisSlide.width() < base.options.min_width) {
                                if (thisSlide.width() * ratio >= base.options.min_height) {
                                    thisSlide.width(base.options.min_width);
                                    thisSlide.height(thisSlide.width() * ratio);
                                } else {
                                    resizeHeight();
                                }
                            }
                        } else {
                            if (base.options.min_height >= browserheight && !base.options.fit_landscape) {	// If minimum height needs to be considered
                                if (browserwidth * ratio >= base.options.min_height || (browserwidth * ratio >= base.options.min_height && ratio <= 1)) {	// If resizing would push below minimum height or image is a landscape
                                    thisSlide.width(browserwidth);
                                    thisSlide.height(browserwidth * ratio);
                                } else if (ratio > 1) {		// Else the image is portrait
                                    thisSlide.height(base.options.min_height);
                                    thisSlide.width(thisSlide.height() / ratio);
                                } else if (thisSlide.width() < browserwidth) {
                                    thisSlide.width(browserwidth);
                                    thisSlide.height(thisSlide.width() * ratio);
                                }
                            } else {	// Otherwise, resize as normal
                                thisSlide.width(browserwidth);
                                thisSlide.height(browserwidth * ratio);
                            }
                        }
                    };

                    function resizeHeight(minimum) {
                        if (minimum) {	// If minimum height needs to be considered
                            if (thisSlide.height() < browserheight) {
                                if (thisSlide.height() / ratio >= base.options.min_width) {
                                    thisSlide.height(base.options.min_height);
                                    thisSlide.width(thisSlide.height() / ratio);
                                } else {
                                    resizeWidth(true);
                                }
                            }
                        } else {	// Otherwise, resized as normal
                            if (base.options.min_width >= browserwidth) {	// If minimum width needs to be considered
                                if (browserheight / ratio >= base.options.min_width || ratio > 1) {	// If resizing would push below minimum width or image is a portrait
                                    thisSlide.height(browserheight);
                                    thisSlide.width(browserheight / ratio);
                                } else if (ratio <= 1) {		// Else the image is landscape
                                    thisSlide.width(base.options.min_width);
                                    thisSlide.height(thisSlide.width() * ratio);
                                }
                            } else {	// Otherwise, resize as normal
                                thisSlide.height(browserheight);
                                thisSlide.width(browserheight / ratio);
                            }
                        }
                    };

                    /*-----End Resize Functions-----*/

                    if (thisSlide.parents('li').hasClass('image-loading')) {
                        $('.image-loading').removeClass('image-loading');
                    }

                    // Horizontally Center
                    if (base.options.horizontal_center) {
                        $(this).css('left', (browserwidth - $(this).width()) / 2);
                    }

                    // Vertically Center
                    if (base.options.vertical_center) {
                        $(this).css('top', (browserheight - $(this).height()) / 2);
                    }

                });

                // Basic image drag and right click protection
                if (base.options.image_protect) {

                    $('img', base.el).bind("contextmenu mousedown", function () {
                        return false;
                    });

                }

                return false;

            });

        };


        /* Next Slide
----------------------------*/
        base.nextSlide = function () {
            if (base.options.slideshow && !vars.is_paused && base.options.auto_exit && (vars.current_slide == base.options.slides.length - 1)) {
                // We're on the last slide of a running slideshow where auto_exit is enabled, so exit.
                base.destroy(true);
                return false;
            }

            var old_slide_number = vars.current_slide;
            // Get the slide number of new slide
            if (vars.current_slide < base.options.slides.length - 1) {
                vars.current_slide++;
            } else if (base.options.loop) {
                vars.current_slide = 0;
            }

            if (old_slide_number == vars.current_slide) {
                vars.in_animation = false;
                return false;
            }

            if (vars.in_animation || !api.options.slideshow) return false;		// Abort if currently animating
            else vars.in_animation = true;		// Otherwise set animation marker

            clearInterval(vars.slideshow_interval);	// Stop slideshow

            var slides = base.options.slides,					// Pull in slides array
			liveslide = base.$el.find('.activeslide');		// Find active slide
            $('.prevslide').removeClass('prevslide');
            liveslide.removeClass('activeslide').addClass('prevslide');	// Remove active class & update previous slide


            var nextslide = $(base.el + ' li:eq(' + vars.current_slide + ')'),
				prevslide = base.$el.find('.prevslide');

            // If hybrid mode is on drop quality for transition
            if (base.options.performance == 1) base.$el.removeClass('quality').addClass('speed');


            /*-----Load Image-----*/

            loadSlide = false;

            vars.current_slide == base.options.slides.length - 1 ? loadSlide = 0 : loadSlide = vars.current_slide + 1;	// Determine next slide

            var targetList = base.el + ' li:eq(' + loadSlide + ')';
            if (!$(targetList).html()) {

                // If links should open in new window
                var linkTarget = base.options.new_window ? ' target="_blank"' : '';

                imageLink = (base.options.slides[loadSlide].url) ? "href='" + base.options.slides[loadSlide].url + "'" : "";	// If link exists, build it
                var img = $('<img src="' + base.options.slides[loadSlide].image + '"/>');

                img.appendTo(targetList).wrap('<a ' + imageLink + linkTarget + '></a>').parent().parent().addClass('image-loading').css('visibility', 'hidden');

                img.load(function () {
                    base._origDim($(this));
                    base.resizeNow();
                });	// End Load
            };

            // Update thumbnails (if enabled)
            if (base.options.thumbnail_navigation == 1) {

                // Load previous thumbnail
                vars.current_slide - 1 < 0 ? prevThumb = base.options.slides.length - 1 : prevThumb = vars.current_slide - 1;
                $(vars.prev_thumb).html($("<img/>").attr("src", base.options.slides[prevThumb].image));

                // Load next thumbnail
                nextThumb = loadSlide;
                $(vars.next_thumb).html($("<img/>").attr("src", base.options.slides[nextThumb].image));

            }



            /*-----End Load Image-----*/


            // Call theme function for before slide transition
            if (typeof theme != 'undefined' && typeof theme.beforeAnimation == "function") theme.beforeAnimation('next');

            //Update slide markers
            if (base.options.slide_links) {
                $('.current-slide').removeClass('current-slide');
                $(vars.slide_list + '> li').eq(vars.current_slide).addClass('current-slide');
            }

            nextslide.css('visibility', 'hidden').addClass('activeslide');	// Update active slide

            switch (base.options.transition) {
                case 0: case 'none':	// No transition
                    nextslide.css('visibility', 'visible'); vars.in_animation = false; base.afterAnimation();
                    break;
                case 1: case 'fade':	// Fade
                    nextslide.css({ opacity: 0, 'visibility': 'visible' }).animate({ opacity: 1, avoidTransforms: false }, base.options.transition_speed, function () { base.afterAnimation(); });
                    break;
                case 2: case 'slideTop':	// Slide Top
                    nextslide.css({ top: -base.$el.height(), 'visibility': 'visible' }).animate({ top: 0, avoidTransforms: false }, base.options.transition_speed, function () { base.afterAnimation(); });
                    break;
                case 3: case 'slideRight':	// Slide Right
                    nextslide.css({ left: base.$el.width(), 'visibility': 'visible' }).animate({ left: 0, avoidTransforms: false }, base.options.transition_speed, function () { base.afterAnimation(); });
                    break;
                case 4: case 'slideBottom': // Slide Bottom
                    nextslide.css({ top: base.$el.height(), 'visibility': 'visible' }).animate({ top: 0, avoidTransforms: false }, base.options.transition_speed, function () { base.afterAnimation(); });
                    break;
                case 5: case 'slideLeft':  // Slide Left
                    nextslide.css({ left: -base.$el.width(), 'visibility': 'visible' }).animate({ left: 0, avoidTransforms: false }, base.options.transition_speed, function () { base.afterAnimation(); });
                    break;
                case 6: case 'carouselRight':	// Carousel Right
                    nextslide.css({ left: base.$el.width(), 'visibility': 'visible' }).animate({ left: 0, avoidTransforms: false }, base.options.transition_speed, function () { base.afterAnimation(); });
                    liveslide.animate({ left: -base.$el.width(), avoidTransforms: false }, base.options.transition_speed);
                    break;
                case 7: case 'carouselLeft':   // Carousel Left
                    nextslide.css({ left: -base.$el.width(), 'visibility': 'visible' }).animate({ left: 0, avoidTransforms: false }, base.options.transition_speed, function () { base.afterAnimation(); });
                    liveslide.animate({ left: base.$el.width(), avoidTransforms: false }, base.options.transition_speed);
                    break;
            }
            return false;
        };


        /* Previous Slide
		----------------------------*/
        base.prevSlide = function () {

            if (vars.in_animation || !api.options.slideshow) return false;		// Abort if currently animating
            else vars.in_animation = true;		// Otherwise set animation marker

            var old_slide_number = vars.current_slide;
            // Get current slide number
            if (vars.current_slide > 0) {
                vars.current_slide--;
            } else if (base.options.loop) {
                vars.current_slide = base.options.slides.length - 1;
            }

            if (old_slide_number == vars.current_slide) {
                vars.in_animation = false;
                return false;
            }

            clearInterval(vars.slideshow_interval);	// Stop slideshow

            var slides = base.options.slides,					// Pull in slides array
				liveslide = base.$el.find('.activeslide');		// Find active slide
            $('.prevslide').removeClass('prevslide');
            liveslide.removeClass('activeslide').addClass('prevslide');		// Remove active class & update previous slide

            var nextslide = $(base.el + ' li:eq(' + vars.current_slide + ')'),
				prevslide = base.$el.find('.prevslide');

            // If hybrid mode is on drop quality for transition
            if (base.options.performance == 1) base.$el.removeClass('quality').addClass('speed');


            /*-----Load Image-----*/

            loadSlide = vars.current_slide;

            var targetList = base.el + ' li:eq(' + loadSlide + ')';
            if (!$(targetList).html()) {
                // If links should open in new window
                var linkTarget = base.options.new_window ? ' target="_blank"' : '';
                imageLink = (base.options.slides[loadSlide].url) ? "href='" + base.options.slides[loadSlide].url + "'" : "";	// If link exists, build it
                var img = $('<img src="' + base.options.slides[loadSlide].image + '"/>');

                img.appendTo(targetList).wrap('<a ' + imageLink + linkTarget + '></a>').parent().parent().addClass('image-loading').css('visibility', 'hidden');

                img.load(function () {
                    base._origDim($(this));
                    base.resizeNow();
                });	// End Load
            };

            // Update thumbnails (if enabled)
            if (base.options.thumbnail_navigation == 1) {

                // Load previous thumbnail
                //prevThumb = loadSlide;
                loadSlide == 0 ? prevThumb = base.options.slides.length - 1 : prevThumb = loadSlide - 1;
                $(vars.prev_thumb).html($("<img/>").attr("src", base.options.slides[prevThumb].image));

                // Load next thumbnail
                vars.current_slide == base.options.slides.length - 1 ? nextThumb = 0 : nextThumb = vars.current_slide + 1;
                $(vars.next_thumb).html($("<img/>").attr("src", base.options.slides[nextThumb].image));
            }

            /*-----End Load Image-----*/


            // Call theme function for before slide transition
            if (typeof theme != 'undefined' && typeof theme.beforeAnimation == "function") theme.beforeAnimation('prev');

            //Update slide markers
            if (base.options.slide_links) {
                $('.current-slide').removeClass('current-slide');
                $(vars.slide_list + '> li').eq(vars.current_slide).addClass('current-slide');
            }

            nextslide.css('visibility', 'hidden').addClass('activeslide');	// Update active slide

            switch (base.options.transition) {
                case 0: case 'none':	// No transition
                    nextslide.css('visibility', 'visible'); vars.in_animation = false; base.afterAnimation();
                    break;
                case 1: case 'fade':	// Fade
                    nextslide.css({ opacity: 0, 'visibility': 'visible' }).animate({ opacity: 1, avoidTransforms: false }, base.options.transition_speed, function () { base.afterAnimation(); });
                    break;
                case 2: case 'slideTop':	// Slide Top (reverse)
                    nextslide.css({ top: base.$el.height(), 'visibility': 'visible' }).animate({ top: 0, avoidTransforms: false }, base.options.transition_speed, function () { base.afterAnimation(); });
                    break;
                case 3: case 'slideRight':	// Slide Right (reverse)
                    nextslide.css({ left: -base.$el.width(), 'visibility': 'visible' }).animate({ left: 0, avoidTransforms: false }, base.options.transition_speed, function () { base.afterAnimation(); });
                    break;
                case 4: case 'slideBottom': // Slide Bottom (reverse)
                    nextslide.css({ top: -base.$el.height(), 'visibility': 'visible' }).animate({ top: 0, avoidTransforms: false }, base.options.transition_speed, function () { base.afterAnimation(); });
                    break;
                case 5: case 'slideLeft':  // Slide Left (reverse)
                    nextslide.css({ left: base.$el.width(), 'visibility': 'visible' }).animate({ left: 0, avoidTransforms: false }, base.options.transition_speed, function () { base.afterAnimation(); });
                    break;
                case 6: case 'carouselRight':	// Carousel Right (reverse)
                    nextslide.css({ left: -base.$el.width(), 'visibility': 'visible' }).animate({ left: 0, avoidTransforms: false }, base.options.transition_speed, function () { base.afterAnimation(); });
                    liveslide.css({ left: 0 }).animate({ left: base.$el.width(), avoidTransforms: false }, base.options.transition_speed);
                    break;
                case 7: case 'carouselLeft':   // Carousel Left (reverse)
                    nextslide.css({ left: base.$el.width(), 'visibility': 'visible' }).animate({ left: 0, avoidTransforms: false }, base.options.transition_speed, function () { base.afterAnimation(); });
                    liveslide.css({ left: 0 }).animate({ left: -base.$el.width(), avoidTransforms: false }, base.options.transition_speed);
                    break;
            }
            return false;
        };


        /* Play/Pause Toggle
		----------------------------*/
        base.playToggle = function () {

            if (vars.in_animation || !api.options.slideshow) return false;		// Abort if currently animating

            if (vars.is_paused) {

                vars.is_paused = false;

                // Call theme function for play
                if (typeof theme != 'undefined' && typeof theme.playToggle == "function") theme.playToggle('play');

                // Resume slideshow
                vars.slideshow_interval = setInterval(base.nextSlide, base.options.slide_interval);

            } else {

                vars.is_paused = true;

                // Call theme function for pause
                if (typeof theme != 'undefined' && typeof theme.playToggle == "function") theme.playToggle('pause');

                // Stop slideshow
                clearInterval(vars.slideshow_interval);

            }

            return false;

        };

        /* Tear down this instance of supersized
		----------------------------*/
        base.destroy = function (causedByAutoExit) {
            if (vars.in_animation || !api.options.slideshow) return;		// Abort if currently animating

            // Start slideshow if paused. Without this, the slideshow is paused and the play/pause button has the wrong icon
            // when the user clicks the 'start slideshow' button a second time.
            if (vars.is_paused)
                api.playToggle();

            clearInterval(vars.slideshow_interval);

            // Unbind events (requires jQuery 1.7+)
            $(document.documentElement).off('.supersized');
            $('.ssControlsContainer *').off('click');

            var currentSlideId = vars.options.slides[vars.current_slide].id;

            vars = null;
            api = null;

            // Remove slideshow DOM elements and restore the page.
            $('#supersized-loader,#supersized,.ssControlsContainer').remove();
            $('body .supersized_hidden').show().removeClass('supersized_hidden');

            $(window).off('resize');

            // Trigger on_destroy event
            base.options.on_destroy.apply(null, [currentSlideId, causedByAutoExit || false]);
        };

        /* Go to specific slide
	----------------------------*/
        base.goTo = function (targetSlide) {
            if (vars.in_animation || !api.options.slideshow) return false;		// Abort if currently animating

            var totalSlides = base.options.slides.length;

            // If target outside range
            if (targetSlide < 0) {
                targetSlide = totalSlides;
            } else if (targetSlide > totalSlides) {
                targetSlide = 1;
            }
            targetSlide = totalSlides - targetSlide + 1;

            clearInterval(vars.slideshow_interval);	// Stop slideshow, prevent buildup

            // Call theme function for goTo trigger
            if (typeof theme != 'undefined' && typeof theme.goTo == "function") theme.goTo();

            if (vars.current_slide == totalSlides - targetSlide) {
                if (!(vars.is_paused)) {
                    vars.slideshow_interval = setInterval(base.nextSlide, base.options.slide_interval);
                }
                return false;
            }

            // If ahead of current position
            if (totalSlides - targetSlide > vars.current_slide) {

                // Adjust for new next slide
                vars.current_slide = totalSlides - targetSlide - 1;
                vars.update_images = 'next';
                base._placeSlide(vars.update_images);

                //Otherwise it's before current position
            } else if (totalSlides - targetSlide < vars.current_slide) {

                // Adjust for new prev slide
                vars.current_slide = totalSlides - targetSlide + 1;
                vars.update_images = 'prev';
                base._placeSlide(vars.update_images);

            }

            // set active markers
            if (base.options.slide_links) {
                $(vars.slide_list + '> .current-slide').removeClass('current-slide');
                $(vars.slide_list + '> li').eq((totalSlides - targetSlide)).addClass('current-slide');
            }

            if (base.options.thumb_links) {
                $(vars.thumb_list + '> .current-thumb').removeClass('current-thumb');
                $(vars.thumb_list + '> li').eq((totalSlides - targetSlide)).addClass('current-thumb');
            }

        };


        /* Place Slide
----------------------------*/
        base._placeSlide = function (place) {

            // If links should open in new window
            var linkTarget = base.options.new_window ? ' target="_blank"' : '';

            loadSlide = false;

            if (place == 'next') {

                vars.current_slide == base.options.slides.length - 1 ? loadSlide = 0 : loadSlide = vars.current_slide + 1;	// Determine next slide

                var targetList = base.el + ' li:eq(' + loadSlide + ')';

                if (!$(targetList).html()) {
                    // If links should open in new window
                    var linkTarget = base.options.new_window ? ' target="_blank"' : '';

                    imageLink = (base.options.slides[loadSlide].url) ? "href='" + base.options.slides[loadSlide].url + "'" : "";	// If link exists, build it
                    var img = $('<img src="' + base.options.slides[loadSlide].image + '"/>');

                    img.appendTo(targetList).wrap('<a ' + imageLink + linkTarget + '></a>').parent().parent().addClass('image-loading').css('visibility', 'hidden');

                    img.load(function () {
                        base._origDim($(this));
                        base.resizeNow();
                    });	// End Load
                };

                base.nextSlide();

            } else if (place == 'prev') {

                vars.current_slide - 1 < 0 ? loadSlide = base.options.slides.length - 1 : loadSlide = vars.current_slide - 1;	// Determine next slide

                var targetList = base.el + ' li:eq(' + loadSlide + ')';

                if (!$(targetList).html()) {
                    // If links should open in new window
                    var linkTarget = base.options.new_window ? ' target="_blank"' : '';

                    imageLink = (base.options.slides[loadSlide].url) ? "href='" + base.options.slides[loadSlide].url + "'" : "";	// If link exists, build it
                    var img = $('<img src="' + base.options.slides[loadSlide].image + '"/>');

                    img.appendTo(targetList).wrap('<a ' + imageLink + linkTarget + '></a>').parent().parent().addClass('image-loading').css('visibility', 'hidden');

                    img.load(function () {
                        base._origDim($(this));
                        base.resizeNow();
                    });	// End Load
                };
                base.prevSlide();
            }

        };


        /* Get Original Dimensions
		----------------------------*/
        base._origDim = function (targetSlide) {
            targetSlide.data('origWidth', targetSlide.width()).data('origHeight', targetSlide.height());
        };


        /* After Slide Animation
		----------------------------*/
        base.afterAnimation = function () {

            // If hybrid mode is on swap back to higher image quality
            if (base.options.performance == 1) {
                base.$el.removeClass('speed').addClass('quality');
            }

            // Update previous slide
            if (vars.update_images) {
                vars.current_slide - 1 < 0 ? setPrev = base.options.slides.length - 1 : setPrev = vars.current_slide - 1;
                vars.update_images = false;
                $('.prevslide').removeClass('prevslide');
                $(base.el + ' li:eq(' + setPrev + ')').addClass('prevslide');
            }

            vars.in_animation = false;

            // Resume slideshow
            if (!vars.is_paused && base.options.slideshow) {
                vars.slideshow_interval = setInterval(base.nextSlide, base.options.slide_interval);
                if (!base.options.loop && !base.options.auto_exit && vars.current_slide == base.options.slides.length - 1) base.playToggle();
            }

            // Call theme function for after slide transition
            if (typeof theme != 'undefined' && typeof theme.afterAnimation == "function") theme.afterAnimation();

            return false;

        };

        base.getField = function (field) {
            return base.options.slides[vars.current_slide][field];
        };

        // Make it go!
        base.init();
    };


    /* Global Variables
	----------------------------*/
    $.supersized.vars = {

        // Elements							
        thumb_tray: '#thumb-tray',	// Thumbnail tray
        thumb_list: '#thumb-list',	// Thumbnail list
        slide_list: '#slide-list',	// Slide link list

        // Internal variables
        current_slide: 0,			// Current slide number
        in_animation: false,		// Prevents animations from stacking
        is_paused: false,		// Tracks paused on/off
        hover_pause: false,		// If slideshow is paused from hover
        slideshow_interval: false,		// Stores slideshow timer					
        update_images: false,		// Trigger to update images after slide jump
        options: {}			// Stores assembled options list

    };


    /* Default Options
	----------------------------*/
    $.supersized.defaultOptions = {

        // Functionality
        slideshow: 1,			// Slideshow on/off
        autoplay: 1,			// Slideshow starts playing automatically
        auto_exit: 0,      // Exit the slideshow when the last slide is finished
        start_slide: 1,			// Start slide (0 is random)
        loop: 1,			// Enables moving between the last and first slide.
        random: 0,			// Randomize slide order (Ignores start slide)
        slide_interval: 5000,		// Length between transitions
        transition: 1, 			// 0-None, 1-Fade, 2-Slide Top, 3-Slide Right, 4-Slide Bottom, 5-Slide Left, 6-Carousel Right, 7-Carousel Left
        transition_speed: 750,		// Speed of transition
        new_window: 1,			// Image links open in new window/tab
        pause_hover: 0,			// Pause slideshow on hover
        keyboard_nav: 1,			// Keyboard navigation on/off
        performance: 1,			// 0-Normal, 1-Hybrid speed/quality, 2-Optimizes image quality, 3-Optimizes transition speed //  (Only works for Firefox/IE, not Webkit)
        image_protect: 1,			// Disables image dragging and right click with Javascript

        // Size & Position
        fit_always: 0,			// Image will never exceed browser width or height (Ignores min. dimensions)
        fit_landscape: 0,			// Landscape images will not exceed browser width
        fit_portrait: 1,			// Portrait images will not exceed browser height  			   
        min_width: 0,			// Min width allowed (in pixels)
        min_height: 0,			// Min height allowed (in pixels)
        horizontal_center: 1,			// Horizontally center background
        vertical_center: 1,			// Vertically center background


        // Components							
        slide_links: 1,			// Individual links for each slide (Options: false, 'num', 'name', 'blank')
        thumb_links: 1,			// Individual thumb links for each slide
        thumbnail_navigation: 0,			// Thumbnail navigation
        on_destroy: function () { } // Empty implementation for on_destroy event, may be overridden by user

    };

    $.fn.supersized = function (options) {
        return this.each(function () {
            (new $.supersized(options));
        });
    };

})(jQuery);

/*
	supersized.shutter.js
	Supersized - Fullscreen Slideshow jQuery Plugin
	Version : 3.2.7
	Theme 	: Shutter 1.1
	
	Site	: www.buildinternet.com/project/supersized
	Author	: Sam Dunn
	Company : One Mighty Roar (www.onemightyroar.com)
	License : MIT License / GPL License

*/

(function ($) {

    theme = {


        /* Initial Placement
		----------------------------*/
        _init: function () {

            // Configure Slide Links
            if (api.options.slide_links) {
                // Note: This code is repeated in the resize event, so if you change it here do it there, too.
                var maxSlideListWidth = $(vars.slide_list).parent().width() - 400; // Constrain the slide bullets area width so they don't cover buttons
                $(vars.slide_list).css('margin-left', -$(vars.slide_list).width() / 2).css('max-width', maxSlideListWidth);
            }

            // Start progressbar if autoplay enabled
            if (api.options.autoplay) {
                if (api.options.progress_bar) theme.progressBar(); else $(vars.progress_bar).parent().hide();
            } else {
                if ($(vars.play_button).attr('src')) $(vars.play_button).attr("src", api.options.image_path + "play.png");	// If pause play button is image, swap src
                if (api.options.progress_bar)
                    $(vars.progress_bar).stop().css({ left: -$(window).width() });	//  Place progress bar
                else
                    $(vars.progress_bar).parent().hide();
            }


            /* Thumbnail Tray
			----------------------------*/
            // Hide tray off screen
            $(vars.thumb_tray).css({ bottom: -($(vars.thumb_tray).outerHeight() + 5) });

            // Thumbnail Tray Toggle
            $(vars.tray_button).click(function(e) {
                var isExpanded = $(e.currentTarget).data('isExpanded') || false;

                if (isExpanded) {
                    $(vars.thumb_tray).stop().animate({ bottom: -($(vars.thumb_tray).outerHeight() + 5), avoidTransforms: true }, 300);
                    if ($(vars.tray_arrow).attr('src')) $(vars.tray_arrow).attr("src", api.options.image_path + "button-tray-up.png");
                } else {
                    $(vars.thumb_tray).stop().animate({ bottom: 0, avoidTransforms: true }, 300);
                    if ($(vars.tray_arrow).attr('src')) $(vars.tray_arrow).attr("src", api.options.image_path + "button-tray-down.png");
                }
                $(e.currentTarget).data('isExpanded', !isExpanded);
                    
                return false;
            });

            // Make thumb tray proper size
            $(vars.thumb_list).width($('> li', vars.thumb_list).length * $('> li', vars.thumb_list).outerWidth(true));	//Adjust to true width of thumb markers

            // Display total slides
            if ($(vars.slide_total).length) {
                $(vars.slide_total).html(api.options.slides.length);
            }


            /* Thumbnail Tray Navigation
			----------------------------*/
            if (api.options.thumb_links) {
                //Hide thumb arrows if not needed
                if ($(vars.thumb_list).width() <= $(vars.thumb_tray).width()) {
                    $(vars.thumb_back + ',' + vars.thumb_forward).fadeOut(0);
                }

                // Thumb Intervals
                vars.thumb_interval = Math.floor($(vars.thumb_tray).width() / $('> li', vars.thumb_list).outerWidth(true)) * $('> li', vars.thumb_list).outerWidth(true);
                vars.thumb_page = 0;

                // Cycle thumbs forward
                $(vars.thumb_forward).click(function () {
                    if (vars.thumb_page - vars.thumb_interval <= -$(vars.thumb_list).width()) {
                        vars.thumb_page = 0;
                        $(vars.thumb_list).stop().animate({ 'left': vars.thumb_page }, { duration: 500, easing: 'easeOutExpo' });
                    } else {
                        vars.thumb_page = vars.thumb_page - vars.thumb_interval;
                        $(vars.thumb_list).stop().animate({ 'left': vars.thumb_page }, { duration: 500, easing: 'easeOutExpo' });
                    }
                });

                // Cycle thumbs backwards
                $(vars.thumb_back).click(function () {
                    if (vars.thumb_page + vars.thumb_interval > 0) {
                        vars.thumb_page = Math.floor($(vars.thumb_list).width() / vars.thumb_interval) * -vars.thumb_interval;
                        if ($(vars.thumb_list).width() <= -vars.thumb_page) vars.thumb_page = vars.thumb_page + vars.thumb_interval;
                        $(vars.thumb_list).stop().animate({ 'left': vars.thumb_page }, { duration: 500, easing: 'easeOutExpo' });
                    } else {
                        vars.thumb_page = vars.thumb_page + vars.thumb_interval;
                        $(vars.thumb_list).stop().animate({ 'left': vars.thumb_page }, { duration: 500, easing: 'easeOutExpo' });
                    }
                });

            }


            /* Navigation Items
			----------------------------*/
            $(vars.next_slide).click(function () {
                api.nextSlide();
            });

            $(vars.prev_slide).click(function () {
                api.prevSlide();
            });

            // Add touchscreen support for wiping left and right. Requires existence of touchwipe library (http://www.netcu.de/jquery-touchwipe-iphone-ipad-library)
            var isTouchScreen = !!('ontouchstart' in window) || !!navigator.msMaxTouchPoints;
            if (isTouchScreen && $.fn.touchwipe) {
                vars.$container.touchwipe({
                    wipeLeft: function () { api.nextSlide(); },
                    wipeRight: function () { api.prevSlide(); }
                });
            }

            // Full Opacity on Hover
            if (jQuery.support.opacity) {
                $(vars.prev_slide + ',' + vars.next_slide).mouseover(function () {
                    $(this).stop().animate({ opacity: 1 }, 100);
                }).mouseout(function () {
                    $(this).stop().animate({ opacity: 0.6 }, 100);
                });
            }

            if (api.options.thumbnail_navigation) {
                // Next thumbnail clicked
                $(vars.next_thumb).click(function () {
                    api.nextSlide();
                });
                // Previous thumbnail clicked
                $(vars.prev_thumb).click(function () {
                    api.prevSlide();
                });
            }

            $(vars.play_button).click(function () {
                api.playToggle();
            });


            /* Thumbnail Mouse Scrub
			----------------------------*/
            if (api.options.mouse_scrub) {
                $(vars.thumb_tray).mousemove(function (e) {
                    var containerWidth = $(vars.thumb_tray).width(),
						listWidth = $(vars.thumb_list).width();
                    if (listWidth > containerWidth) {
                        var mousePos = 1,
							diff = e.pageX - mousePos;
                        if (diff > 10 || diff < -10) {
                            mousePos = e.pageX;
                            newX = (containerWidth - listWidth) * (e.pageX / containerWidth);
                            diff = parseInt(Math.abs(parseInt($(vars.thumb_list).css('left')) - newX)).toFixed(0);
                            $(vars.thumb_list).stop().animate({ 'left': newX }, { duration: diff * 3, easing: 'easeOutExpo' });
                        }
                    }
                });
            }


            /* Window Resize
			----------------------------*/
            $(window).resize(function () {

                // Delay progress bar on resize
                if (api.options.progress_bar && !vars.in_animation) {
                    if (vars.slideshow_interval) clearInterval(vars.slideshow_interval);
                    if (api.options.slides.length - 1 > 0) clearInterval(vars.slideshow_interval);

                    $(vars.progress_bar).stop().css({ left: -$(window).width() });

                    if (!vars.progressDelay && api.options.slideshow) {
                        // Delay slideshow from resuming so Chrome can refocus images
                        vars.progressDelay = setTimeout(function () {
                            if (!vars.is_paused) {
                                theme.progressBar();
                                vars.slideshow_interval = setInterval(api.nextSlide, api.options.slide_interval);
                            }
                            vars.progressDelay = false;
                        }, 1000);
                    }
                }

                // Thumb Links
                if (api.options.thumb_links && vars.thumb_tray.length) {
                    // Update Thumb Interval & Page
                    vars.thumb_page = 0;
                    vars.thumb_interval = Math.floor($(vars.thumb_tray).width() / $('> li', vars.thumb_list).outerWidth(true)) * $('> li', vars.thumb_list).outerWidth(true);

                    // Adjust thumbnail markers
                    if ($(vars.thumb_list).width() > $(vars.thumb_tray).width()) {
                        $(vars.thumb_back + ',' + vars.thumb_forward).fadeIn('fast');
                        $(vars.thumb_list).stop().animate({ 'left': 0 }, 200);
                    } else {
                        $(vars.thumb_back + ',' + vars.thumb_forward).fadeOut('fast');
                    }

                }

                // Configure Slide Links
                if (api.options.slide_links) {
                    // Note: This code is repeated in the _init function, so if you change it here do it there, too.
                    maxSlideListWidth = $(vars.slide_list).parent().width() - 400; // Constrain the slide bullets area width so they don't cover buttons
                    $(vars.slide_list).css('margin-left', -$(vars.slide_list).width() / 2).css('max-width', maxSlideListWidth);
                }
            });


        },


        /* Go To Slide
		----------------------------*/
        goTo: function () {
            if (api.options.progress_bar && !vars.is_paused) {
                $(vars.progress_bar).stop().css({ left: -$(window).width() });
                theme.progressBar();
            }
        },

        /* Play & Pause Toggle
		----------------------------*/
        playToggle: function (state) {

            if (state == 'play') {
                // If image, swap to pause
                if ($(vars.play_button).attr('src')) $(vars.play_button).attr("src", api.options.image_path + "pause.png");
                if (api.options.progress_bar && !vars.is_paused) theme.progressBar();
            } else if (state == 'pause') {
                // If image, swap to play
                if ($(vars.play_button).attr('src')) $(vars.play_button).attr("src", api.options.image_path + "play.png");
                if (api.options.progress_bar && vars.is_paused) $(vars.progress_bar).stop().css({ left: -$(window).width() });
            }

        },


        /* Before Slide Transition
		----------------------------*/
        beforeAnimation: function (direction) {
            if (api.options.progress_bar && !vars.is_paused) $(vars.progress_bar).stop().css({ left: -$(window).width() });

            /* Update Fields
			----------------------------*/
            // Update slide caption
            if ($(vars.slide_caption).length) {
                (api.getField('title')) ? $(vars.slide_caption).html(api.getField('title')) : $(vars.slide_caption).html('');
            }
            // Update slide number
            if (vars.slide_current.length) {
                $(vars.slide_current).html(vars.current_slide + 1);
            }


            // Highlight current thumbnail and adjust row position
            if (api.options.thumb_links) {

                $('.current-thumb').removeClass('current-thumb');
                $('li', vars.thumb_list).eq(vars.current_slide).addClass('current-thumb');

                // If thumb out of view
                if ($(vars.thumb_list).width() > $(vars.thumb_tray).width()) {
                    // If next slide direction
                    if (direction == 'next') {
                        if (vars.current_slide == 0) {
                            vars.thumb_page = 0;
                            $(vars.thumb_list).stop().animate({ 'left': vars.thumb_page }, { duration: 500, easing: 'easeOutExpo' });
                        } else if ($('.current-thumb').offset().left - $(vars.thumb_tray).offset().left >= vars.thumb_interval) {
                            vars.thumb_page = vars.thumb_page - vars.thumb_interval;
                            $(vars.thumb_list).stop().animate({ 'left': vars.thumb_page }, { duration: 500, easing: 'easeOutExpo' });
                        }
                        // If previous slide direction
                    } else if (direction == 'prev') {
                        if (vars.current_slide == api.options.slides.length - 1) {
                            vars.thumb_page = Math.floor($(vars.thumb_list).width() / vars.thumb_interval) * -vars.thumb_interval;
                            if ($(vars.thumb_list).width() <= -vars.thumb_page) vars.thumb_page = vars.thumb_page + vars.thumb_interval;
                            $(vars.thumb_list).stop().animate({ 'left': vars.thumb_page }, { duration: 500, easing: 'easeOutExpo' });
                        } else if ($('.current-thumb').offset().left - $(vars.thumb_tray).offset().left < 0) {
                            if (vars.thumb_page + vars.thumb_interval > 0) return false;
                            vars.thumb_page = vars.thumb_page + vars.thumb_interval;
                            $(vars.thumb_list).stop().animate({ 'left': vars.thumb_page }, { duration: 500, easing: 'easeOutExpo' });
                        }
                    }
                }


            }

        },


        /* After Slide Transition
		----------------------------*/
        afterAnimation: function () {
            if (api.options.progress_bar && !vars.is_paused) theme.progressBar();	//  Start progress bar
        },


        /* Progress Bar
		----------------------------*/
        progressBar: function () {
            $(vars.progress_bar).stop().css({ left: -$(window).width() }).animate({ left: 0 }, api.options.slide_interval);
        }


    };


    /* Theme Specific Variables
	----------------------------*/
    $.supersized.themeVars = {

        // Internal Variables
        progress_delay: false,				// Delay after resize before resuming slideshow
        thumb_page: false,				// Thumbnail page
        thumb_interval: false,				// Thumbnail interval

        // General Elements							
        play_button: '#pauseplay',		// Play/Pause button
        next_slide: '#nextslide',		// Next slide button
        prev_slide: '#prevslide',		// Prev slide button
        next_thumb: '#nextthumb',		// Next slide thumb button
        prev_thumb: '#prevthumb',		// Prev slide thumb button

        slide_caption: '#slidecaption',	// Slide caption
        slide_current: '.slidenumber',		// Current slide number
        slide_total: '.totalslides',		// Total Slides
        slide_list: '#slide-list',		// Slide jump list							

        thumb_tray: '#thumb-tray',		// Thumbnail tray
        thumb_list: '#thumb-list',		// Thumbnail list
        thumb_forward: '#thumb-forward',	// Cycles forward through thumbnail list
        thumb_back: '#thumb-back',		// Cycles backwards through thumbnail list
        tray_arrow: '#tray-arrow',		// Thumbnail tray button arrow
        tray_button: '#tray-button',		// Thumbnail tray button

        progress_bar: '#progress-bar'		// Progress bar

    };

    /* Theme Specific Options
	----------------------------*/
    $.supersized.themeOptions = {

        progress_bar: 1,		// Timer for each slide											
        image_path: 'img/',				// Default image path
        mouse_scrub: 0,		// Thumbnails move with mouse
        // html_template contains the HTML for the slideshow controls
        html_template: '<div class="ssControlsContainer"> \
		<!--Thumbnail Navigation--> \
		<div id="prevthumb"></div> \
		<div id="nextthumb"></div> \
\
		<!--Arrow Navigation--> \
		<a id="prevslide" class="load-item"></a> \
		<a id="nextslide" class="load-item"></a> \
\
		<div id="thumb-tray" class="load-item"> \
			<div id="thumb-back"></div> \
			<div id="thumb-forward"></div> \
		</div> \
\
		<!--Time Bar--> \
		<div id="progress-back" class="load-item"> \
			<div id="progress-bar"></div> \
		</div> \
\
		<!--Control Bar--> \
		<div id="controls-wrapper" class="load-item"> \
			<div id="controls"> \
\
				<a id="play-button"> \
					<img id="pauseplay" src="img/pause.png" /></a> \
\
				<a id="stop-button"> \
					<img src="img/stop.png" /></a> \
\
				<!--Slide counter--> \
				<div id="slidecounter"> \
					<span class="slidenumber"></span>/ <span class="totalslides"></span> \
				</div> \
\
				<!--Slide captions displayed here--> \
				<div id="slidecaption"></div> \
\
				<!--Thumb Tray button--> \
				<a id="tray-button"> \
					<img id="tray-arrow" src="img/button-tray-up.png" /></a> \
\
				<!--Navigation--> \
				<ul id="slide-list"></ul> \
\
			</div> \
		</div> \
</div>'

    };


})(jQuery);

//#endregion End supersized

//#region MultiSelect

/*
 * jQuery MultiSelect UI Widget 1.13
 * Copyright (c) 2012 Eric Hynds
 *
 * http://www.erichynds.com/jquery/jquery-ui-multiselect-widget/
 *
 * Depends:
 *   - jQuery 1.4.2+
 *   - jQuery UI 1.8 widget factory
 *
 * Optional:
 *   - jQuery UI effects
 *   - jQuery UI position utility
 *
 * Dual licensed under the MIT and GPL licenses:
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 *
 * CHANGE LOG
 * 2014-05-30 - HTML-encode quotes. See [Roger]
 *
*/
(function ($, undefined) {

    var multiselectID = 0;

    $.widget("ech.multiselect", {

        // default options
        options: {
            header: true,
            height: 175,
            minWidth: 225,
            classes: '',
            checkAllText: 'Check all',
            uncheckAllText: 'Uncheck all',
            noneSelectedText: 'Select options',
            selectedText: '# selected',
            selectedList: 0,
            show: null,
            hide: null,
            autoOpen: false,
            multiple: true,
            position: {}
        },

        _create: function () {
            var el = this.element.hide(),
				o = this.options;

            this.speed = $.fx.speeds._default; // default speed for effects
            this._isOpen = false; // assume no

            var
				button = (this.button = $('<button type="button"><span class="ui-icon ui-icon-triangle-2-n-s"></span></button>'))
					.addClass('ui-multiselect ui-widget ui-state-default ui-corner-all')
					.addClass(o.classes)
					.attr({ 'title': el.attr('title'), 'aria-haspopup': true, 'tabIndex': el.attr('tabIndex') })
					.insertAfter(el),

				buttonlabel = (this.buttonlabel = $('<span />'))
					.html(o.noneSelectedText)
					.appendTo(button),

				menu = (this.menu = $('<div />'))
					.addClass('ui-multiselect-menu ui-widget ui-widget-content ui-corner-all')
					.addClass(o.classes)
					.appendTo(document.body),

				header = (this.header = $('<div />'))
					.addClass('ui-widget-header ui-corner-all ui-multiselect-header ui-helper-clearfix')
					.appendTo(menu),

				headerLinkContainer = (this.headerLinkContainer = $('<ul />'))
					.addClass('ui-helper-reset')
					.html(function () {
					    if (o.header === true) {
					        return '<li><a class="ui-multiselect-all" href="#"><span class="ui-icon ui-icon-check"></span><span>' + o.checkAllText + '</span></a></li><li><a class="ui-multiselect-none" href="#"><span class="ui-icon ui-icon-closethick"></span><span>' + o.uncheckAllText + '</span></a></li>';
					    } else if (typeof o.header === "string") {
					        return '<li>' + o.header + '</li>';
					    } else {
					        return '';
					    }
					})
					.append('<li class="ui-multiselect-close"><a href="#" class="ui-multiselect-close"><span class="ui-icon ui-icon-circle-close"></span></a></li>')
					.appendTo(header),

				checkboxContainer = (this.checkboxContainer = $('<ul />'))
					.addClass('ui-multiselect-checkboxes ui-helper-reset')
					.appendTo(menu);

            // perform event bindings
            this._bindEvents();

            // build menu
            this.refresh(true);

            // some addl. logic for single selects
            if (!o.multiple) {
                menu.addClass('ui-multiselect-single');
            }
        },

        _init: function () {
            if (this.options.header === false) {
                this.header.hide();
            }
            if (!this.options.multiple) {
                this.headerLinkContainer.find('.ui-multiselect-all, .ui-multiselect-none').hide();
            }
            if (this.options.autoOpen) {
                this.open();
            }
            if (this.element.is(':disabled')) {
                this.disable();
            }
        },

        refresh: function (init) {
            var el = this.element,
				o = this.options,
				menu = this.menu,
				checkboxContainer = this.checkboxContainer,
				optgroups = [],
				html = "",
				id = el.attr('id') || multiselectID++; // unique ID for the label & option tags

            // build items
            el.find('option').each(function (i) {
                var $this = $(this),
					parent = this.parentNode,
					title = this.innerHTML,
					description = this.title,
					value = this.value,
					inputID = 'ui-multiselect-' + (this.id || id + '-option-' + i),
					isDisabled = this.disabled,
					isSelected = this.selected,
					labelClasses = ['ui-corner-all'],
					liClasses = (isDisabled ? 'ui-multiselect-disabled ' : ' ') + this.className,
					optLabel;

                // is this an optgroup?
                if (parent.tagName === 'OPTGROUP') {
                    optLabel = parent.getAttribute('label');

                    // has this optgroup been added already?
                    if ($.inArray(optLabel, optgroups) === -1) {
                        html += '<li class="ui-multiselect-optgroup-label ' + parent.className + '"><a href="#">' + optLabel + '</a></li>';
                        optgroups.push(optLabel);
                    }
                }

                if (isDisabled) {
                    labelClasses.push('ui-state-disabled');
                }

                // browsers automatically select the first option
                // by default with single selects
                if (isSelected && !o.multiple) {
                    labelClasses.push('ui-state-active');
                }

                html += '<li class="' + liClasses + '">';

                // create the label
                html += '<label for="' + inputID + '" title="' + description + '" class="' + labelClasses.join(' ') + '">';
                html += '<input id="' + inputID + '" name="multiselect_' + id + '" type="' + (o.multiple ? "checkbox" : "radio") + '" value="' + value.replace(/\"/g, '&quot;') + '" title="' + title.replace(/\"/g, '&quot;') + '"'; // [Roger] Added replace function to HTML encode quotes

                // pre-selected?
                if (isSelected) {
                    html += ' checked="checked"';
                    html += ' aria-selected="true"';
                }

                // disabled?
                if (isDisabled) {
                    html += ' disabled="disabled"';
                    html += ' aria-disabled="true"';
                }

                // add the title and close everything off
                html += ' /><span>' + title + '</span></label></li>';
            });

            // insert into the DOM
            checkboxContainer.html(html);

            // cache some moar useful elements
            this.labels = menu.find('label');
            this.inputs = this.labels.children('input');

            // set widths
            this._setButtonWidth();
            this._setMenuWidth();

            // remember default value
            this.button[0].defaultValue = this.update();

            // broadcast refresh event; useful for widgets
            if (!init) {
                this._trigger('refresh');
            }
        },

        // updates the button text. call refresh() to rebuild
        update: function () {
            var o = this.options,
				$inputs = this.inputs,
				$checked = $inputs.filter(':checked'),
				numChecked = $checked.length,
				value;

            if (numChecked === 0) {
                value = o.noneSelectedText;
            } else {
                if ($.isFunction(o.selectedText)) {
                    value = o.selectedText.call(this, numChecked, $inputs.length, $checked.get());
                } else if (/\d/.test(o.selectedList) && o.selectedList > 0 && numChecked <= o.selectedList) {
                    value = $checked.map(function () { return $(this).next().html(); }).get().join(', ');
                } else {
                    value = o.selectedText.replace('#', numChecked).replace('#', $inputs.length);
                }
            }

            this.buttonlabel.html(value);
            return value;
        },

        // binds events
        _bindEvents: function () {
            var self = this, button = this.button;

            function clickHandler() {
                self[self._isOpen ? 'close' : 'open']();
                return false;
            }

            // webkit doesn't like it when you click on the span :(
            button
				.find('span')
				.bind('click.multiselect', clickHandler);

            // button events
            button.bind({
                click: clickHandler,
                keypress: function (e) {
                    switch (e.which) {
                        case 27: // esc
                        case 38: // up
                        case 37: // left
                            self.close();
                            break;
                        case 39: // right
                        case 40: // down
                            self.open();
                            break;
                    }
                },
                mouseenter: function () {
                    if (!button.hasClass('ui-state-disabled')) {
                        $(this).addClass('ui-state-hover');
                    }
                },
                mouseleave: function () {
                    $(this).removeClass('ui-state-hover');
                },
                focus: function () {
                    if (!button.hasClass('ui-state-disabled')) {
                        $(this).addClass('ui-state-focus');
                    }
                },
                blur: function () {
                    $(this).removeClass('ui-state-focus');
                }
            });

            // header links
            this.header
				.delegate('a', 'click.multiselect', function (e) {
				    // close link
				    if ($(this).hasClass('ui-multiselect-close')) {
				        self.close();

				        // check all / uncheck all
				    } else {
				        self[$(this).hasClass('ui-multiselect-all') ? 'checkAll' : 'uncheckAll']();
				    }

				    e.preventDefault();
				});

            // optgroup label toggle support
            this.menu
				.delegate('li.ui-multiselect-optgroup-label a', 'click.multiselect', function (e) {
				    e.preventDefault();

				    var $this = $(this),
						$inputs = $this.parent().nextUntil('li.ui-multiselect-optgroup-label').find('input:visible:not(:disabled)'),
						nodes = $inputs.get(),
						label = $this.parent().text();

				    // trigger event and bail if the return is false
				    if (self._trigger('beforeoptgrouptoggle', e, { inputs: nodes, label: label }) === false) {
				        return;
				    }

				    // toggle inputs
				    self._toggleChecked(
						$inputs.filter(':checked').length !== $inputs.length,
						$inputs
					);

				    self._trigger('optgrouptoggle', e, {
				        inputs: nodes,
				        label: label,
				        checked: nodes[0].checked
				    });
				})
				.delegate('label', 'mouseenter.multiselect', function () {
				    if (!$(this).hasClass('ui-state-disabled')) {
				        self.labels.removeClass('ui-state-hover');
				        $(this).addClass('ui-state-hover').find('input').focus();
				    }
				})
				.delegate('label', 'keydown.multiselect', function (e) {
				    e.preventDefault();

				    switch (e.which) {
				        case 9: // tab
				        case 27: // esc
				            self.close();
				            break;
				        case 38: // up
				        case 40: // down
				        case 37: // left
				        case 39: // right
				            self._traverse(e.which, this);
				            break;
				        case 13: // enter
				            $(this).find('input')[0].click();
				            break;
				    }
				})
				.delegate('input[type="checkbox"], input[type="radio"]', 'click.multiselect', function (e) {
				    var $this = $(this),
						val = this.value,
						checked = this.checked,
						tags = self.element.find('option');

				    // bail if this input is disabled or the event is cancelled
				    if (this.disabled || self._trigger('click', e, { value: val, text: this.title, checked: checked }) === false) {
				        e.preventDefault();
				        return;
				    }

				    // make sure the input has focus. otherwise, the esc key
				    // won't close the menu after clicking an item.
				    $this.focus();

				    // toggle aria state
				    $this.attr('aria-selected', checked);

				    // change state on the original option tags
				    tags.each(function () {
				        if (this.value === val) {
				            this.selected = checked;
				        } else if (!self.options.multiple) {
				            this.selected = false;
				        }
				    });

				    // some additional single select-specific logic
				    if (!self.options.multiple) {
				        self.labels.removeClass('ui-state-active');
				        $this.closest('label').toggleClass('ui-state-active', checked);

				        // close menu
				        self.close();
				    }

				    // fire change on the select box
				    self.element.trigger("change");

				    // setTimeout is to fix multiselect issue #14 and #47. caused by jQuery issue #3827
				    // http://bugs.jquery.com/ticket/3827
				    setTimeout($.proxy(self.update, self), 10);
				});

            // close each widget when clicking on any other element/anywhere else on the page
            $(document).bind('mousedown.multiselect', function (e) {
                if (self._isOpen && !$.contains(self.menu[0], e.target) && !$.contains(self.button[0], e.target) && e.target !== self.button[0]) {
                    self.close();
                }
            });

            // deal with form resets.  the problem here is that buttons aren't
            // restored to their defaultValue prop on form reset, and the reset
            // handler fires before the form is actually reset.  delaying it a bit
            // gives the form inputs time to clear.
            $(this.element[0].form).bind('reset.multiselect', function () {
                setTimeout($.proxy(self.refresh, self), 10);
            });
        },

        // set button width
        _setButtonWidth: function () {
            var width = this.element.outerWidth(),
				o = this.options;

            if (/\d/.test(o.minWidth) && width < o.minWidth) {
                width = o.minWidth;
            }

            // set widths
            this.button.width(width);
        },

        // set menu width
        _setMenuWidth: function () {
            var m = this.menu,
				width = this.button.outerWidth() -
					parseInt(m.css('padding-left'), 10) -
					parseInt(m.css('padding-right'), 10) -
					parseInt(m.css('border-right-width'), 10) -
					parseInt(m.css('border-left-width'), 10);

            m.width(width || this.button.outerWidth());
        },

        // move up or down within the menu
        _traverse: function (which, start) {
            var $start = $(start),
				moveToLast = which === 38 || which === 37,

				// select the first li that isn't an optgroup label / disabled
				$next = $start.parent()[moveToLast ? 'prevAll' : 'nextAll']('li:not(.ui-multiselect-disabled, .ui-multiselect-optgroup-label)')[moveToLast ? 'last' : 'first']();

            // if at the first/last element
            if (!$next.length) {
                var $container = this.menu.find('ul').last();

                // move to the first/last
                this.menu.find('label')[moveToLast ? 'last' : 'first']().trigger('mouseover');

                // set scroll position
                $container.scrollTop(moveToLast ? $container.height() : 0);

            } else {
                $next.find('label').trigger('mouseover');
            }
        },

        // This is an internal function to toggle the checked property and
        // other related attributes of a checkbox.
        //
        // The context of this function should be a checkbox; do not proxy it.
        _toggleState: function (prop, flag) {
            return function () {
                if (!this.disabled) {
                    this[prop] = flag;
                }

                if (flag) {
                    this.setAttribute('aria-selected', true);
                } else {
                    this.removeAttribute('aria-selected');
                }
            };
        },

        _toggleChecked: function (flag, group) {
            var $inputs = (group && group.length) ? group : this.inputs,
				self = this;

            // toggle state on inputs
            $inputs.each(this._toggleState('checked', flag));

            // give the first input focus
            $inputs.eq(0).focus();

            // update button text
            this.update();

            // gather an array of the values that actually changed
            var values = $inputs.map(function () {
                return this.value;
            }).get();

            // toggle state on original option tags
            this.element
				.find('option')
				.each(function () {
				    if (!this.disabled && $.inArray(this.value, values) > -1) {
				        self._toggleState('selected', flag).call(this);
				    }
				});

            // trigger the change event on the select
            if ($inputs.length) {
                this.element.trigger("change");
            }
        },

        _toggleDisabled: function (flag) {
            this.button
				.attr({ 'disabled': flag, 'aria-disabled': flag })[flag ? 'addClass' : 'removeClass']('ui-state-disabled');

            var inputs = this.menu.find('input');
            var key = "ech-multiselect-disabled";

            if (flag) {
                // remember which elements this widget disabled (not pre-disabled)
                // elements, so that they can be restored if the widget is re-enabled.
                inputs = inputs.filter(':enabled')
					.data(key, true)
            } else {
                inputs = inputs.filter(function () {
                    return $.data(this, key) === true;
                }).removeData(key);
            }

            inputs
				.attr({ 'disabled': flag, 'arial-disabled': flag })
				.parent()[flag ? 'addClass' : 'removeClass']('ui-state-disabled');

            this.element
				.attr({ 'disabled': flag, 'aria-disabled': flag });
        },

        // open the menu
        open: function (e) {
            var self = this,
				button = this.button,
				menu = this.menu,
				speed = this.speed,
				o = this.options,
				args = [];

            // bail if the multiselectopen event returns false, this widget is disabled, or is already open
            if (this._trigger('beforeopen') === false || button.hasClass('ui-state-disabled') || this._isOpen) {
                return;
            }

            var $container = menu.find('ul').last(),
				effect = o.show,
				pos = button.offset();

            // figure out opening effects/speeds
            if ($.isArray(o.show)) {
                effect = o.show[0];
                speed = o.show[1] || self.speed;
            }

            // if there's an effect, assume jQuery UI is in use
            // build the arguments to pass to show()
            if (effect) {
                args = [effect, speed];
            }

            // set the scroll of the checkbox container
            $container.scrollTop(0).height(o.height);

            // position and show menu
            if ($.ui.position && !$.isEmptyObject(o.position)) {
                o.position.of = o.position.of || button;

                menu
					.show()
					.position(o.position)
					.hide();

                // if position utility is not available...
            } else {
                menu.css({
                    top: pos.top + button.outerHeight(),
                    left: pos.left
                });
            }

            // show the menu, maybe with a speed/effect combo
            $.fn.show.apply(menu, args);

            // select the first option
            // triggering both mouseover and mouseover because 1.4.2+ has a bug where triggering mouseover
            // will actually trigger mouseenter.  the mouseenter trigger is there for when it's eventually fixed
            this.labels.eq(0).trigger('mouseover').trigger('mouseenter').find('input').trigger('focus');

            button.addClass('ui-state-active');
            this._isOpen = true;
            this._trigger('open');
        },

        // close the menu
        close: function () {
            if (this._trigger('beforeclose') === false) {
                return;
            }

            var o = this.options,
					effect = o.hide,
					speed = this.speed,
					args = [];

            // figure out opening effects/speeds
            if ($.isArray(o.hide)) {
                effect = o.hide[0];
                speed = o.hide[1] || this.speed;
            }

            if (effect) {
                args = [effect, speed];
            }

            $.fn.hide.apply(this.menu, args);
            this.button.removeClass('ui-state-active').trigger('blur').trigger('mouseleave');
            this._isOpen = false;
            this._trigger('close');
        },

        enable: function () {
            this._toggleDisabled(false);
        },

        disable: function () {
            this._toggleDisabled(true);
        },

        checkAll: function (e) {
            this._toggleChecked(true);
            this._trigger('checkAll');
        },

        uncheckAll: function () {
            this._toggleChecked(false);
            this._trigger('uncheckAll');
        },

        getChecked: function () {
            return this.menu.find('input').filter(':checked');
        },

        destroy: function () {
            // remove classes + data
            $.Widget.prototype.destroy.call(this);

            this.button.remove();
            this.menu.remove();
            this.element.show();

            return this;
        },

        isOpen: function () {
            return this._isOpen;
        },

        widget: function () {
            return this.menu;
        },

        getButton: function () {
            return this.button;
        },

        // react to option changes after initialization
        _setOption: function (key, value) {
            var menu = this.menu;

            switch (key) {
                case 'header':
                    menu.find('div.ui-multiselect-header')[value ? 'show' : 'hide']();
                    break;
                case 'checkAllText':
                    menu.find('a.ui-multiselect-all span').eq(-1).text(value);
                    break;
                case 'uncheckAllText':
                    menu.find('a.ui-multiselect-none span').eq(-1).text(value);
                    break;
                case 'height':
                    menu.find('ul').last().height(parseInt(value, 10));
                    break;
                case 'minWidth':
                    this.options[key] = parseInt(value, 10);
                    this._setButtonWidth();
                    this._setMenuWidth();
                    break;
                case 'selectedText':
                case 'selectedList':
                case 'noneSelectedText':
                    this.options[key] = value; // these all needs to update immediately for the update() call
                    this.update();
                    break;
                case 'classes':
                    menu.add(this.button).removeClass(this.options.classes).addClass(value);
                    break;
                case 'multiple':
                    menu.toggleClass('ui-multiselect-single', !value);
                    this.options.multiple = value;
                    this.element[0].multiple = value;
                    this.refresh();
            }

            $.Widget.prototype._setOption.apply(this, arguments);
        }
    });

})(jQuery);

//#endregion End MultiSelect

//#region JQCloud

/*!
 * jQCloud Plugin for jQuery https://github.com/lucaong/jQCloud
 * 
 * Version 1.0.4
 *
 * Copyright 2011, Luca Ongaro
 * Licensed under the MIT license.
 *
 * Date: 2013-05-09 18:54:22 +0200
*/

(function ($) {
    "use strict";
    $.fn.jQCloud = function (word_array, options) {
        // Reference to the container element
        var $this = this;
        // Namespace word ids to avoid collisions between multiple clouds
        var cloud_namespace = $this.attr('id') || Math.floor((Math.random() * 1000000)).toString(36);

        // Default options value
        var default_options = {
            width: $this.width(),
            height: $this.height(),
            center: {
                x: ((options && options.width) ? options.width : $this.width()) / 2.0,
                y: ((options && options.height) ? options.height : $this.height()) / 2.0
            },
            delayedMode: word_array.length > 50,
            shape: false, // It defaults to elliptic shape
            encodeURI: true,
            removeOverflowing: true
        };

        options = $.extend(default_options, options || {});

        // Add the "jqcloud" class to the container for easy CSS styling, set container width/height
        $this.addClass("jqcloud").width(options.width).height(options.height);

        // Container's CSS position cannot be 'static'
        if ($this.css("position") === "static") {
            $this.css("position", "relative");
        }

        var drawWordCloud = function () {
            // Helper function to test if an element overlaps others
            var hitTest = function (elem, other_elems) {
                // Pairwise overlap detection
                var overlapping = function (a, b) {
                    if (Math.abs(2.0 * a.offsetLeft + a.offsetWidth - 2.0 * b.offsetLeft - b.offsetWidth) < a.offsetWidth + b.offsetWidth) {
                        if (Math.abs(2.0 * a.offsetTop + a.offsetHeight - 2.0 * b.offsetTop - b.offsetHeight) < a.offsetHeight + b.offsetHeight) {
                            return true;
                        }
                    }
                    return false;
                };
                var i = 0;
                // Check elements for overlap one by one, stop and return false as soon as an overlap is found
                for (i = 0; i < other_elems.length; i++) {
                    if (overlapping(elem, other_elems[i])) {
                        return true;
                    }
                }
                return false;
            };

            // Make sure every weight is a number before sorting
            for (var i = 0; i < word_array.length; i++) {
                word_array[i].weight = parseFloat(word_array[i].weight, 10);
            }

            // Sort word_array from the word with the highest weight to the one with the lowest
            word_array.sort(function (a, b) { if (a.weight < b.weight) { return 1; } else if (a.weight > b.weight) { return -1; } else { return 0; } });

            var step = (options.shape === "rectangular") ? 18.0 : 2.0,
					already_placed_words = [],
					aspect_ratio = options.width / options.height;

            // Function to draw a word, by moving it in spiral until it finds a suitable empty place. This will be iterated on each word.
            var drawOneWord = function (index, word) {
                // Define the ID attribute of the span that will wrap the word, and the associated jQuery selector string
                var word_id = cloud_namespace + "_word_" + index,
						word_selector = "#" + word_id,
						angle = 6.28 * Math.random(),
						radius = 0.0,

						// Only used if option.shape == 'rectangular'
						steps_in_direction = 0.0,
						quarter_turns = 0.0,

						weight = 5,
						custom_class = "",
						inner_html = "",
						word_span;

                // Extend word html options with defaults
                word.html = $.extend(word.html, { id: word_id });

                // If custom class was specified, put them into a variable and remove it from html attrs, to avoid overwriting classes set by jQCloud
                if (word.html && word.html["class"]) {
                    custom_class = word.html["class"];
                    delete word.html["class"];
                }

                // Check if min(weight) > max(weight) otherwise use default
                if (word_array[0].weight > word_array[word_array.length - 1].weight) {
                    // Linearly map the original weight to a discrete scale from 1 to 10
                    weight = Math.round((word.weight - word_array[word_array.length - 1].weight) /
															(word_array[0].weight - word_array[word_array.length - 1].weight) * 9.0) + 1;
                }
                word_span = $('<span>').attr(word.html).addClass('w' + weight + " " + custom_class);

                // Append link if word.url attribute was set
                if (word.link) {
                    // If link is a string, then use it as the link href
                    if (typeof word.link === "string") {
                        word.link = { href: word.link };
                    }

                    // Extend link html options with defaults
                    if (options.encodeURI) {
                        word.link = $.extend(word.link, { href: encodeURI(word.link.href).replace(/'/g, "%27") });
                    }

                    inner_html = $('<a>').attr(word.link).text(word.text);
                } else {
                    inner_html = word.text;
                }
                word_span.append(inner_html);

                // Bind handlers to words
                if (!!word.handlers) {
                    for (var prop in word.handlers) {
                        if (word.handlers.hasOwnProperty(prop) && typeof word.handlers[prop] === 'function') {
                            $(word_span).bind(prop, word.handlers[prop]);
                        }
                    }
                }

                $this.append(word_span);

                var width = word_span.width(),
						height = word_span.height(),
						left = options.center.x - width / 2.0,
						top = options.center.y - height / 2.0;

                // Save a reference to the style property, for better performance
                var word_style = word_span[0].style;
                word_style.position = "absolute";
                word_style.left = left + "px";
                word_style.top = top + "px";

                while (hitTest(word_span[0], already_placed_words)) {
                    // option shape is 'rectangular' so move the word in a rectangular spiral
                    if (options.shape === "rectangular") {
                        steps_in_direction++;
                        if (steps_in_direction * step > (1 + Math.floor(quarter_turns / 2.0)) * step * ((quarter_turns % 4 % 2) === 0 ? 1 : aspect_ratio)) {
                            steps_in_direction = 0.0;
                            quarter_turns++;
                        }
                        switch (quarter_turns % 4) {
                            case 1:
                                left += step * aspect_ratio + Math.random() * 2.0;
                                break;
                            case 2:
                                top -= step + Math.random() * 2.0;
                                break;
                            case 3:
                                left -= step * aspect_ratio + Math.random() * 2.0;
                                break;
                            case 0:
                                top += step + Math.random() * 2.0;
                                break;
                        }
                    } else { // Default settings: elliptic spiral shape
                        radius += step;
                        angle += (index % 2 === 0 ? 1 : -1) * step;

                        left = options.center.x - (width / 2.0) + (radius * Math.cos(angle)) * aspect_ratio;
                        top = options.center.y + radius * Math.sin(angle) - (height / 2.0);
                    }
                    word_style.left = left + "px";
                    word_style.top = top + "px";
                }

                // Don't render word if part of it would be outside the container
                if (options.removeOverflowing && (left < 0 || top < 0 || (left + width) > options.width || (top + height) > options.height)) {
                    word_span.remove()
                    return;
                }


                already_placed_words.push(word_span[0]);

                // Invoke callback if existing
                if ($.isFunction(word.afterWordRender)) {
                    word.afterWordRender.call(word_span);
                }
            };

            var drawOneWordDelayed = function (index) {
                index = index || 0;
                if (!$this.is(':visible')) { // if not visible then do not attempt to draw
                    setTimeout(function () { drawOneWordDelayed(index); }, 10);
                    return;
                }
                if (index < word_array.length) {
                    drawOneWord(index, word_array[index]);
                    setTimeout(function () { drawOneWordDelayed(index + 1); }, 10);
                } else {
                    if ($.isFunction(options.afterCloudRender)) {
                        options.afterCloudRender.call($this);
                    }
                }
            };

            // Iterate drawOneWord on every word. The way the iteration is done depends on the drawing mode (delayedMode is true or false)
            if (options.delayedMode) {
                drawOneWordDelayed();
            }
            else {
                $.each(word_array, drawOneWord);
                if ($.isFunction(options.afterCloudRender)) {
                    options.afterCloudRender.call($this);
                }
            }
        };

        // Delay execution so that the browser can render the page before the computatively intensive word cloud drawing
        setTimeout(function () { drawWordCloud(); }, 10);
        return $this;
    };
})(jQuery);

//#endregion End JQCloud

//#region jQuery UI Touch Punch

/*!
   * jQuery UI Touch Punch 0.2.3
   * http://touchpunch.furf.com
   *
   * Copyright 20112014, Dave Furfero
   * Dual licensed under the MIT or GPL Version 2 licenses.
   *
   * Depends:
   *  jquery.ui.widget.js
   *  jquery.ui.mouse.js
   *
   * [2015-08-06] Bug fix: Chrome on some devices was sending touchmove events even during careful touches by users, preventing them from being
   * converted into click events. I implemented the changed suggested in this pull request: https://github.com/furf/jquery-ui-touch-punch/pull/151
   */
(function ($) {

    // Detect touch support
    $.support.touch = 'ontouchend' in document;

    // Ignore browsers without touch support
    if (!$.support.touch) {
        return;
    }

    var mouseProto = $.ui.mouse.prototype,
      _mouseInit = mouseProto._mouseInit,
      _mouseDestroy = mouseProto._mouseDestroy,
      touchHandled;

    /**
   * Simulate a mouse event based on a corresponding touch event
   * @param {Object} event A touch event
   * @param {String} simulatedType The corresponding mouse event
   */
    function simulateMouseEvent(event, simulatedType) {

        // Ignore multi-touch events
        if (event.originalEvent.touches.length > 1) {
            return;
        }

        event.preventDefault();

        var touch = event.originalEvent.changedTouches[0],
        simulatedEvent = document.createEvent('MouseEvents');

        // Initialize the simulated mouse event using the touch event's coordinates
        simulatedEvent.initMouseEvent(
      simulatedType,    // type
      true,             // bubbles                    
      true,             // cancelable                 
      window,           // view                       
      1,                // detail                     
      touch.screenX,    // screenX                    
      touch.screenY,    // screenY                    
      touch.clientX,    // clientX                    
      touch.clientY,    // clientY                    
      false,            // ctrlKey                    
      false,            // altKey                     
      false,            // shiftKey                   
      false,            // metaKey                    
      0,                // button                     
      null              // relatedTarget              
    );

        // Dispatch the simulated event to the target element
        event.target.dispatchEvent(simulatedEvent);
    }

    /**
   * Handle the jQuery UI widget's touchstart events
   * @param {Object} event The widget element's touchstart event
   */
    mouseProto._touchStart = function (event) {

        var self = this;

        // Ignore the event if another widget is already being handled
        if (touchHandled || !self._mouseCapture(event.originalEvent.changedTouches[0])) {
            return;
        }

        // Set the flag to prevent other widgets from inheriting the touch event
        touchHandled = true;

        // Track movement to determine if interaction was a click
        self._touchMoved = 0;

        // Simulate the mouseover event
        simulateMouseEvent(event, 'mouseover');

        // Simulate the mousemove event
        simulateMouseEvent(event, 'mousemove');

        // Simulate the mousedown event
        simulateMouseEvent(event, 'mousedown');
    };

    /**
   * Handle the jQuery UI widget's touchmove events
   * @param {Object} event The document's touchmove event
   */
    mouseProto._touchMove = function (event) {

        // Ignore event if not handled
        if (!touchHandled) {
            return;
        }

        // Interaction was less likely to be a click
        this._touchMoved += 1;

        // Simulate the mousemove event
        simulateMouseEvent(event, 'mousemove');
    };

    /**
   * Handle the jQuery UI widget's touchend events
   * @param {Object} event The document's touchend event
   */
    mouseProto._touchEnd = function (event) {

        // Ignore event if not handled
        if (!touchHandled) {
            return;
        }

        // Simulate the mouseup event
        simulateMouseEvent(event, 'mouseup');

        // Simulate the mouseout event
        simulateMouseEvent(event, 'mouseout');

        // If the touch interaction did not move (much), it should trigger a click
        if (this._touchMoved <= 5) {

            // Simulate the click event
            simulateMouseEvent(event, 'click');
        }

        // Unset the flag to allow other widgets to inherit the touch event
        touchHandled = false;
    };

    /**
   * A duck punch of the $.ui.mouse _mouseInit method to support touch events.
   * This method extends the widget with bound touch event handlers that
   * translate touch events to mouse events and pass them to the widget's
   * original mouse event handling methods.
   */
    mouseProto._mouseInit = function () {

        var self = this;

        // Delegate the touch handlers to the widget's element
        self.element.bind({
            touchstart: $.proxy(self, '_touchStart'),
            touchmove: $.proxy(self, '_touchMove'),
            touchend: $.proxy(self, '_touchEnd')
        });

        // Call the original $.ui.mouse init method
        _mouseInit.call(self);
    };

    /**
   * Remove the touch event handlers
   */
    mouseProto._mouseDestroy = function () {

        var self = this;

        // Delegate the touch handlers to the widget's element
        self.element.unbind({
            touchstart: $.proxy(self, '_touchStart'),
            touchmove: $.proxy(self, '_touchMove'),
            touchend: $.proxy(self, '_touchEnd')
        });

        // Call the original $.ui.mouse destroy method
        _mouseDestroy.call(self);
    };

})(jQuery);

//#endregion End jQuery UI Touch Punch

//#region touchwipe

/**
 * jQuery Plugin to obtain touch gestures from iPhone, iPod Touch and iPad, should also work with Android mobile phones (not tested yet!)
 * Common usage: wipe images (left and right to show the previous or next image)
 * 
 * @author Andreas Waltl, netCU Internetagentur (http://www.netcu.de/jquery-touchwipe-iphone-ipad-library)
 * @version 1.1.1 (9th December 2010) - fix bug (older IE's had problems)
 * @version 1.1 (1st September 2010) - support wipe up and wipe down
 * @version 1.0 (15th July 2010)
 */
(function ($) {
    $.fn.touchwipe = function (settings) {
        var config = {
            min_move_x: 20,
            min_move_y: 20,
            wipeLeft: function () { },
            wipeRight: function () { },
            wipeUp: function () { },
            wipeDown: function () { },
            preventDefaultEvents: true
        };

        if (settings) $.extend(config, settings);

        this.each(function () {
            var startX;
            var startY;
            var isMoving = false;

            function cancelTouch() {
                this.removeEventListener('touchmove', onTouchMove);
                startX = null;
                isMoving = false;
            }

            function onTouchMove(e) {
                if (config.preventDefaultEvents) {
                    e.preventDefault();
                }
                if (isMoving) {
                    var x = e.touches[0].pageX;
                    var y = e.touches[0].pageY;
                    var dx = startX - x;
                    var dy = startY - y;
                    if (Math.abs(dx) >= config.min_move_x) {
                        cancelTouch();
                        if (dx > 0) {
                            config.wipeLeft();
                        }
                        else {
                            config.wipeRight();
                        }
                    }
                    else if (Math.abs(dy) >= config.min_move_y) {
                        cancelTouch();
                        if (dy > 0) {
                            config.wipeDown();
                        }
                        else {
                            config.wipeUp();
                        }
                    }
                }
            }

            function onTouchStart(e) {
                if (e.touches.length == 1) {
                    startX = e.touches[0].pageX;
                    startY = e.touches[0].pageY;
                    isMoving = true;
                    this.addEventListener('touchmove', onTouchMove, false);
                }
            }
            if ('ontouchstart' in document.documentElement) {
                this.addEventListener('touchstart', onTouchStart, false);
            }
        });

        return this;
    };

})(jQuery);

//#endregion End touchwipe

/*

 jQuery Textarea Fullscreen Editor v1.0
 Fullscreen text editor plugin for jQuery.

 :For more details visit http://github.com/CreoArt/jquery.textareafullscreen

 - CreoArt <support@creoart.org>
 - http://github.com/CreoArt

 Licensed under Apache - https://raw.githubusercontent.com/CreoArt/jquery.textareafullscreen/master/LICENSE

 */
(function ($) {
    "use strict";

    function isFullscreen() {
        return $('.tx-editor-overlay').length > 0;
    }

    function relocate(el) {
        var yPos = ($(window).height() - el.height()) / 2;
        var xPos = ($(window).width() - el.width()) / 2;

        el.css({
            'top': yPos,
            'left': xPos
        });
    }

    function transitions($el, $editor) {
        relocate($editor);

        if (isFullscreen()) {
            $el.focus();
        } else {
            $el.focus();
            $editor.css('opacity', 1);
        }
    }

    function FullscreenTextarea(el, opts) {
        var method,
            i;

        this.$el = $(el);

        this.settings = {
            overlay: true,
            maxWidth: '',
            maxHeight: ''
        };

        for (i = 0; i < this.bindMethods.length; i++) {
            method = this.bindMethods[i];
            this[method] = $.proxy(this, method);
        }

        this.init(opts);
    }

    FullscreenTextarea.prototype.$el = null;

    FullscreenTextarea.prototype.$widget = null;

    FullscreenTextarea.prototype.$editor = null;

    FullscreenTextarea.prototype.$icon = null;

    FullscreenTextarea.prototype.init = function (opts) {
        var content;

        this.settings = $.extend(true, this.settings, opts);

        if (!this.$el.is('textarea')) {
            $.error(
                'Error initializing Textarea Fullscreen Editor Plugin. It can only work on <textarea> element.'
            );
            return;
        }

        content =
            '<div class="tx-editor-wrapper"><div class="tx-editor"><span class="fa fa-2x tx-icon" title="Click to expand/collapse"></span></div></div>';
        this.$wrapper = $(content).insertAfter(this.$el);
        this.$editor = this.$wrapper.find('.tx-editor');
        this.$icon = this.$editor.find('.tx-icon');
        this.$editor.append(this.$el);

        this.$el.css({
            'width': '100%',
            'height': '100%',
            'resize': 'none'
        });

        //Fullscreen icon click event
        this.$icon.on('click.txeditor.icon', this.onIconClick);
    };


    FullscreenTextarea.prototype.bindMethods = ["onOverlayClick", "onIconClick", "onKeyUp", "onResize"];

    FullscreenTextarea.prototype.showOverlay = function () {
        $('<div class="tx-editor-overlay" />').appendTo('body')
            .fadeTo(0, 1)
            .click(this.onOverlayClick);
        return this;
    };

    FullscreenTextarea.prototype.removeOverlay = function () {
        var $overlay = $('.tx-editor-overlay');
        if ($overlay.length) {
            $overlay.fadeTo(0, 0, function () {
                $(this).remove();
            });
        }
        return this;
    };

    FullscreenTextarea.prototype.expand = function () {
        var settings = this.settings,
            $editor = this.$editor;

        if (settings.maxWidth) {
            $editor.css('max-width', settings.maxWidth);
        }
        if (settings.maxHeight) {
            $editor.css('max-height', settings.maxHeight);
        }

        if (settings.overlay) {
            this.showOverlay();
        }

        $editor.addClass('expanded');
        transitions(this.$el, this.$editor);

        //Adjust editor size on resize
        $(window).on('resize.txeditor', this.onResize);

        // ESC = closes the fullscreen mode
        $(window).on("keyup.txeditor", this.onKeyUp);

        return this;
    };

    FullscreenTextarea.prototype.minimize = function () {
        var settings = this.settings,
            $editor = this.$editor;

        $(window).off('resize.txeditor', this.onResize);
        $(window).off('keyup.txeditor', this.onKeyUp);

        $editor.removeClass('expanded')
            .css({
                'max-width': 'none',
                'max-height': 'none'
            });

        transitions(this.$el, $editor);

        if (settings.overlay) {
            this.removeOverlay();
        }

        return this;
    };

    FullscreenTextarea.prototype.destroy = function () {
        var $wrapper = this.$wrapper;

        this.removeOverlay();

        this.$el = this.$el.detach();
        this.$el.insertBefore($wrapper);
        $wrapper.remove();

        this.$wrapper = null;
        this.$icon = null;
        this.$editor = null;

        $(window).off('keyup.txeditor', this.onKeyUp)
            .off('resize.txeditor', this.onResize);

        return this;
    };

    FullscreenTextarea.prototype.onOverlayClick = function () {
        this.minimize();
    };

    FullscreenTextarea.prototype.onIconClick = function (e) {
        e.preventDefault();
        
        if (isFullscreen()) {
            this.minimize();
        } else {
            this.expand();
        }
    };

    FullscreenTextarea.prototype.onKeyUp = function (e) {
        if (e.keyCode === 27 && isFullscreen()) {
            this.minimize();
        }
    };

    FullscreenTextarea.prototype.onResize = function (e) {
        relocate(this.$editor);
    };

    $.fn.textareafullscreen = function (options) {
        return this.each(function () {
            var $this = $(this),
                fullscreenTextarea, args;

            if ("string" === typeof options) {
                fullscreenTextarea = $this.data('textareafullscreendata');

                if ("function" === typeof fullscreenTextarea[options]) {
                    args = Array.prototype.slice.call(arguments, 1);
                    return fullscreenTextarea[options].apply(fullscreenTextarea, args);
                } else {
                    $.error('Method ' + options +
                    ' does not exist on jQuery.textareafullscreen');
                }
            } else {
                $this.data('textareafullscreendata', new FullscreenTextarea(this, options));
            }
        });
    };
})(jQuery);
/* TO MODIFY: Make changes to this file and test locally under the Debug compilation configuration. When
finished, run this text through a javascript minifier and copy the output to lib.min.js.
There is an online minifier at http://gpbmike.github.io/refresh-sf/. */
var Gs;
(function (Gs) {
    var $ = jQuery;
    //#region Gallery-wide functions
    /**
    * A container for variables that can be used throughout the Gs module.
    * @module Vars
    */
    var Vars;
    (function (Vars) {
        // Not seen here is the dynamic property having the same name as the client ID of the div tag holding this gallery.
        // By default it is 'gsp_g' and it contains two properties: gsData: GalleryData and gsAlbumTreeData (object that can be fed to jsTree).
        // One can access these properties using bracket notation: var data = Gs.Vars[clientId].gsData
        /**
        * Get the path, relative to the web site root, to the current web application. Does not include the containing page
        * or the trailing slash. Example: If GS is installed at C:\inetpub\wwwroot\dev\gallery, and C:\inetpub\wwwroot\ is
        * the parent web site, this property returns /dev/gallery. This is assigned in GalleryPage.AddGlobalStartupScript
        * and ultimately comes from Utils.AppRoot on the server.
        */
        Vars.AppRoot = '';
        /**
         * Gets the URL to the current web application. Does not include the containing page or the trailing slash.
         * Example: If the gallery is installed in a virtual directory 'gallery' on domain 'www.site.com', this returns 'http://www.site.com/gallery'.
         */
        Vars.AppUrl = '';
        /**
        * Gets the path, relative to the current application, to the directory containing the Gallery Server resources such
        * as images, user controls, scripts, etc. This value is pulled from the AppSettings value "GalleryResourcesPath"
        * in web.config if present; otherwise it defaults to "gs". Examples: "gs", "GalleryServer\resources"
        * This is assigned in GalleryPage.AddGlobalStartupScript and ultimately comes from Utils.GalleryResourcesPath on the server.
        */
        Vars.GalleryResourcesRoot = '';
        /**
        * Gets a reference to the ID of a Microsoft Ajax Library component that implements IDisposable. Used to reference the
        * Silverlight component, if one is being used on the page to play a video or audio file.
        */
        Vars.msAjaxComponentId = '';
        /**
        * Gets a reference to the URL of the current page, with the hash tag removed.
        */
        Vars.href = '';
    })(Vars = Gs.Vars || (Gs.Vars = {}));
    /**
    * A container for functions that can be used throughout the Gs module.
    * @class Utils
    */
    var Utils = /** @class */ (function () {
        function Utils() {
        }
        /**
         * Replace apostrophes and quotation marks with their ASCII equivalents
         * @param value string
         * @returns {String} The escaped string
         */
        Utils.escape = function (value) { return value.replace(/\'/g, '&#39;').replace(/\"/g, '&quot;'); };
        /**
         * HTML encode a string. Note that this function will strip out extra whitespace, such as new lines and tabs.
         * @param value
         * @returns {string} The encoded string
         */
        Utils.htmlEncode = function (value) { return $('<div/>').text(value).html(); };
        /**
         * HTML decode a string.
         * @param value
         * @returns {string} The decoded string
         */
        Utils.htmlDecode = function (value) {
            return $('<div/>').html(value).text();
        };
        /**
         * Removes all HTML tags from the string. Also replaces apostrophes and quotation marks with their ASCII equivalents
         * @param value string
         * @returns {String} The string with HTML removed
         */
        Utils.removeHtmlTags = function (value) { return Utils.escape(value.replace(/(<[^<>]*>)/g, '')); };
        /**
         * Returns true when the current browser supports the checkValidity() function on form elements.
         */
        Utils.hasFormValidation = function () {
            return typeof document.createElement('input').checkValidity == 'function';
        };
        /**
         * Returns true when the user's screen is touch-enabled.
         */
        Utils.isTouchScreen = function () {
            // ReSharper disable once DoubleNegationOfBoolean
            return !!('ontouchstart' in window) || !!navigator.msMaxTouchPoints;
        };
        /**
         * Returns true for screens less than w px wide. See http://stackoverflow.com/questions/6850164
         */
        Utils.isWidthLessThan = function (w) {
            return window.matchMedia && window.matchMedia('(max-device-width: ' + w + 'px)').matches || screen.width <= w;
        };
        /**
         * Returns true for touch-enabled screens where only the center pane is visible. Gallery Server is hard-coded to show a single
         * pane for widths less than 750 pixels.
         */
        Utils.isSinglePaneTouchScreen = function () {
            return Utils.isTouchScreen() && Utils.isWidthLessThan(750);
        };
        /**
         * Get the width of the browser viewport. See http://stackoverflow.com/questions/3437786
         */
        Utils.getViewportWidth = function () {
            return window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
        };
        /**
         * Get the height of the browser viewport. See http://stackoverflow.com/questions/3437786
         */
        Utils.getViewportHeight = function () {
            return window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
        };
        /**
         * Returns true when obj is undefined, null, or an empty string.
         */
        Utils.isNullOrEmpty = function (obj) {
            if ((!obj && obj !== false) || !(obj.length > 0)) {
                return true;
            }
            return false;
        };
        /**
         * Performs a deep copy of the specified object.
         */
        Utils.deepCopy = function (o) {
            var copy = o, k;
            if (o && typeof o === 'object') {
                copy = Object.prototype.toString.call(o) === '[object Array]' ? [] : {};
                for (k in o) {
                    if (o.hasOwnProperty(k)) {
                        copy[k] = Utils.deepCopy(o[k]);
                    }
                }
            }
            return copy;
        };
        /**
         * Converts the album to an instance of GalleryItem.
         */
        Utils.convertAlbumToGalleryItem = function (a) {
            return { Id: a.Id, ParentId: a.ParentId, IsAlbum: true, MimeType: 0, ItemType: 3, NumAlbums: a.NumAlbums, NumMediaItems: a.NumMediaItems, Caption: a.Caption, Title: a.Title, ViewIndex: -1, Views: [] };
        };
        /**
         * Converts the media item to an instance of GalleryItem.
         */
        Utils.convertMediaItemToGalleryItem = function (m) {
            return { Id: m.Id, ParentId: m.AlbumId, IsAlbum: false, MimeType: m.MimeType, ItemType: m.ItemType, NumAlbums: 0, NumMediaItems: 0, Caption: '', Title: m.Title, ViewIndex: m.ViewIndex, Views: Utils.deepCopy(m.Views) };
        };
        /**
         * Gets a string representation of the item type.
         */
        Utils.getItemTypeDesc = function (itemType) {
            switch (itemType) {
                case Enums.ItemType.Album:
                    return 'Album';
                case Enums.ItemType.Image:
                    return 'Image';
                case Enums.ItemType.Audio:
                    return 'Audio';
                case Enums.ItemType.Video:
                    return 'Video';
                case Enums.ItemType.Generic:
                    return 'Generic';
                case Enums.ItemType.External:
                    return 'External';
                default:
                    return 'Unknown';
            }
        };
        /**
         * Finds the gallery item in data.Album.GalleryItems[] matching the specified ID and item type. Returns null if not found.
         */
        Utils.findGalleryItem = function (data, id, got) {
            if (data.Album != null && data.Album.GalleryItems != null)
                return $.grep(data.Album.GalleryItems, function (gi) { return (gi.Id === id && gi.ItemType === got); })[0];
            else
                return null;
        };
        /**
         * Finds the media item in data.Album.MediaItems[] matching the specified ID and - optionally - the item type. Returns null if not found.
         */
        Utils.findMediaItem = function (data, id, itemType) {
            if (data.Album != null && data.Album.MediaItems != null) {
                if (itemType == null)
                    return $.grep(data.Album.MediaItems, function (mi) { return (mi.Id === id); })[0];
                else
                    return $.grep(data.Album.MediaItems, function (mi) { return (mi.Id === id && mi.ItemType === itemType); })[0];
            }
            else
                return null;
        };
        /**
         * Finds the meta item in metaItems having the specified mTypeId. mTypeId maps to the MetadataItemName enumeration. Returns null if not found.
         */
        Utils.findMetaItem = function (metaItems, mTypeId) {
            return $.grep(metaItems, function (mi) { return mi.MTypeId === mTypeId; })[0] || null;
        };
        /**
         * Finds the meta item in metaItems having the specified id. Returns null if not found.
         */
        Utils.findMetaItemById = function (metaItems, id) {
            return $.grep(metaItems, function (mi) { return mi.Id === id; })[0] || null;
        };
        /**
         * Add the gallery items to the client-side data
         * @param data The gallery data to add the gallery items to.
         * @param gItems The gallery items to add to the gallery data.
         * CURRENTLY NOT USED (originally created when copying item to current album but came up with a different solution)
         */
        Utils.addGalleryItems = function (data, gItems) {
            $.each(gItems, function (indx, gi) {
                data.Album.GalleryItems.push(gi);
                data.Album.NumGalleryItems++;
                if (!gi.IsAlbum) {
                    data.Album.NumMediaItems++;
                }
            });
        };
        /**
         * Remove the gallery items from the client-side data
         * @param data The gallery data to remove the gallery items from.
         * @param gItems The gallery items to remove from the gallery data.
         */
        Utils.removeGalleryItems = function (data, gItems) {
            $.each(gItems, function (indx, gi) {
                // There is no guarantee that gItems are the same memory references as those in data.Album.GalleryItems,
                // (they won't be when we get here after deleting items), so we find the matching items in our data and remove those.
                var gi1 = Utils.findGalleryItem(data, gi.Id, gi.ItemType);
                if (gi1 != null) {
                    data.Album.GalleryItems.gspRemove($.inArray(gi1, data.Album.GalleryItems));
                    data.Album.NumGalleryItems--;
                    if (!gi.IsAlbum) {
                        data.Album.NumMediaItems--;
                    }
                }
            });
        };
        /**
         * Remove the media item from the data.Album.MediaItems[] array. Also updates the index of remaining media items in the array
         * and decrements the Album.NumGalleryItems and Album.NumMediaItems properties.
         * @param data The gallery data to remove the media item from.
         * @param mItem The media item to remove from the gallery data.
         */
        Utils.removeMediaItem = function (data, mItem) {
            var idx = $.inArray(mItem, data.Album.MediaItems);
            // Remove the media object at the specified index from the client data
            data.Album.MediaItems.gspRemove(idx);
            if (idx >= 0) {
                $.each(data.Album.MediaItems, function (indx, mo) {
                    mo.Index = indx + 1; // Re-assign the index values of each media object
                });
                data.Album.NumGalleryItems--;
                data.Album.NumMediaItems--;
                if (idx >= data.Album.MediaItems.length)
                    idx = data.Album.MediaItems.length - 1; // Deleted item was the last one; set index to 2nd to last one
                // Set current media item to the previous one so when we subsequently call showNextMediaObject we see the right one
                data.MediaItem = data.Album.MediaItems[idx - 1];
            }
            else
                data.MediaItem = null; // No more items in album; set to null. Calling code will detect and then redirect
        };
        /**
        * Get the requested view for the specified media item or gallery item. If the requested view is for the optimized version and
        * it does not exist, the original is returned; otherwise returns null when the requested size does not exist.
        * @param mediaItem An instance of MediaItem or GalleryItem
        * @param viewSize The size to be returned
        * @returns {DisplayObject}
        */
        Utils.getView = function (mediaItem, viewSize) {
            var orig = null;
            for (var i = 0; i < mediaItem.Views.length; i++) {
                if (mediaItem.Views[i].ViewSize === viewSize) {
                    return mediaItem.Views[i];
                }
                else if (mediaItem.Views[i].ViewSize === Enums.ViewSize.Original)
                    orig = mediaItem.Views[i];
            }
            return orig;
        };
        /**
        * Returns true if the specified media item or gallery item has the requested view; otherwise returns false.
        * @param mediaItem An instance of MediaItem or GalleryItem
        * @param viewSize The size to look for
        * @returns {boolean}
        */
        Utils.hasView = function (mediaItem, viewSize) {
            if (mediaItem.Views == null) {
                return false;
            }
            for (var i = 0; i < mediaItem.Views.length; i++) {
                if (mediaItem.Views[i].ViewSize === viewSize) {
                    return true;
                }
            }
            return false;
        };
        /**
         * Gets the page ready to go by turning input form elements into buttons, configuring jsRender converters and helper functions,
         * and assigning a few variables.
         */
        Utils.Init = function () {
            // To reduce chance of namespace collision, define an alias to Cookies object (https://github.com/js-cookie/js-cookie)
            Vars.Cookies = Cookies.noConflict();
            $('.gsp_ns input:submit, .gsp_ns button').button();
            // Set up jsRender converters
            $.views.converters({
                getItemTypeDesc: function (itemType) { return Utils.getItemTypeDesc(itemType); },
                stripHtml: function (text) { return Utils.removeHtmlTags(text); }
            });
            $.views.helpers({
                htmlEscape: function (value) { return Utils.escape(value); },
                // Parses a string representing a date into a JavaScript Date object. See https://github.com/jquery/globalize
                parseDate: function (value, formats, culture) { return Globalize.parseDate(value, formats, culture); },
                // Parses a string representing a whole number in the given radix (10 by default). See https://github.com/jquery/globalize
                parseInt: function (value, radix, culture) { return Globalize.parseInt(value, radix, culture); },
                // Parses a string representing a floating point number in the given radix (10 by default). See https://github.com/jquery/globalize
                parseFloat: function (value, radix, culture) {
                    return Globalize.parseFloat(value, radix, culture);
                },
                // Find the meta item for the specified type, returning an object set to default values if not found.
                findMetaItem: function (metaItems, mTypeId) { return (Utils.findMetaItem(metaItems, mTypeId) || new MetaItem(mTypeId)); },
                /**
                 * Gets URL to album. When preserveTags=true, several known query string parameters are included if already present; otherwise they are stripped.
                 * Ex: http://localhost/default.aspx?tag=desert, http://localhost/default.aspx?aid=44
                 * @param albumId The ID of the album the URL should navigate to. If no album ID is applicable (e.g. virtual albums), specify Constants.IntMinValue.
                 * @param preserveTags Indicates whether several known query string parameters should be preserved in the resulting URL.
                 * @returns {string} An URL pointing to the album having ID albumId
                 */
                getAlbumUrl: function (albumId, preserveTags) { return Utils.GetAlbumUrl(albumId, preserveTags); },
                /**
                 * Gets URL to the album or media asset corresponding to the galleryItem parameter. When preserveTags=true, several known query
                 * string parameters are included if already present; otherwise they are stripped .
                 * Ex: http://localhost/default.aspx?aid=44, http://localhost/default.aspx?tag=desert&moid=23
                 * @param galleryItem The gallery item the URL should navigate to.
                 * @param preserveTags Indicates whether several known query string parameters should be preserved in the resulting URL.
                 * @returns {} An URL pointing to the album or media asset corresponding to the galleryItem parameter.
                 */
                getGalleryItemUrl: function (galleryItem, preserveTags) {
                    var qs = { aid: galleryItem.IsAlbum ? galleryItem.Id : null, moid: galleryItem.IsAlbum ? null : galleryItem.Id };
                    if (!preserveTags) {
                        // Generally we want to strip tags for albums and preserve them for MOs. This allows users to browse MOs
                        // within the context of their tag/people/search criteria.
                        qs.title = null;
                        qs.tag = null;
                        qs.people = null;
                        qs.search = null;
                        qs.latest = null;
                        qs.filter = null;
                        qs.rating = null;
                        qs.top = null;
                    }
                    return Utils.GetUrl(Vars.href, qs);
                },
                getView: function (galleryItem, viewSize) { return Utils.getView(galleryItem, viewSize); },
                /**
                 * Get URL to media item. When preserveTags=true, several known query string parameters are included if already present; otherwise they are stripped.
                 * Ex: http://localhost/default.aspx?tag=desert&moid=23
                 * @param mediaId The ID of the media asset the URL should navigate to.
                 * @param preserveTags Indicates whether several known query string parameters should be preserved in the resulting URL.
                 * @returns {string} An URL pointing to the media asset having ID mediaId
                 */
                getMediaUrl: function (mediaId, preserveTags) { return Utils.GetMediaUrl(mediaId, preserveTags); },
                /**
                 * Gets URL to page where album objects can be downloaded. Ex: http://localhost/default.aspx?g=task_downloadobjects&aid=45
                 * @param albumId The ID of the album.
                 * @returns {string} An URL to the album download page.
                 */
                getDownloadUrl: function (albumId) { return Utils.GetUrl(window.location.href, { g: 'task_downloadobjects', moid: null, aid: albumId }); },
                /**
                 * Gets URL to add objects page for current album. Ex: http://localhost/default.aspx?g=task_addobjects&aid=45
                 * @param galleryData The gallery data
                 * @returns {string} An URL to the add objects page.
                 */
                getAddUrl: function (galleryData) { return Utils.GetUrl(window.location.href, { g: 'task_addobjects', aid: galleryData.Album.Id }); },
                /**
                 * Gets URL to the specified page. Any existing query string parameters are removed except for the media or album ID. Ex: http://localhost/default.aspx?g=task_addobjects&aid=45
                 * @param pageId The name of the destination page. Maps to PageId enumeration. Ex: task_addobjects, mediaobject, album, admin_manageusers
                 * @param galleryData The gallery data
                 * @returns {string} An URL to the page.
                 */
                getPageUrl: function (pageId, galleryData) {
                    var qsParms = { title: null, tag: null, people: null, search: null, latest: null, filter: null, rating: null, top: null, aid: null, moid: null };
                    qsParms.g = pageId;
                    if (galleryData.MediaItem != null) {
                        qsParms.moid = galleryData.MediaItem.Id;
                    }
                    else if (galleryData.Album.Id > Constants.IntMinValue) {
                        qsParms.aid = galleryData.Album.Id;
                    }
                    return Utils.GetUrl(window.location.href, qsParms);
                },
                /**
                 * Indicates whether the current screen has touch capabilities.
                 * @returns {boolean} true when the screen is touch capable; otherwise false
                 */
                isTouchScreen: function (boolean) { return Utils.isTouchScreen(); },
                /**
                 * Indicates whether the current screen has a width smaller than the specified number of pixels.
                 * @param number The width, in pixels, to test.
                 * @returns {boolean} true when the screen is less than the specified width; otherwise false
                 */
                isWidthLessThan: function (width) { return Utils.isWidthLessThan(width); },
                /**
                * Indicates whether the current screen has touch capabilities with only the center pane visible. Gallery Server is hard-coded to show a single
                * pane for widths less than 750 pixels.
                * @returns {boolean} true when the screen is a single-pane touch screen; otherwise false
                */
                isSinglePaneTouchScreen: function (boolean) { return Utils.isSinglePaneTouchScreen(); }
            });
            // Gets reference to current URL with hash tag removed
            Vars.href = window.location.href.replace(/#\d+/, '');
            Utils.StoreParentFrameUrlInSession();
        };
        /**
         * Reload the current page with all existing query string parameters preserved except for 'msg', which is removed if present.
         */
        Utils.ReloadPage = function () {
            window.location.href = Utils.RemoveQSParm(window.location.href, 'msg');
        };
        /**
         * Get the HTML embed code that can be used to embed the specified media asset on a web page.
         */
        Utils.GetEmbedCode = function (mediaId) {
            var url = Utils.GetUrl(Vars.AppUrl + '/' + Vars.GalleryResourcesRoot + '/embed.aspx' + location.search, { aid: null, moid: mediaId });
            return "<iframe allowtransparency='true' frameborder='0' sandbox='allow-same-origin allow-forms allow-scripts' scrolling='auto' src='" + url + "' style='width:100%;height:100%'></iframe>";
        };
        /**
         * Gets URL to album. When preserveTags=true, several known query string parameters are included if already present; otherwise they are stripped
         * Ex: http://localhost/default.aspx?tag=desert, http://localhost/default.aspx?aid=44
         * @param albumId The ID of the album the URL should navigate to. If no album ID is applicable (e.g. virtual albums), specify Constants.IntMinValue.
         * @param preserveTags Indicates whether several known query string parameters should be preserved in the resulting URL.
         * @returns {string} An URL pointing to the album having ID albumId
         */
        Utils.GetAlbumUrl = function (albumId, preserveTags) {
            var qs = { aid: null, moid: null };
            if (!preserveTags) {
                qs.title = null;
                qs.tag = null;
                qs.people = null;
                qs.search = null;
                qs.latest = null;
                qs.filter = null;
                qs.rating = null;
                qs.top = null;
            }
            if (albumId > Constants.IntMinValue)
                qs.aid = albumId;
            return Utils.GetUrl(document.location.href, qs);
        };
        /**
         * Get URL to the album, using parent window location if the gallery is contained within an iframe. This is useful for generating a link to the
         * page containing the iframe rather than a "deep link" directly to the album that would be generated by GetAlbumUrl(). For example, if a page
         * gallery.html contains an iframe that points to the default gallery page (default.aspx), this function will return http://site.com/gallery.html?aid=X
         * It is expected that the admin creating the page will have code that passes the query string to the iframe source as described in the Admin Guide.
         * @param albumId The ID of the album the URL should navigate to. If no album ID is applicable (e.g. virtual albums), specify Constants.IntMinValue.
         * @returns {string} An URL pointing to the album having ID albumId
         */
        Utils.GetAlbumExternalUrl = function (albumId) {
            var qs = { aid: null, moid: null };
            if (albumId > Constants.IntMinValue)
                qs.aid = albumId;
            var url = document.location.href;
            if (Utils.GetParentFrameUrl() != null) {
                url = Utils.GetParentFrameUrl() + document.location.search;
            }
            return Utils.GetUrl(url, qs);
        };
        /**
        * Get URL to media item. When preserveTags=true, several known query string parameters are included if already present; otherwise they are stripped.
        * Ex: http://localhost/default.aspx?tag=desert&moid=23
        * @param mediaId The ID of the media asset the URL should navigate to.
        * @param preserveTags Indicates whether several known query string parameters should be preserved in the resulting URL.
        * @returns {string} An URL pointing to the media asset having ID mediaId
        */
        Utils.GetMediaUrl = function (mediaId, preserveTags) {
            var qs = { aid: null, moid: mediaId };
            if (!preserveTags) {
                // Generally we want to strip tags for albums and preserve them for MOs. This allows users to browse MOs
                // within the context of their tag/people/search criteria.
                qs.title = null;
                qs.tag = null;
                qs.people = null;
                qs.search = null;
                qs.latest = null;
                qs.filter = null;
                qs.rating = null;
                qs.top = null;
            }
            return Utils.GetUrl(document.location.href, qs);
        };
        /**
         * Get URL to the media asset, using parent window location if the gallery is contained within an iframe. This is useful for generating a link to the
         * page containing the iframe rather than a "deep link" directly to the asset that would be generated by GetMediaUrl(). For example, if a page
         * gallery.html contains an iframe that points to the default gallery page (default.aspx), this function will return http://site.com/gallery.html?moid=X
         * It is expected that the admin creating the page will have code that passes the query string to the iframe source as described in the Admin Guide.
        * @param mediaId The ID of the media asset the URL should navigate to.
        * @returns {string} An URL pointing to the media asset having ID mediaId
        */
        Utils.GetMediaExternalUrl = function (mediaId) {
            var qs = { aid: null, moid: mediaId };
            var url = document.location.href;
            if (Utils.GetParentFrameUrl() != null) {
                url = Utils.GetParentFrameUrl() + document.location.search;
            }
            return Utils.GetUrl(url, qs);
        };
        /**
         * If we're within an iframe, try to get the parent frame's URL and store it in session storage. The only way to get the URL is from document.referrer,
         * and that will only be accurate the first time the user goes to the page containing the iframe. Detect this and put it in session storage so we can
         * refer to it on subsequent page loads.
         */
        Utils.StoreParentFrameUrlInSession = function () {
            var isInIframe = (parent !== window);
            if (isInIframe) {
                var referrerNoQs = void 0;
                if (document.referrer.indexOf('?') >= 0) {
                    // Strip off query string so we have something like http://site.com/gallery.aspx
                    referrerNoQs = document.referrer.substring(0, document.referrer.indexOf('?'));
                }
                else {
                    referrerNoQs = document.referrer;
                }
                var curPageUrlNoQs = document.location.origin + document.location.pathname; // Current URL w/o query string e.g. http://site.com/gallery.aspx
                if (referrerNoQs !== curPageUrlNoQs) {
                    // Referrer is different page than the current one, so it is highly probably referrer is the parent frame URL. Store in session storage (supported in IE 8+).
                    if (sessionStorage) {
                        sessionStorage.setItem('parentFrameUrl', document.referrer);
                    }
                }
            }
            else if (sessionStorage) {
                // Handle the (admittedly rare) situation where a user navigates directly to the gallery after being on a page with an iframe to the gallery
                sessionStorage.removeItem('parentFrameUrl');
            }
        };
        /**
         * Get the URL to the page containing this gallery in an iframe. If this gallery is not in an iframe, return null.
         */
        Utils.GetParentFrameUrl = function () {
            return sessionStorage && sessionStorage.getItem('parentFrameUrl');
        };
        /**
         * Generate an URL from the url parameter and having the specified query string parameters. If 'url' contains the 'ss' or 'msg' parameters,
         * they are removed. Ex: http://localhost/default.aspx?tag=desert, http://localhost/default.aspx?aid=44
         * @param url The URL to use for modification. This is often assigned from document.location.href.
         * @param parmValuePairs A set of query string parameters to assign to the URL
         * @returns {string} Returns the url with updated query string parameters.
         */
        Utils.GetUrl = function (url, parmValuePairs) {
            if (typeof parmValuePairs.ss === 'undefined')
                parmValuePairs.ss = null; // auto-start slide show
            if (typeof parmValuePairs.msg === 'undefined')
                parmValuePairs.msg = null; // msg ID
            $.each(parmValuePairs, function (p, v) { url = Utils.AddQSParm(Utils.RemoveQSParm(url, p), p, v); });
            return url;
        };
        /**
         * Indicates whether the specified query string parameter is present on the URL for the current page.
         * @param param The query string parameter name.
         * @returns {boolean} true if parameter is present; otherwise false
         */
        Utils.IsQSParmPresent = function (param) {
            var qs = Utils.GetQS[param];
            return ((qs != null) && (qs.length > 0));
        };
        /**
         * Gets an object where its properties represent the query string parameters for the current page.
         * @returns {Object} An object containing string properties representing the query string parameters.
         */
        Utils.GetQS = function () {
            var result = {};
            var queryString = location.search.substring(1);
            var re = /([^&=]+)=([^&]*)/g;
            var m;
            while ((m = re.exec(queryString))) {
                result[decodeURIComponent(m[1])] = decodeURIComponent(m[2]);
            }
            return result;
        };
        /**
         * Gets the value of the specified query string parameter. Returns undefined if the parameter is not present.
         * @param param The query string parameter name.
         * @returns {string} The query string parameter value.
         */
        Utils.GetQSParm = function (param) { return Utils.GetQS()[param]; };
        /**
         * Adds the specified query string name and value to the URL.
         * @param url The URL to add the query string value to
         * @param param The query string parameter name.
         * @param value The query string parameter value.
         * @returns {string} The updated URL.
         */
        Utils.AddQSParm = function (url, param, value) {
            if (!param || !value)
                return url;
            param = encodeURIComponent(param);
            value = encodeURIComponent(value);
            var urlparts = url.split('?');
            if (urlparts.length < 2)
                return url + '?' + param + '=' + value;
            var kvp = urlparts[1].split(/[&;]/g);
            var i;
            for (i = kvp.length - 1; i >= 0; i--) {
                var x = kvp[i].split('=');
                if (x[0] === param) {
                    x[1] = value;
                    kvp[i] = x.join('=');
                    break;
                }
            }
            if (i < 0) {
                kvp[kvp.length] = [param, value].join('=');
            }
            return urlparts[0] + '?' + kvp.join('&');
        };
        /**
         * Removes the specified query string name from the URL.
         * @param url The URL to remove the query string value from
         * @param param The query string parameter name.
         * @returns {string} The updated URL.
         */
        Utils.RemoveQSParm = function (url, param) {
            var urlparts = url.split('?');
            if (urlparts.length < 2)
                return url;
            var prefix = encodeURIComponent(param) + '=';
            var pars = urlparts[1].split(/[&;]/g);
            for (var i = pars.length - 1; i >= 0; i--)
                if (pars[i].lastIndexOf(prefix, 0) !== -1)
                    pars.splice(i, 1);
            if (pars.length > 0)
                return urlparts[0] + '?' + pars.join('&');
            else
                return urlparts[0];
        };
        /**
         * Disposes the Microsoft Ajax Library component having the specified ID. Used to clean up resources when Silverlight
         * media assets are rendered on the page. No action is taken if no current component is active or if ID is null or an empty string.
         * @param id The ID of the Microsoft Ajax Library component
         */
        Utils.DisposeAjaxComponent = function (id) {
            if (typeof Sys === 'undefined' || typeof Sys.Application === 'undefined')
                return;
            if (id && id.length > 0) {
                var obj = Sys.Application.findComponent(id);
                if (obj)
                    obj.dispose();
            }
        };
        /**
         * Highlight the text in the element. Use this to select text in contentEditable elements such as those used in tinyMCE.
         * Inspired from http://stackoverflow.com/questions/6139107/
         */
        Utils.selectElementContents = function (el) {
            // A stackoverflow user suggested wrapping the commands in a requestAnimationFrame callback for "extra compatibility". Not 
            // sure exactly what this means and did not thoroughly test not using it.
            var selectContents = function () {
                var range = document.createRange();
                range.selectNodeContents(el);
                var sel = window.getSelection();
                sel.removeAllRanges();
                sel.addRange(range);
            };
            if (typeof requestAnimationFrame !== 'undefined') {
                requestAnimationFrame(function () { return selectContents(); });
            }
            else {
                // We'll get here for IE9 and lower. http://caniuse.com/#search=requestAnimationFrame
                selectContents();
            }
        };
        /**
        * Generate a 32-character pseudo-GUID.
        * @returns {String} Returns a pseudo-GUID.
        */
        Utils.createPseudoGuid = function () {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
                var r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        };
        /**
         * Parse a user-friendly message from the JQueryXHR instance. If it contains a responseJSON property, then use that;
         * otherwise use the responseText property.
         * @param jqXHR The JQueryXHR instance
         * @returns {String} Returns a user-friendly message.
         */
        Utils.parseJqXhrMsg = function (jqXHR) {
            return (jqXHR.responseJSON && jqXHR.responseJSON.Message && jqXHR.responseJSON.MessageDetail ? jqXHR.responseJSON.Message + ' ' + jqXHR.responseJSON.MessageDetail : jqXHR.responseText);
        };
        return Utils;
    }());
    Gs.Utils = Utils;
    //#region Class / Interface / Enum / Constants definitions
    var Constants;
    (function (Constants) {
        Constants.IntMinValue = -2147483648;
        Constants.IntMaxValue = 2147483647;
    })(Constants = Gs.Constants || (Gs.Constants = {}));
    var Enums;
    (function (Enums) {
        /**
        * Specifies the size of a display object. This is the client-side version of the DisplayObjectType enumeration defined on the server.
        * @enum ViewSize
        */
        var ViewSize;
        (function (ViewSize) {
            /**
            * Gets the Unknown view size.
            */
            ViewSize[ViewSize["Unknown"] = 0] = "Unknown";
            /**
            * Gets the Thumbnail view size.
            */
            ViewSize[ViewSize["Thumbnail"] = 1] = "Thumbnail";
            /**
            * Gets the Optimized view size.
            */
            ViewSize[ViewSize["Optimized"] = 2] = "Optimized";
            /**
            * Gets the Original view size.
            */
            ViewSize[ViewSize["Original"] = 3] = "Original";
            /**
            * Gets the External view size.
            */
            ViewSize[ViewSize["External"] = 4] = "External";
        })(ViewSize = Enums.ViewSize || (Enums.ViewSize = {}));
        ;
        /**
        * Specifies the category to which this mime type belongs. This usually corresponds to the first portion of the full mime type description.
        * (e.g. "image" if the full mime type is "image/jpeg") The one exception to this is the "Other" enumeration, which represents any category
        * not represented by the others. This is the client-side version of the MimeTypeCategory enumeration defined on the server.
        * @enum MimeType
        */
        var MimeType;
        (function (MimeType) {
            /**
            * Gets the NotSet mime type name, which indicates that no assignment has been made.
            */
            MimeType[MimeType["NotSet"] = 0] = "NotSet";
            /**
            * Gets the Other mime type name.
            */
            MimeType[MimeType["Other"] = 1] = "Other";
            /**
            * Gets the Image mime type name.
            */
            MimeType[MimeType["Image"] = 2] = "Image";
            /**
            * Gets the Video mime type name.
            */
            MimeType[MimeType["Video"] = 3] = "Video";
            /**
            * Gets the Audio mime type name.
            */
            MimeType[MimeType["Audio"] = 4] = "Audio";
        })(MimeType = Enums.MimeType || (Enums.MimeType = {}));
        ;
        /**
        * Specifies the type of the gallery object. This is the client-side version of the GalleryObjectType enumeration defined on the server.
        * Note that some of the enumeration values that exist on the server are not present here because they would be complex to implement and
        * are not needed at this time.
        * @enum ItemType
        */
        var ItemType;
        (function (ItemType) {
            /**
            * Specifies that no gallery object type has been assigned.
            */
            ItemType[ItemType["NotSpecified"] = 0] = "NotSpecified";
            /**
            * Gets the Album gallery object type.
            */
            ItemType[ItemType["Album"] = 3] = "Album";
            /**
            * Gets the Image gallery object type.
            */
            ItemType[ItemType["Image"] = 4] = "Image";
            /**
            * Gets the Audio gallery object type.
            */
            ItemType[ItemType["Audio"] = 5] = "Audio";
            /**
            * Gets the Video gallery object type.
            */
            ItemType[ItemType["Video"] = 6] = "Video";
            /**
            * Gets the Generic gallery object type.
            */
            ItemType[ItemType["Generic"] = 7] = "Generic";
            /**
            * Gets the External gallery object type.
            */
            ItemType[ItemType["External"] = 8] = "External";
        })(ItemType = Enums.ItemType || (Enums.ItemType = {}));
        ;
        /**
        * Specifies whether an item is editable and, if so, the type of editor to use.
        * @enum PropertyEditorMode
        */
        var PropertyEditorMode;
        (function (PropertyEditorMode) {
            /**
            * Indicates no property editor mode has been specified
            */
            PropertyEditorMode[PropertyEditorMode["NotSet"] = 0] = "NotSet";
            /**
            * Indicates that a property is not editable by users.
            */
            PropertyEditorMode[PropertyEditorMode["NotEditable"] = 3] = "NotEditable";
            /**
            * Indicates that a plain text editor is to be used for property editing.
            */
            PropertyEditorMode[PropertyEditorMode["PlainTextEditor"] = 2] = "PlainTextEditor";
            /**
            * Indicates that the tinyMCE HTML editor is to be used for property editing.
            */
            PropertyEditorMode[PropertyEditorMode["TinyMCEHtmlEditor"] = 3] = "TinyMCEHtmlEditor";
        })(PropertyEditorMode = Enums.PropertyEditorMode || (Enums.PropertyEditorMode = {}));
        ;
        /**
        * Specifies one or more security-related actions within Gallery Server. A user may or may not have authorization to
        * perform each security action. A user's authorization is determined by the role or roles to which he or she belongs.
        * Note that some of the enumeration values that exist on the server are not present here.
        * This is the client-side version of the SecurityActions enumeration defined on the server.
        * @enum SecurityActions
        */
        var SecurityActions;
        (function (SecurityActions) {
            /**
            * Represents the ability to create a new album within the current album. This includes the ability to move or
            * copy an album into the current album.
            */
            SecurityActions[SecurityActions["AddChildAlbum"] = 2] = "AddChildAlbum";
            /**
            * Represents the ability to add a new media object to the current album. This includes the ability to move or
            * copy a media object into the current album.
            */
            SecurityActions[SecurityActions["AddMediaObject"] = 4] = "AddMediaObject";
            /**
            * Represents the ability to edit an album's title, summary, and begin and end dates. Also includes rearranging the
            * order of objects within the album and assigning the album's thumbnail image. Does not include the ability to
            * add or delete child albums or media objects.
            */
            SecurityActions[SecurityActions["EditAlbum"] = 8] = "EditAlbum";
        })(SecurityActions = Enums.SecurityActions || (Enums.SecurityActions = {}));
        ;
        /**
        * Identifies the type of virtual album. Note that some of the enumeration values that exist on the server are not present here.
        * This is the client-side version of the VirtualAlbumType enumeration defined on the server.
        * @enum SecurityActions
        */
        var VirtualAlbumType;
        (function (VirtualAlbumType) {
            /**
            * Specifies that the album is not a virtual album.
            */
            VirtualAlbumType[VirtualAlbumType["NotVirtual"] = 1] = "NotVirtual";
        })(VirtualAlbumType = Enums.VirtualAlbumType || (Enums.VirtualAlbumType = {}));
        ;
        /**
        * Specifies the type of the slide show. . This is the client-side version of the SlideShowType enumeration defined on the server.
        * @enum SlideShowType
        */
        var SlideShowType;
        (function (SlideShowType) {
            /**
            * Specifies that no slide show type has been assigned.
            */
            SlideShowType[SlideShowType["NotSet"] = 0] = "NotSet";
            /**
            * Gets the Inline slide show type.
            */
            SlideShowType[SlideShowType["Inline"] = 1] = "Inline";
            /**
            * Gets the FullScreen slide show type.
            */
            SlideShowType[SlideShowType["FullScreen"] = 2] = "FullScreen";
        })(SlideShowType = Enums.SlideShowType || (Enums.SlideShowType = {}));
        ;
        /**
         * Specifies a particular message that is to be displayed to the user. The text of the message is extracted from the resource file.
         * This is useful when redirecting the user to a new page. Include 'msg=11' in the URL, where 11 is the numeric value of the desired message.
         */
        var MessageType;
        (function (MessageType) {
            MessageType[MessageType["None"] = 0] = "None";
            MessageType[MessageType["AlbumSuccessfullyDeleted"] = 11] = "AlbumSuccessfullyDeleted";
        })(MessageType = Enums.MessageType || (Enums.MessageType = {}));
        /**
         * Specifies the type of meta item (e.g. title, caption, etc). Maps to the MetadataItemName enumeration on the server.
         */
        var MetaType;
        (function (MetaType) {
            MetaType[MetaType["NotSet"] = 0] = "NotSet";
            MetaType[MetaType["Title"] = 29] = "Title";
            MetaType[MetaType["Caption"] = 41] = "Caption";
            MetaType[MetaType["HtmlSource"] = 112] = "HtmlSource";
        })(MetaType = Enums.MetaType || (Enums.MetaType = {}));
        /**
         * Specifies a keyboard character. Can be used to compare with an event's keyCode property to see which key a user pressed.
         */
        var KeyCode;
        (function (KeyCode) {
            KeyCode[KeyCode["NotSet"] = 0] = "NotSet";
            KeyCode[KeyCode["Enter"] = 13] = "Enter";
            KeyCode[KeyCode["Escape"] = 27] = "Escape";
            KeyCode[KeyCode["CursorLeft"] = 37] = "CursorLeft";
            KeyCode[KeyCode["CursorRight"] = 39] = "CursorRight";
        })(KeyCode = Enums.KeyCode || (Enums.KeyCode = {}));
        /**
         * Identifies the amount to rotate or flip a media asset. Maps to the MediaAssetRotateFlip enumeration on the server.
         */
        var RotateFlip;
        (function (RotateFlip) {
            RotateFlip[RotateFlip["NotSet"] = 0] = "NotSet";
            RotateFlip[RotateFlip["Rotate0FlipNone"] = 1] = "Rotate0FlipNone";
            RotateFlip[RotateFlip["Rotate0FlipX"] = 2] = "Rotate0FlipX";
            RotateFlip[RotateFlip["Rotate0FlipY"] = 3] = "Rotate0FlipY";
            RotateFlip[RotateFlip["Rotate90FlipNone"] = 4] = "Rotate90FlipNone";
            RotateFlip[RotateFlip["Rotate180FlipNone"] = 7] = "Rotate180FlipNone";
            RotateFlip[RotateFlip["Rotate270FlipNone"] = 10] = "Rotate270FlipNone";
        })(RotateFlip = Enums.RotateFlip || (Enums.RotateFlip = {}));
        /**
         * Identifies a specific page. Maps to the PageId enumeration on the server.
         */
        var PageId;
        (function (PageId) {
            PageId[PageId["none"] = 0] = "none";
            PageId[PageId["admin_albums"] = 1] = "admin_albums";
            PageId[PageId["admin_backuprestore"] = 2] = "admin_backuprestore";
            PageId[PageId["admin_css"] = 3] = "admin_css";
            PageId[PageId["admin_eventlog"] = 4] = "admin_eventlog";
            PageId[PageId["admin_galleries"] = 5] = "admin_galleries";
            PageId[PageId["admin_gallerysettings"] = 6] = "admin_gallerysettings";
            PageId[PageId["admin_gallerycontrolsettings"] = 7] = "admin_gallerycontrolsettings";
            PageId[PageId["admin_images"] = 8] = "admin_images";
            PageId[PageId["admin_manageroles"] = 9] = "admin_manageroles";
            PageId[PageId["admin_manageusers"] = 10] = "admin_manageusers";
            PageId[PageId["admin_mediaobjects"] = 11] = "admin_mediaobjects";
            PageId[PageId["admin_metadata"] = 12] = "admin_metadata";
            PageId[PageId["admin_filetypes"] = 13] = "admin_filetypes";
            PageId[PageId["admin_mediatemplates"] = 14] = "admin_mediatemplates";
            PageId[PageId["admin_sitesettings"] = 15] = "admin_sitesettings";
            PageId[PageId["admin_uitemplates"] = 16] = "admin_uitemplates";
            PageId[PageId["admin_usersettings"] = 17] = "admin_usersettings";
            PageId[PageId["admin_videoaudioother"] = 18] = "admin_videoaudioother";
            PageId[PageId["admin_mediaqueue"] = 19] = "admin_mediaqueue";
            PageId[PageId["album"] = 20] = "album";
            PageId[PageId["changepassword"] = 21] = "changepassword";
            PageId[PageId["createaccount"] = 22] = "createaccount";
            PageId[PageId["error_cannotwritetodirectory"] = 23] = "error_cannotwritetodirectory";
            PageId[PageId["error_generic"] = 24] = "error_generic";
            PageId[PageId["login"] = 25] = "login";
            PageId[PageId["mediaobject"] = 26] = "mediaobject";
            PageId[PageId["myaccount"] = 27] = "myaccount";
            PageId[PageId["recoverpassword"] = 28] = "recoverpassword";
            PageId[PageId["task_addobjects"] = 29] = "task_addobjects";
            PageId[PageId["task_synchronize"] = 30] = "task_synchronize";
        })(PageId = Enums.PageId || (Enums.PageId = {}));
    })(Enums = Gs.Enums || (Gs.Enums = {}));
    /**
    * A client-optimized object that stores application-level properties for the gallery.
    * @class Permissions
    */
    var App = /** @class */ (function () {
        function App() {
        }
        return App;
    }());
    Gs.App = App;
    /**
     * A simple object that contains gallery item information. It is essentially a client-optimized version of IGalleryObject.
     * @class GalleryItem
     */
    var GalleryItem = /** @class */ (function () {
        function GalleryItem() {
        }
        return GalleryItem;
    }());
    Gs.GalleryItem = GalleryItem;
    /**
     * A client-optimized object that contains information about a particular view of a media object.
     * @class DisplayObject
     */
    var DisplayObject = /** @class */ (function () {
        function DisplayObject() {
        }
        return DisplayObject;
    }());
    Gs.DisplayObject = DisplayObject;
    /**
     * A client-optimized object that stores a piece of information describing a gallery object.
     * @class MetaItem
     */
    var MetaItem = /** @class */ (function () {
        function MetaItem(mTypeId) {
            this.Id = 0;
            this.MediaId = 0;
            this.MTypeId = mTypeId;
            this.GTypeId = 0;
            this.Desc = '';
            this.Value = '';
            //this.IsEditable = false;
            this.EditMode = Enums.PropertyEditorMode.NotSet;
        }
        return MetaItem;
    }());
    Gs.MetaItem = MetaItem;
    /**
     * A data object that contains permissions relevant to the current user.
     * @class Permissions
     */
    var Permissions = /** @class */ (function () {
        function Permissions() {
        }
        return Permissions;
    }());
    Gs.Permissions = Permissions;
    /**
     * A simple object that contains album information. This class is used to pass information between the browser and the web server via AJAX callbacks.
     * @class Album
     */
    var Album = /** @class */ (function () {
        function Album() {
        }
        return Album;
    }());
    Gs.Album = Album;
    /**
     * A client-optimized object that contains media object information.
     * @class MediaItem
     */
    var MediaItem = /** @class */ (function () {
        function MediaItem() {
        }
        return MediaItem;
    }());
    Gs.MediaItem = MediaItem;
    /**
     * A client-optimized object that contains language resources.
     * @class Resource
     */
    var Resource = /** @class */ (function () {
        function Resource() {
        }
        return Resource;
    }());
    Gs.Resource = Resource;
    /**
     * A client-optimized object that stores properties that affect the user experience.
     * @class Settings
     */
    var Settings = /** @class */ (function () {
        function Settings() {
        }
        return Settings;
    }());
    Gs.Settings = Settings;
    /**
     * A client-optimized object containing information about the current user.
     * @class User
     */
    var User = /** @class */ (function () {
        function User() {
        }
        return User;
    }());
    Gs.User = User;
    /**
     * A client-optimized object that contains gallery data.
     * @class GalleryData
     */
    var GalleryData = /** @class */ (function () {
        function GalleryData() {
        }
        return GalleryData;
    }());
    Gs.GalleryData = GalleryData;
    /**
     * A data object containing information about the result of an action. Maps to the ActionResult class on the server.
     * @class ActionResult
     */
    var ActionResult = /** @class */ (function () {
        function ActionResult() {
        }
        return ActionResult;
    }());
    Gs.ActionResult = ActionResult;
    /**
     * A client-optimized object that wraps a meta item and the gallery items it applies to.
     * @class GalleryItemMeta
     */
    var GalleryItemMeta = /** @class */ (function () {
        function GalleryItemMeta() {
        }
        return GalleryItemMeta;
    }());
    Gs.GalleryItemMeta = GalleryItemMeta;
    //#endregion Class / Interface / Enum / Constants definitions
    //#region tinyMCE plugins
    // Add placeholder functionality for tinyMCE editor. Inspired from https://github.com/mohan999/tinymce-placeholder
    // Tested only for inline mode
    if (typeof tinyMCE !== 'undefined') {
        tinyMCE.PluginManager.add('placeholder', function (editor) {
            editor.on('init', function () {
                var tinyMcePh = new TinyMcePlaceholder(editor); // editor is instance of tinymce.Editor: https://www.tinymce.com/docs/api/class/tinymce.editor/
                onBlur();
                tinyMCE.DOM.bind(tinyMcePh.placeholderElement, 'click', function (e) {
                    // User clicks on placeholder
                    tinyMcePh.hide();
                    $(e.target).prevAll('.mce-content-body').focus();
                });
                editor.on('focus', function () {
                    tinyMcePh.hide();
                });
                editor.on('blur', onBlur);
                function onBlur() {
                    if (editor.getContent() === '') {
                        tinyMcePh.show();
                    }
                    else {
                        tinyMcePh.hide();
                    }
                }
            });
            var TinyMcePlaceholder = /** @class */ (function () {
                function TinyMcePlaceholder(editor) {
                    // The placeholder text comes from the first of these locations: (1) placedholder attribute of the tinyMCE element 
                    // (2) placeholder_text setting in tinyMCE.init() (3) hard-coded text 'Add...'
                    this.placeholderText = editor.getElement().getAttribute('placeholder') || editor.settings.placeholder_text || 'Add...';
                    // Get the parent of our tinyMCE element. This plugin requires the parent to have a top left position at the same place as the element.
                    this.placeholderParent = $(editor.getElement()).parent()[0];
                    tinyMCE.DOM.setStyle(this.placeholderParent, 'position', 'relative');
                    var attrs = { 'class': 'gs_meta_placeholder' }; // Class should have style similar to: position: absolute; top: 0; left: 0; color: #888; padding: 3px; width: 100%; overflow:hidden;border: 1px solid transparent;
                    this.placeholderElement = tinyMCE.DOM.add(this.placeholderParent, 'label', attrs, this.placeholderText);
                }
                TinyMcePlaceholder.prototype.show = function () {
                    tinyMCE.DOM.setStyle(this.placeholderElement, 'display', '');
                };
                TinyMcePlaceholder.prototype.hide = function () {
                    tinyMCE.DOM.setStyle(this.placeholderElement, 'display', 'none');
                };
                return TinyMcePlaceholder;
            }());
        });
    }
    //#endregion
    $(document).ready(Utils.Init);
    //#endregion End Gallery-wide functions
    //#region AJAX functions
    var DataService = /** @class */ (function () {
        function DataService() {
        }
        DataService.logOff = function (callback) {
            $.post(Vars.AppRoot + '/api/task/logoff', function (data) {
                callback(data);
            });
        };
        DataService.getGalleryItems = function (albumId, alwaysCallback, doneCallback, failCallback) {
            $.ajax({
                type: 'GET',
                url: Vars.AppRoot + '/api/albums/' + albumId + '/galleryitems',
                dataType: 'json'
            })
                .done(doneCallback)
                .always(alwaysCallback)
                .fail(failCallback);
        };
        DataService.deleteGalleryItems = function (galleryItems, deleteFromFileSystem, alwaysCallback, doneCallback, failCallback) {
            $.ajax({
                type: 'DELETE',
                url: Vars.AppRoot + '/api/galleryitems/delete?deleteFromFileSystem=' + deleteFromFileSystem,
                data: JSON.stringify(galleryItems),
                contentType: 'application/json; charset=utf-8',
                dataType: 'json'
            })
                .done(doneCallback)
                .always(alwaysCallback)
                .fail(failCallback);
        };
        DataService.deleteOriginalFiles = function (galleryItems, alwaysCallback, doneCallback, failCallback) {
            $.ajax({
                type: 'DELETE',
                url: Vars.AppRoot + '/api/galleryitems/deleteoriginalfiles',
                data: JSON.stringify(galleryItems),
                contentType: 'application/json; charset=utf-8',
                dataType: 'json'
            })
                .done(doneCallback)
                .always(alwaysCallback)
                .fail(failCallback);
        };
        DataService.getMediaAsset = function (mediaAssetId, alwaysCallback, doneCallback, failCallback) {
            $.ajax({
                type: 'GET',
                url: Vars.AppRoot + '/api/mediaitems/' + mediaAssetId + '/get'
            })
                .done(doneCallback)
                .always(alwaysCallback)
                .fail(failCallback);
        };
        /**
         * Delete the specified media asset. NOTE: This function is not currently used in Gallery Server.
         */
        DataService.deleteMediaAsset = function (mediaAssetId, alwaysCallback, doneCallback, failCallback) {
            $.ajax({
                type: 'DELETE',
                url: Vars.AppRoot + '/api/mediaitems/' + mediaAssetId
            })
                .done(doneCallback)
                .always(alwaysCallback)
                .fail(failCallback);
        };
        DataService.prepareZipDownload = function (galleryItems, viewSize, alwaysCallback, doneCallback, failCallback) {
            $.ajax({
                type: 'POST',
                url: Vars.AppRoot + '/api/mediaitems/preparezipdownload?mediaSize=' + viewSize,
                data: JSON.stringify(galleryItems),
                contentType: 'application/json; charset=utf-8',
                dataType: 'json'
            })
                .done(doneCallback)
                .always(alwaysCallback)
                .fail(failCallback);
        };
        /**
         * Create a new album on the server. The only properties of the album parameter that are used are Title and ParentId.
         * Optional: If GalleryId is specified and an error occurs, it is used to help with error logging.
         */
        DataService.createAlbum = function (album, alwaysCallback, doneCallback, failCallback) {
            $.ajax({
                type: 'PUT',
                url: Vars.AppRoot + '/api/albums/createalbum',
                data: JSON.stringify(album),
                contentType: 'application/json; charset=utf-8',
                dataType: 'json'
            })
                .done(doneCallback)
                .always(alwaysCallback)
                .fail(failCallback);
        };
        DataService.sortAlbum = function (album, persistToAlbum, alwaysCallback, doneCallback, failCallback) {
            $.ajax({
                type: 'POST',
                url: Vars.AppRoot + "/api/albums/sortalbum?persistToAlbum=" + persistToAlbum,
                data: JSON.stringify(album),
                contentType: 'application/json; charset=utf-8',
                dataType: 'json'
            })
                .done(doneCallback)
                .always(alwaysCallback)
                .fail(failCallback);
        };
        DataService.changeAlbumOwner = function (albumId, ownerName, alwaysCallback, doneCallback, failCallback) {
            $.ajax({
                type: 'POST',
                url: Vars.AppRoot + "/api/albums/changealbumowner?albumId=" + albumId + "&ownerName=" + ownerName,
                dataType: 'json'
            })
                .done(doneCallback)
                .always(alwaysCallback)
                .fail(failCallback);
        };
        DataService.saveAlbum = function (album, alwaysCallback, doneCallback, failCallback) {
            var a = Utils.deepCopy(album);
            a.MediaItems = null;
            a.GalleryItems = null;
            a.MetaItems = null;
            a.Permissions = null;
            $.ajax({
                type: 'POST',
                url: Vars.AppRoot + '/api/albums/post',
                data: JSON.stringify(a),
                contentType: 'application/json; charset=utf-8'
            })
                .done(doneCallback)
                .always(alwaysCallback)
                .fail(failCallback);
        };
        DataService.moveTo = function (destinationAlbumId, galleryItemsToMove, alwaysCallback, doneCallback, failCallback) {
            $.ajax({
                type: 'POST',
                url: Vars.AppRoot + '/api/albums/movetoalbum?destinationAlbumId=' + destinationAlbumId,
                data: JSON.stringify(galleryItemsToMove),
                contentType: 'application/json; charset=utf-8',
                dataType: 'json'
            })
                .done(doneCallback)
                .always(alwaysCallback)
                .fail(failCallback);
        };
        DataService.copyTo = function (destinationAlbumId, galleryItemsToCopy, alwaysCallback, doneCallback, failCallback) {
            $.ajax({
                type: 'POST',
                url: Vars.AppRoot + '/api/albums/copytoalbum?destinationAlbumId=' + destinationAlbumId,
                data: JSON.stringify(galleryItemsToCopy),
                contentType: 'application/json; charset=utf-8'
            })
                .done(doneCallback)
                .always(alwaysCallback)
                .fail(failCallback);
        };
        /**
         * Sort the galleryItems in the order in which they are passed. This method is used when a user is manually sorting an album
         * and has dragged an item to a new position.
         */
        DataService.sortGalleryItems = function (galleryItems, alwaysCallback, doneCallback, failCallback) {
            $.ajax({
                type: 'POST',
                url: Vars.AppRoot + '/api/albums/sortgalleryobjects',
                data: JSON.stringify(galleryItems),
                contentType: 'application/json; charset=utf-8'
            })
                .done(doneCallback)
                .always(alwaysCallback)
                .fail(failCallback);
        };
        DataService.saveMeta = function (galleryItemMeta, alwaysCallback, doneCallback, failCallback) {
            $.ajax({
                type: 'PUT',
                url: Vars.AppRoot + '/api/galleryitemmeta',
                data: JSON.stringify(galleryItemMeta),
                contentType: 'application/json; charset=utf-8',
                dataType: 'json'
            })
                .done(doneCallback)
                .always(alwaysCallback)
                .fail(failCallback);
        };
        DataService.deleteMeta = function (galleryItemMeta, alwaysCallback, doneCallback, failCallback) {
            $.ajax({
                type: 'DELETE',
                url: Vars.AppRoot + '/api/galleryitemmeta',
                data: JSON.stringify(galleryItemMeta),
                contentType: 'application/json; charset=utf-8'
            })
                .done(doneCallback)
                .always(alwaysCallback)
                .fail(failCallback);
        };
        DataService.canUserEdit = function (galleryItems, alwaysCallback, doneCallback, failCallback) {
            $.ajax({
                type: 'POST',
                url: Vars.AppRoot + '/api/galleryitemmeta/canuseredit',
                data: JSON.stringify(galleryItems),
                contentType: 'application/json; charset=utf-8'
            })
                .done(doneCallback)
                .always(alwaysCallback)
                .fail(failCallback);
        };
        /**
         * Get the meta items for the specified gallery items. Server returns an array of MetaItem instances.
         */
        DataService.getMeta = function (galleryItems, alwaysCallback, doneCallback, failCallback) {
            $.ajax({
                type: 'POST',
                url: Vars.AppRoot + '/api/galleryitemmeta/galleryitems',
                data: JSON.stringify(galleryItems),
                contentType: 'application/json; charset=utf-8',
                dataType: 'json'
            })
                .done(doneCallback)
                .always(alwaysCallback)
                .fail(failCallback);
        };
        DataService.assignThumbnail = function (galleryItem, albumId, alwaysCallback, doneCallback, failCallback) {
            $.ajax({
                type: 'POST',
                url: Vars.AppRoot + '/api/albums/assignThumbnail?albumId=' + albumId,
                data: JSON.stringify(galleryItem),
                contentType: 'application/json; charset=utf-8',
                dataType: 'json'
            })
                .done(doneCallback)
                .always(alwaysCallback)
                .fail(failCallback);
        };
        DataService.cancelMediaQueueItem = function (mediaQueueId, alwaysCallback, doneCallback, failCallback) {
            $.ajax({
                type: 'POST',
                url: Vars.AppRoot + '/api/mediaqueueitem/cancel/?mediaQueueId=' + mediaQueueId
            })
                .done(doneCallback)
                .always(alwaysCallback)
                .fail(failCallback);
        };
        DataService.saveCurrentUserProfile = function (user, alwaysCallback, doneCallback, failCallback) {
            $.ajax({
                type: 'POST',
                url: Vars.AppRoot + '/api/users/currentuserprofile',
                data: JSON.stringify(user),
                contentType: 'application/json; charset=utf-8'
            })
                .done(doneCallback)
                .always(alwaysCallback)
                .fail(failCallback);
        };
        DataService.clearUserProfile = function (userName, alwaysCallback, doneCallback, failCallback) {
            $.ajax({
                type: 'POST',
                url: Vars.AppRoot + '/api/users/clearuserprofile?userName=' + userName,
                contentType: 'application/json; charset=utf-8'
            })
                .done(doneCallback)
                .always(alwaysCallback)
                .fail(failCallback);
        };
        /**
         * Purge the entire cache on the server. User must be a site administrator.
         * NOTE: This function is not currently used in Gallery Server.
         */
        DataService.purgeCache = function (alwaysCallback, doneCallback, failCallback) {
            $.ajax({
                url: Vars.AppRoot + '/api/task/purgecache'
            })
                .done(doneCallback)
                .always(alwaysCallback)
                .fail(failCallback);
        };
        DataService.calculateOriginalFileSize = function (galleryItem, alwaysCallback, doneCallback, failCallback) {
            $.ajax({
                type: 'POST',
                url: Vars.AppRoot + '/api/albums/calculateoriginalfilesize',
                data: JSON.stringify(galleryItem),
                contentType: 'application/json; charset=utf-8',
                dataType: 'json'
            })
                .done(doneCallback)
                .always(alwaysCallback)
                .fail(failCallback);
        };
        DataService.replaceWithEditedImage = function (mediaAssetId, fileNameOnServer, alwaysCallback, doneCallback, failCallback) {
            $.ajax({
                type: 'POST',
                url: Vars.AppRoot + '/api/mediaitems/replacewitheditedimage?mediaAssetId=' + mediaAssetId + '&fileNameOnServer=' + encodeURIComponent(fileNameOnServer),
                dataType: 'json'
            })
                .done(doneCallback)
                .always(alwaysCallback)
                .fail(failCallback);
        };
        DataService.replaceMediaAssetFile = function (mediaAssetId, fileNameOnServer, fileName, alwaysCallback, doneCallback, failCallback) {
            $.ajax({
                type: 'POST',
                url: Vars.AppRoot + "/api/mediaitems/replacemediaassetfile?mediaAssetId=" + mediaAssetId + "&fileNameOnServer=" + encodeURIComponent(fileNameOnServer) + "&fileName=" + encodeURIComponent(fileName),
                dataType: 'json'
            })
                .done(doneCallback)
                .always(alwaysCallback)
                .fail(failCallback);
        };
        DataService.rotateFlipMediaAsset = function (galleryItems, rotateFlip, viewSize, alwaysCallback, doneCallback, failCallback) {
            $.ajax({
                type: 'POST',
                url: Vars.AppRoot + '/api/galleryitems/rotateflip?rotateFlip=' + rotateFlip + '&viewSize=' + viewSize,
                data: JSON.stringify(galleryItems),
                contentType: 'application/json; charset=utf-8',
                dataType: 'json'
            })
                .done(doneCallback)
                .always(alwaysCallback)
                .fail(failCallback);
        };
        /**
         * Invoke a GET request to the specified url and parse the response as JSON.
         */
        DataService.getAsJson = function (url, data, alwaysCallback, doneCallback, failCallback) {
            $.ajax({
                type: 'GET',
                url: url,
                data: data,
                dataType: 'json'
            })
                .done(doneCallback)
                .always(alwaysCallback)
                .fail(failCallback);
        };
        return DataService;
    }());
    Gs.DataService = DataService;
    //#endregion
    //#region gsTagCloud plug-in
    $.fn.gsTagCloud = function (data, options) {
        var _this = this;
        var settings = $.extend({}, $.fn.gsTagCloud.defaults, options);
        var getTagDataAndRender = function () {
            DataService.getAsJson(options.tagCloudUrl, null, function () {
                _this.removeClass('gsp_wait');
            }, function (tags) {
                var tc = new GsTagCloud(_this, tags, settings);
                tc.render();
            }, function (jqXHR) {
                Msg.show('Cannot Retrieve Tag Cloud Data', Utils.parseJqXhrMsg(jqXHR), { msgType: 'error', autoCloseDelay: 0 });
            });
        };
        if (data == null) {
            getTagDataAndRender();
        }
        else {
            var gspTc = new GsTagCloud(this, data, settings);
            gspTc.render();
        }
        return this;
    };
    $.fn.gsTagCloud.defaults = {
        clientId: '',
        tagCloudType: 'tag',
        tagCloudUrl: '',
        shape: 'rectangular' // Shape of cloud. Set to false to get the elliptic shape (the default shape of JQCloud)
    };
    var GsTagCloud = /** @class */ (function () {
        function GsTagCloud(target, data, options) {
            this.$target = target; // A jQuery object to receive the tag cloud.
            this.TagCloudOptions = options;
            this.Data = data;
        }
        GsTagCloud.prototype.render = function () {
            var _this = this;
            var parms = { title: null, tag: null, people: null, search: null, latest: null, filter: null, rating: null, top: null, aid: null, moid: null };
            var pageUrl = window.location.href;
            var jqcloudData = $.map(this.Data, function (tag) {
                parms[_this.TagCloudOptions.tagCloudType] = tag.value;
                return { text: tag.value, weight: tag.count, link: Utils.GetUrl(pageUrl, parms) };
            });
            this.$target.jQCloud(jqcloudData, {
                encodeURI: false,
                shape: this.TagCloudOptions.shape
            });
        };
        return GsTagCloud;
    }());
    //#endregion
    //#region gsTreeView plug-in
    $.fn.gsTreeView = function (data, options) {
        var _this = this;
        var settings = $.extend({}, $.fn.gsTreeView.defaults, options);
        var getTreeDataAndRender = function () {
            var ajaxData = {
                // Query string parms to be added to the AJAX request
                id: settings.albumId,
                gid: settings.galleryId,
                secaction: settings.requiredSecurityPermissions,
                sc: settings.enableCheckboxPlugin,
                navurl: settings.navigateUrl,
                levels: settings.numberOfLevels,
                includealbum: settings.includeAlbum,
                idtoselect: settings.albumIdsToSelect
            };
            DataService.getAsJson(settings.treeDataUrl, ajaxData, function () {
                // Always callback
                _this.removeClass('gsp_wait');
            }, function (treeJson) {
                // Success callback
                var treeData = (typeof (treeJson) === 'string' ? JSON.parse(treeJson) : treeJson);
                var tv = new GsTreeView(_this, treeData, settings);
                tv.render();
            }, function (jqXHR) {
                Msg.show('Cannot Retrieve Tag Cloud Data', Utils.parseJqXhrMsg(jqXHR), { msgType: 'error', autoCloseDelay: 0 });
            });
        };
        if (data == null) {
            getTreeDataAndRender();
        }
        else {
            var gspTv = new GsTreeView(this, data, settings);
            gspTv.render();
        }
        return this;
    };
    $.fn.gsTreeView.defaults = {
        albumId: 0,
        galleryId: 0,
        containerClientId: '',
        allowMultiSelect: false,
        numberOfLevels: 1,
        albumIdsToSelect: null,
        checkedAlbumIdsHiddenFieldClientId: '',
        theme: 'gsp',
        requiredSecurityPermissions: 1,
        navigateUrl: '',
        enableCheckboxPlugin: false,
        includeAlbum: true,
        treeDataUrl: '' // The URL for retrieving tree data. Ignored when tree data is passed via data parameter
    };
    var GsTreeView = /** @class */ (function () {
        function GsTreeView(target, data, options) {
            this.$target = target; // A jQuery object to receive the rendered treeview.
            this.TreeViewOptions = options;
            this.Data = data;
        }
        GsTreeView.prototype.render = function () {
            var _this = this;
            this.updateNodeDataWithAlbumIdsToSelect();
            var jstreeOptions = {
                core: {
                    worker: false,
                    check_callback: true,
                    data: function (node, cb) {
                        if (node.id === '#') {
                            return cb(_this.Data);
                        }
                        var url = Vars.GalleryResourcesRoot + '/handler/gettreeview.ashx';
                        var ajaxData = {
                            // Query string parms to be added to the AJAX request
                            id: node.li_attr['data-id'],
                            //gid: self.TreeViewOptions.galleryId,
                            secaction: _this.TreeViewOptions.requiredSecurityPermissions,
                            sc: _this.TreeViewOptions.enableCheckboxPlugin,
                            navurl: _this.TreeViewOptions.navigateUrl,
                            levels: 1,
                            includealbum: false
                        };
                        DataService.getAsJson(url, ajaxData, null, function (treeData) {
                            cb(treeData);
                        }, function (jqXHR) {
                            Msg.show('Cannot Retrieve Tree Data', Utils.parseJqXhrMsg(jqXHR), { msgType: 'error', autoCloseDelay: 0 });
                        });
                        return null;
                    },
                    multiple: this.TreeViewOptions.allowMultiSelect,
                    themes: {
                        name: this.TreeViewOptions.theme,
                        dots: false,
                        icons: false,
                        responsive: false
                    },
                    error: function () {
                        var msg = 'An error occurred in jsTree.';
                        var err = _this.$target.jstree(true).last_error();
                        if (err && err.reason && err.error && err.id && err.plugin && err.data) {
                            msg = msg + " " + err.reason + " Error: " + err.error + "; ID: " + err.id + "; Plugin: " + err.plugin + "; Data: " + err.data;
                        }
                        Msg.show('jsTree Error', msg, { msgType: 'error', autoCloseDelay: 0 });
                    }
                }
            };
            if (this.TreeViewOptions.enableCheckboxPlugin) {
                jstreeOptions.plugins = ['checkbox'];
                jstreeOptions.checkbox = {
                    keep_selected_style: false,
                    three_state: this.TreeViewOptions.allowMultiSelect,
                    visible: true,
                    whole_node: true,
                    cascade: '',
                    tie_selection: true
                };
            }
            this.$target.jstree(jstreeOptions)
                .on('ready.jstree', function (e, data) {
                _this.onLoaded(e, data);
            })
                .on('changed.jstree', function (e, data) {
                _this.onChangeState(e, data);
            })
                .on('deselect_node.jstree', function (e, data) {
                _this.onDeselectNode(e, data);
            });
        };
        ;
        /**
         * Grab the data-id values from the top selected nodes, concatenate them and store them in a hidden
         * form field. This can later be retrieved by server side code to determine what was selected.
         * @param data Tree data. Not sure what the schema is.
         */
        GsTreeView.prototype.storeSelectedNodesInHiddenFormField = function (data) {
            if (this.TreeViewOptions.checkedAlbumIdsHiddenFieldClientId == null || this.TreeViewOptions.checkedAlbumIdsHiddenFieldClientId.length === 0)
                return;
            var topSelectedNodes = data.instance.get_top_selected(true);
            var albumIds = $.map(topSelectedNodes, function (val, i) { return val.li_attr['data-id']; }).join();
            $("#" + this.TreeViewOptions.checkedAlbumIdsHiddenFieldClientId).val(albumIds);
        };
        ;
        /**
         * Process the this.TreeViewOptions.albumIdsToSelect array - find the matching node in the data and change state.selected to true
         * Note that in many cases the nodes are pre-selected in server side code. This function isn't needed in those cases.
         */
        GsTreeView.prototype.updateNodeDataWithAlbumIdsToSelect = function () {
            var _this = this;
            if (Utils.isNullOrEmpty(this.TreeViewOptions.albumIdsToSelect))
                return;
            var findMatch = function (nodeArray, dataId) {
                // Search nodeArray for a node having data-id=dataId, acting recursively
                if (Utils.isNullOrEmpty(nodeArray))
                    return null;
                var matchingNode = $.grep(nodeArray, function (n) { return (n.li_attr['data-id'] === dataId); })[0] || null;
                if (matchingNode != null)
                    return matchingNode;
                // Didn't find it, so recursively search node data
                $.each(nodeArray, function (idx, n) {
                    matchingNode = findMatch(n.children, dataId);
                    if (matchingNode != null) {
                        return false; // Break out of $.each
                    }
                    else
                        return true;
                });
                return matchingNode;
            };
            $.each(this.TreeViewOptions.albumIdsToSelect, function (idx, id) {
                var node = findMatch(_this.Data, id);
                if (node != null) {
                    node.state.selected = true;
                }
            });
        };
        GsTreeView.prototype.onChangeState = function (e, data) {
            if (data.action === 'select_node') {
                var url = data.instance.get_node(data.node, true).children('a').attr('href');
                if (url != null && url.length > 1) {
                    // Selected node is a hyperlink with an URL, so navigate to it.
                    document.location.href = url;
                    return;
                }
            }
            if (data.action === 'deselect_node' || data.action === 'select_node') {
                this.storeSelectedNodesInHiddenFormField(data);
            }
        };
        GsTreeView.prototype.onDeselectNode = function (e, data) {
            // Don't let user deselect the only selected node when allowMultiSelect=false
            if (!this.TreeViewOptions.allowMultiSelect && data.instance.get_selected().length === 0) {
                data.instance.select_node(data.node);
            }
        };
        GsTreeView.prototype.onLoaded = function (e, data) {
            this.storeSelectedNodesInHiddenFormField(data);
            // Scroll the left pane if necessary so that the selected node is visible
            if (this.TreeViewOptions.containerClientId.length < 1)
                return;
            var selectedIds = data.instance.get_selected();
            if (selectedIds != null && selectedIds.length === 1) {
                var nodeOffsetTop = $("#" + selectedIds[0]).position().top;
                var leftPaneHeight = $("#" + this.TreeViewOptions.containerClientId).height();
                if (nodeOffsetTop > leftPaneHeight) {
                    $("#" + this.TreeViewOptions.containerClientId).animate({ scrollTop: nodeOffsetTop }, 200, 'linear');
                }
            }
        };
        ;
        return GsTreeView;
    }());
    //#endregion gsTreeView plug-in
    //#region gs.gsMedia widget
    $.widget('gs.gsMedia', {
        options: {
            clientId: ''
        },
        _create: function () {
            var gData = Vars[this.options.clientId].gsData;
            this.gspMedia = new GsMedia(this.element, gData, this.options);
            this.gspMedia.initialize();
        },
        showNextMediaObject: function () {
            this.gspMedia.showNextMediaObject();
        },
        startSlideshow: function () {
            this.gspMedia.startSlideshow();
        },
        stopSlideshow: function () {
            this.gspMedia.stopSlideshow();
        },
        render: function () {
            this.gspMedia.render();
        },
        preloadImages: function () {
            this.gspMedia.preloadImages();
        },
        addCursorNavigationHandler: function () {
            this.gspMedia.addCursorNavigationHandler();
        },
        removeCursorNavigationHandler: function () {
            this.gspMedia.removeCursorNavigationHandler();
        }
    });
    var GsMedia = /** @class */ (function () {
        function GsMedia(target, data, options) {
            this.$target = target; // A jQuery object to receive the rendered HTML from the template.
            this.data = data;
            this.gsMediaOptions = options;
            this.timer = null;
        }
        GsMedia.prototype.initialize = function () {
            if (!this.data.MediaItem) {
                Msg.show('Cannot Render Media Object', "<p>Cannot render the media object template. Navigate to a media object and then return to this page.</p><p>You'll know you got it right when you see 'moid' In the URL's query string.</p><p>ERROR: this.Data.MediaItem is null.</p>", { msgType: 'error', autoCloseDelay: 0 });
                return;
            }
            this.jsRenderSetup();
            this.overwriteMediaObject();
            this.attachEvents();
            this.render();
            this.preloadImages();
        };
        GsMedia.prototype.jsRenderSetup = function () {
            var _this = this;
            // Create a few helper functions that can be used in the jsRender template.
            $.views.helpers({
                prevUrl: function () {
                    // Generate the URL to the previous media item.
                    var prvMi = _this.getPreviousMediaObject();
                    return prvMi ? _this.getPermalink(prvMi.Id) : Utils.GetAlbumUrl(_this.data.Album.Id, true);
                },
                nextUrl: function () {
                    // Generate the URL to the next media item.
                    var nxtMi = _this.getNextMediaObject();
                    return nxtMi ? _this.getPermalink(nxtMi.Id) : Utils.GetAlbumUrl(_this.data.Album.Id, true);
                },
                getEmbedCode: function () {
                    var url = Utils.GetUrl(_this.data.App.AppUrl + '/' + _this.data.App.GalleryResourcesPath + '/embed.aspx' + location.search, { aid: null, moid: _this.data.MediaItem.Id });
                    return "<iframe allowtransparency='true' frameborder='0' sandbox='allow-same-origin allow-forms allow-scripts' scrolling='auto' src='" + url + "' style='width:100%;height:100%'></iframe>";
                }
            });
        };
        GsMedia.prototype.render = function () {
            this.setSize();
            this.dataBind();
            this.runMediaObjectScript();
            this.ScaleDownOriginalIfNecessary();
            if (this.data.Settings.SlideShowIsRunning)
                this.startSlideshow();
            if (history.replaceState)
                history.replaceState(null, '', this.getPermalink(this.data.MediaItem.Id));
        };
        /**
         * Reduce the size of the media asset, if necessary, to ensure there are no horizontal scrollbars. Applies only when viewing
         * an original media asset.
         */
        GsMedia.prototype.ScaleDownOriginalIfNecessary = function () {
            if (this.data.Settings.MediaViewSize !== Enums.ViewSize.Original)
                return;
            var $moContainer = $('.gsp_moContainer', this.$target);
            var moContainerWidth = $moContainer.width();
            var mediaSelector = 'img:first-child, video:first-child, object:first-child';
            var $media = $(mediaSelector, $moContainer).first();
            if ($media.length === 0)
                return; // We'll get here for images that can't display in the browser (wmf, psd, etc). No need to go further.
            // We can't measure width when dimensions aren't specified in the HTML, since it's not known until later.
            // 1) Hook into load event and go from there.
            // 2) Use width and height dimension in metadata.
            var moWidth = $media.outerWidth();
            var checkWidth = function ($mediaEl) {
                if (moWidth > moContainerWidth) {
                    // The media asset is too big to fit in the center pane. Set its width to the width of its container.
                    // We have to change box- sizing to border- box to have enough room for the padding/border.
                    $mediaEl.css({ 'box-sizing': 'border-box', 'width': moContainerWidth, 'height': 'auto' });
                }
            };
            if (moWidth > moContainerWidth) {
                checkWidth($media);
            }
            else {
                // The media asset may not yet be loaded and that is why moWidth is small. Check for this and add handler if necessary,
                // but we only check images because there isn't a complete property for the video & object tags.
                if (this.data.MediaItem.ItemType === Enums.ItemType.Image && !$media[0].complete) {
                    $media.load(function () {
                        // We need to get another reference to the media element. If we try to re-use the first one, the CSS doesn't work in Chrome 47.
                        var $mediaEl = $(mediaSelector, $moContainer).first();
                        moContainerWidth = $moContainer.width();
                        moWidth = $mediaEl.outerWidth();
                        checkWidth($mediaEl);
                    });
                }
            }
        };
        GsMedia.prototype.setSize = function () {
            var defaultViewIndex = 0;
            for (var i = 0; i < this.data.MediaItem.Views.length; i++) {
                if (this.data.MediaItem.Views[i].ViewSize === this.data.Settings.MediaViewSize) {
                    this.data.MediaItem.ViewIndex = this.data.ActiveGalleryItems[0].ViewIndex = i; // Get index corresponding to requested size
                    return;
                }
                else if (this.data.MediaItem.Views[i].ViewSize === Enums.ViewSize.Original
                    || this.data.MediaItem.Views[i].ViewSize === Enums.ViewSize.External)
                    defaultViewIndex = i;
            }
            // If we get here, we couldn't find a match for the requested size, so default to showing original or external
            this.data.MediaItem.ViewIndex = this.data.ActiveGalleryItems[0].ViewIndex = defaultViewIndex;
        };
        GsMedia.prototype.startSlideshow = function () {
            var _this = this;
            if (this.data.Settings.SlideShowType === Enums.SlideShowType.FullScreen) {
                this.removeCursorNavigationHandler();
                var ss = new GsFullScreenSlideShow(this.data, {
                    viewSize: this.data.Settings.MediaViewSize,
                    on_exit: function (currentId, autoExited) {
                        _this.data.Settings.SlideShowIsRunning = false;
                        _this.addCursorNavigationHandler();
                        // If slide show auto-exited, we finished the album so navigate to the album view. Otherwise just show the image.
                        if (autoExited) {
                            _this.redirectToAlbum();
                        }
                        else {
                            _this.showMediaObject(currentId);
                        }
                    }
                });
                this.data.Settings.SlideShowIsRunning = ss.startSlideShow();
            }
            else if (this.data.Settings.SlideShowType === Enums.SlideShowType.Inline) {
                if (this.timer && this.timer.isRunning)
                    return true;
                this.data.Settings.SlideShowIsRunning = true;
                if (this.data.MediaItem.ItemType === Enums.ItemType.Image || this.getNextMediaObject() != null) {
                    this.timer = new GsTimer(this.showNextMediaObject, this.data.Settings.SlideShowIntervalMs, this);
                    this.timer.start();
                }
                else {
                    this.data.Settings.SlideShowIsRunning = false;
                    Msg.show(this.data.Resource.MoNoSsHdr, this.data.Resource.MoNoSsBdy, { msgType: 'info' });
                }
            }
            return this.data.Settings.SlideShowIsRunning;
        };
        GsMedia.prototype.stopSlideshow = function () {
            if (this.timer)
                this.timer.stop();
            this.data.Settings.SlideShowIsRunning = false;
        };
        GsMedia.prototype.dataBind = function () {
            Utils.DisposeAjaxComponent(Vars.msAjaxComponentId); // Dispose Silverlight component (if necessary)
            this.$target.html($.render[this.data.Settings.MediaTmplName](this.data)); // Render HTML template and add to page
            this.animateMediaObject(); // Execute transition effect
            this.attachMediaEvents();
            this.makeMetaItemsEditable();
        };
        GsMedia.prototype.makeMetaItemsEditable = function () {
            var _this = this;
            if (!this.data.Album.Permissions.EditMediaObject)
                return;
            var tinyMcePlainTextOptions = {
                selector: "#" + this.data.Settings.MediaClientId + " section[data-editMode=2]",
                menubar: false,
                inline: true,
                skin: this.data.App.Skin,
                plugins: ['placeholder'],
                toolbar: false,
                forced_root_block: false,
                verify_html: false,
                placeholder_text: this.data.Resource.MetaEditPlaceholder,
                setup: function (editor) {
                    var selectedGalleryItemsKey = 'sgi';
                    var currentMetaItemKey = 'cmi';
                    editor.on('init', function (e) {
                        // Navigate to hyperlink if user clicks on one. Without this tinyMCE simply makes the area editable and doesn't send the user to the URL.
                        $(editor.getBody()).on('click', 'a[href]', function (e1) {
                            window.location.href = $(e1.currentTarget).attr('href');
                        });
                    });
                    editor.on('focus', function (e) {
                        var metaItem = Utils.findMetaItemById(_this.data.MediaItem.MetaItems, $(e.target.targetElm).data('id'));
                        _this.$target.data(selectedGalleryItemsKey, _this.data.ActiveGalleryItems);
                        _this.$target.data(currentMetaItemKey, metaItem);
                        if (metaItem.EditMode === Enums.PropertyEditorMode.PlainTextEditor) {
                            // Need to encode any HTML for plain text editing
                            var tinyMceEditor = tinyMCE.get(e.target.id);
                            tinyMceEditor.setContent(Utils.htmlEncode(metaItem.Value));
                        }
                        // Disable left/right arrow navigation so user can use these keys while editing
                        $("#" + _this.data.Settings.MediaClientId).gsMedia('removeCursorNavigationHandler');
                    });
                    editor.on('blur', function (e) {
                        var tinyMceEditor = tinyMCE.get(e.target.id);
                        var $targetElm = $(tinyMceEditor.targetElm);
                        // Persist unsaved changes
                        if (tinyMceEditor.isDirty()) {
                            // Retrieve the selected gallery items. We can't use data.ActiveGalleryItems because it will be different if user made a new selection
                            // (this is because the blur event we're running right now fires after the jQuery UI selected event)
                            var selectedGalleryItems = [Utils.convertMediaItemToGalleryItem(_this.data.MediaItem)];
                            var cachedMetaItem_1 = _this.$target.data(currentMetaItemKey);
                            var editorFormat = (cachedMetaItem_1.EditMode === Enums.PropertyEditorMode.TinyMCEHtmlEditor ? 'html' : 'text');
                            var galleryItemMeta = { GalleryItems: selectedGalleryItems, MetaItem: { MTypeId: cachedMetaItem_1.MTypeId, Value: tinyMceEditor.getContent({ format: editorFormat }) } };
                            var $parentCell_1 = $(e.target.targetElm).addClass('gsp_wait_center');
                            DataService.saveMeta(galleryItemMeta, function () { $parentCell_1.removeClass('gsp_wait_center'); }, function (gim) {
                                // Success callback - Ajax request to save meta property completed. Check for validation and other errors and respond accordingly
                                switch (gim.ActionResult.Status) {
                                    case 'Success':
                                    case 'Info':
                                    case 'Warning':
                                        {
                                            // Update local data objects with new meta value
                                            var metaItem = Utils.findMetaItemById(_this.data.MediaItem.MetaItems, $(e.target.targetElm).data('id'));
                                            if (metaItem != null) {
                                                if (metaItem.MTypeId === Enums.MetaType.Title) {
                                                    _this.data.MediaItem.Title = gim.MetaItem.Value;
                                                }
                                                metaItem.Value = gim.MetaItem.Value;
                                                if (cachedMetaItem_1.EditMode === Enums.PropertyEditorMode.PlainTextEditor) {
                                                    // Editor may have been displaying HTML-encoded text, so now display the un-encoded value
                                                    tinyMCE.get(e.target.id).targetElm.innerHTML = gim.MetaItem.Value;
                                                }
                                                _this.$target.trigger("mediaUpdate." + _this.data.Settings.ClientId, [_this.data.ActiveGalleryItems]);
                                            }
                                            break;
                                        }
                                    case 'Error':
                                        // Revert to previous value and show or hide the placeholder text.
                                        $targetElm.html(cachedMetaItem_1.Value).nextAll('label').toggle(cachedMetaItem_1.Value.length === 0);
                                        break;
                                }
                                if (gim.ActionResult.Status !== 'Success') {
                                    Msg.show(gim.ActionResult.Title, gim.ActionResult.Message, { msgType: gim.ActionResult.Status.toLowerCase(), autoCloseDelay: 0 });
                                }
                            }, function (jqXHR) {
                                // Revert to previous value and show or hide the placeholder text.
                                $targetElm.html(cachedMetaItem_1.Value).nextAll('label').toggle(cachedMetaItem_1.Value.length === 0);
                                Msg.show('Cannot Save Changes', Utils.parseJqXhrMsg(jqXHR), { msgType: 'error', autoCloseDelay: 0 });
                            });
                        }
                        // Restore left/right arrow navigation
                        $("#" + _this.data.Settings.MediaClientId).gsMedia('addCursorNavigationHandler');
                    });
                    editor.on('keydown', (function (e) {
                        var tinyMceEditor = tinyMCE.get(e.target.id);
                        if (e.keyCode === Enums.KeyCode.Escape) {
                            var cachedMetaItem = _this.$target.data(currentMetaItemKey);
                            tinyMceEditor.setContent((cachedMetaItem.MTypeId === Enums.MetaType.HtmlSource ? Utils.htmlEncode(cachedMetaItem.Value) : cachedMetaItem.Value));
                            tinyMceEditor.setDirty(false);
                            tinyMceEditor.targetElm.blur();
                            return false; // Prevent event propagation. If we return true (or omit this line), tinyMceEditor.isDirty() returns true in blur event handler
                        }
                        else if (e.keyCode === Enums.KeyCode.Enter) {
                            if (_this.$target.data(currentMetaItemKey).EditMode === Enums.PropertyEditorMode.PlainTextEditor) {
                                // User hit 'enter' while in text mode. Blur editor to trigger save. Do nothing for HTML mode to allow user to move to next line.
                                tinyMceEditor.targetElm.blur();
                                return false;
                            }
                        }
                        return true;
                    }));
                }
            };
            tinyMCE.init(tinyMcePlainTextOptions);
            // Set up the HTML editor.
            var tinyMceHtmlOptions = Utils.deepCopy(tinyMcePlainTextOptions);
            tinyMceHtmlOptions.selector = "#" + this.data.Settings.MediaClientId + " section[data-editMode=3]";
            tinyMceHtmlOptions.plugins = ['code autolink image link textcolor placeholder'];
            tinyMceHtmlOptions.image_advtab = true; // Add advanced tab to image editor
            tinyMceHtmlOptions.verify_html = false; // Use Gallery Server's scrubber. When verify_html is ommitted or set to true, tinyMCE strips out invalid elements, but only on the client. 
            tinyMceHtmlOptions.toolbar1 = 'formatselect fontsizeselect forecolor backcolor image';
            tinyMceHtmlOptions.toolbar2 = 'undo redo | code bold italic link | alignleft aligncenter alignright | bullist numlist indent';
            delete tinyMceHtmlOptions.forced_root_block; // Remove forced_root_block setting to force it to inherit default value
            tinyMCE.init(tinyMceHtmlOptions);
        };
        GsMedia.prototype.animateMediaObject = function () {
            var _this = this;
            var hideMediaObject = function (moEl) {
                // If it is an image and a transition is specified, then hide the media object container so that it
                // can later be shown with the transition effect. Returns true when object is hidden; otherwise returns false.
                var isImage = _this.data.MediaItem.ItemType === Enums.ItemType.Image;
                var hasTransition = _this.data.Settings.TransitionType !== 'none';
                if (isImage && hasTransition) {
                    // Explicitly set the height of the parent element so that the page doesn't reflow when the media object is hidden.
                    // Line commented out 2012-06-05 because it added a vertical scrollbar and no longer seemed required
                    //moEl.parent().height(moEl.parent().height());
                    moEl.hide();
                    return true;
                }
                else {
                    return false;
                }
            };
            var anEl = $('.gsp_moContainer', this.$target);
            if (hideMediaObject(anEl)) {
                // Valid:  'none', 'fade', 'blind', 'bounce', 'clip', 'drop', 'explode', 'fold', 'highlight', 'puff', 'pulsate', 'scale', 'shake', 'size', 'slide', 'transfer'.
                switch (this.data.Settings.TransitionType) {
                    case 'none':
                        anEl.show();
                        break;
                    case 'fade':
                        anEl.fadeIn(this.data.Settings.TransitionDurationMs);
                        break;
                    default:
                        var options = {};
                        // Some effects have required parameters
                        if (this.data.Settings.TransitionType === 'scale')
                            options = { percent: 100 };
                        anEl.toggle(this.data.Settings.TransitionType, options, this.data.Settings.TransitionDurationMs);
                        break;
                }
            }
        };
        GsMedia.prototype.showPreviousMediaObject = function (e) {
            if (typeof tinyMCE !== 'undefined' && tinyMCE.activeEditor) {
                tinyMCE.activeEditor.destroy();
            }
            this.data.MediaItem = this.getPreviousMediaObject();
            if (this.data.MediaItem) {
                if (e)
                    e.preventDefault(); // Prevent the event from bubbling (prevents hyperlink navigation on next/previous buttons)
                this.data.ActiveGalleryItems = [Utils.convertMediaItemToGalleryItem(this.data.MediaItem)];
                $("#" + this.data.Settings.ClientId + "_moid").val(this.data.MediaItem.Id.toString());
                this.setSize();
                this.render(); // Re-bind the template
                this.$target.trigger('previous.' + this.data.Settings.ClientId, [this.data.ActiveGalleryItems]);
            }
            else
                this.redirectToAlbum();
        };
        GsMedia.prototype.showNextMediaObject = function (e) {
            if (typeof tinyMCE !== 'undefined' && tinyMCE.activeEditor) {
                tinyMCE.activeEditor.destroy();
            }
            this.data.MediaItem = this.getNextMediaObject();
            if (this.data.MediaItem == null && this.data.Settings.SlideShowLoop) {
                // Set media item to the first image
                if (this.data.Album.MediaItems.length > 0) {
                    var mo = this.data.Album.MediaItems[0];
                    while (mo && mo.MimeType !== Enums.MimeType.Image) {
                        mo = this.data.Album.MediaItems[$.inArray(mo, this.data.Album.MediaItems) + 1];
                    }
                    this.data.MediaItem = mo;
                }
            }
            if (this.data.MediaItem) {
                if (e)
                    e.preventDefault(); // Prevent the event from bubbling (prevents hyperlink navigation on next/previous buttons)
                this.data.ActiveGalleryItems = [Utils.convertMediaItemToGalleryItem(this.data.MediaItem)];
                $("#" + this.data.Settings.ClientId + "_moid").val(this.data.MediaItem.Id.toString());
                this.setSize();
                this.render(); // Re-bind the template
                this.$target.trigger("next." + this.data.Settings.ClientId, [this.data.ActiveGalleryItems]);
            }
            else
                this.redirectToAlbum();
        };
        GsMedia.prototype.showMediaObject = function (id) {
            this.data.MediaItem = Utils.findMediaItem(this.data, id);
            if (this.data.MediaItem) {
                this.data.ActiveGalleryItems = [Utils.convertMediaItemToGalleryItem(this.data.MediaItem)];
                $("#" + this.data.Settings.ClientId + "_moid").val(this.data.MediaItem.Id.toString());
                this.setSize();
                this.render(); // Re-bind the template
                this.$target.trigger("mediaUpdate." + this.data.Settings.ClientId, [this.data.ActiveGalleryItems]);
            }
            else
                this.redirectToAlbum();
        };
        GsMedia.prototype.getPreviousMediaObject = function () {
            return this.data.Album.MediaItems[$.inArray(this.data.MediaItem, this.data.Album.MediaItems) - 1];
        };
        GsMedia.prototype.getNextMediaObject = function () {
            if (this.data.Settings.SlideShowIsRunning) {
                // Return the next *image* media object
                var mo = this.data.MediaItem;
                do {
                    mo = this.data.Album.MediaItems[$.inArray(mo, this.data.Album.MediaItems) + 1];
                } while (mo && mo.MimeType !== Enums.MimeType.Image);
                return mo;
            }
            else {
                // Return the next media object
                return this.data.Album.MediaItems[$.inArray(this.data.MediaItem, this.data.Album.MediaItems) + 1];
            }
        };
        GsMedia.prototype.redirectToAlbum = function () {
            window.location.href = Utils.GetAlbumUrl(this.data.Album.Id, true);
        };
        ;
        GsMedia.prototype.runMediaObjectScript = function () {
            if (this.data.MediaItem.Views[this.data.MediaItem.ViewIndex].ScriptOutput.length > 0) {
                (new Function((this.data.MediaItem.Views[this.data.MediaItem.ViewIndex].ScriptOutput)))();
            }
        };
        GsMedia.prototype.getPermalink = function (id) {
            return Utils.GetUrl(document.location.href, { moid: id });
        };
        ;
        GsMedia.prototype.overwriteMediaObject = function () {
            // Overwrite the this.Data.MediaItem object that was parsed from JSON with the equivalent object from the collection. We do this so that
            // we can later use $.inArray to find the current item in the array.
            for (var i = 0; i < this.data.Album.MediaItems.length; i++) {
                if (this.data.Album.MediaItems[i].Id === this.data.MediaItem.Id) {
                    this.data.MediaItem = this.data.Album.MediaItems[i];
                    return;
                }
            }
        };
        GsMedia.prototype.attachEvents = function () {
            // This runs once when initialized, so don't wire up any events on items *inside* the template, since
            // they'll be erased when the user navigates between media objects. (Do that in attachMediaEvents())
            var _this = this;
            // Attach a handler for when a metaitem is updated.
            $("#" + this.data.Settings.MediaClientId).on("metaUpdate." + this.data.Settings.ClientId, function (e, gim) { _this.onMetaUpdate(e, gim); });
            this.addCursorNavigationHandler();
        };
        GsMedia.prototype.attachMediaEvents = function () {
            // This runs each time the template is rendered, so here we wire up events to any elements inside the rendered HTML.
            var _this = this;
            // Attach handlers for next/previous clicks and left/right swipes.
            $('.gsp_mvPrevBtn', this.$target).on('click', function (e) { _this.showPreviousMediaObject(e); });
            $('.gsp_mvNextBtn', this.$target).on('click', function (e) { _this.showNextMediaObject(e); });
            if (Utils.isTouchScreen) {
                $('.gsp_moContainer', this.$target).touchwipe({
                    preventDefaultEvents: false,
                    wipeLeft: function () { _this.showNextMediaObject(); },
                    wipeRight: function () { _this.showPreviousMediaObject(); }
                });
            }
        };
        GsMedia.prototype.addCursorNavigationHandler = function () {
            var _this = this;
            if (this.data.Settings.ShowMediaObjectNavigation) {
                $(document.documentElement).on("keydown." + this.data.Settings.ClientId, function (e) {
                    if ((e.target.tagName === 'INPUT') || (e.target.tagName === 'TEXTAREA'))
                        return; // Ignore when focus is in editable box
                    if (e.keyCode === Enums.KeyCode.CursorLeft)
                        _this.showPreviousMediaObject(e);
                    if (e.keyCode === Enums.KeyCode.CursorRight)
                        _this.showNextMediaObject(e);
                });
            }
        };
        GsMedia.prototype.removeCursorNavigationHandler = function () {
            $(document.documentElement).off("keydown." + this.data.Settings.ClientId);
        };
        ;
        GsMedia.prototype.onMetaUpdate = function (e, gim) {
            // Event handler for when a meta item has been updated. e is the jQuery event object; gim is the GalleryItemMeta instance.
            if (gim.MetaItem.MTypeId === Enums.MetaType.Title) {
                this.render(); // At some point we may want to move this outside the 'if' if the media template uses other metadata values
            }
            else if (gim.MetaItem.MTypeId === Enums.MetaType.HtmlSource) {
                this.render();
            }
        };
        GsMedia.prototype.preloadImages = function () {
            var _this = this;
            // Create an array of all optimized or original image URLs
            var urls = $.map(this.data.Album.MediaItems, function (mo) {
                for (var i = 0; i < mo.Views.length; i++) {
                    if ((mo.Views[i].ViewType === Enums.MimeType.Image) && (mo.Views[i].ViewSize === _this.data.Settings.MediaViewSize))
                        return mo.Views[i].Url;
                }
                return null;
            });
            // Create an image tag & set the source
            $.each(urls, function (idx, url) {
                $('<img>').attr('src', url);
            });
        };
        return GsMedia;
    }());
    //#endregion End GsMedia object
    //#region gs.gsThumbnails widget
    $.widget('gs.gsThumbnails', {
        options: {
            clientId: ''
        },
        _create: function () {
            var data = Vars[this.options.clientId].gsData;
            this.gsThumbnails = new GsThumbnails(this.element, data, this.options);
        },
        renderThumbnails: function () {
            this.gsThumbnails.renderThmbView();
        },
        selectThumbnails: function () {
            this.gsThumbnails.selectThumbnails();
        },
        deselectThumbnails: function () {
            this.gsThumbnails.deselectThumbnails();
        }
    });
    var GsThumbnails = /** @class */ (function () {
        function GsThumbnails(target, data, options) {
            this.hndleDom = "<div class='hndl'><span class='fa fa-arrows'></span></div>"; // The drag handle for rearranging thumbnails
            this.$target = target; // A jQuery object to receive the rendered HTML from the template.
            this.data = data;
            this.gsThumbnailsOptions = options;
            if (!this.data.Album.GalleryItems) {
                Msg.show('Cannot Render Album', "<p>Cannot render the album thumbnails. Navigate to an album and then return to this page.</p><p>You'll know you got it right when you see 'aid' In the URL's query string.</p><p>ERROR: data.Album.GalleryItems is null.</p>", { msgType: 'error', autoCloseDelay: 0 });
                return;
            }
            this.jsRenderSetup(); // Prepare jsRender for rendering
            this.attachEvents();
            this.renderThmbView();
        }
        GsThumbnails.prototype.attachEvents = function () {
            var _this = this;
            // Attach a handler for when a metaitem is updated.
            $("#" + this.data.Settings.ThumbnailClientId).on("metaUpdate." + this.data.Settings.ClientId, function (e, gim) { _this.onMetaUpdate(e, gim); });
        };
        GsThumbnails.prototype.onMetaUpdate = function (e, gim) {
            // Meta data has been updated. Let's re-render the thumbnail view so that is always shows the
            // latest data (e.g. the title/caption may have changed).
            var selItemsOld = $('.ui-selected', e.currentTarget); // Grab a reference to which thumbnails are selected
            this.renderThmbView(); // Render the template (which will wipe out the current selection)
            // Re-select thumbnails that were previously selected
            $('.thmb', this.$target).filter(function (idx, el) { return selItemsOld.is("li[data-id=" + $(el).data('id') + "][data-it=" + $(el).data('it') + "]"); })
                .addClass('ui-selected');
            // Update: I'm leaving this commented out so that user can tab from title to the next meta property (caption).
            // Trigger the selectable 'stop' event, which ultimately refreshes the UI by rebinding the right pane and the thumbnails in the center pane.
            // (Currently it has no effect on left pane, header, or media view because it's not needed)
            // Note that if the fix proposed in bugfix 44 is implemented, it will trigger this to fire when tags/people are updated,
            // causing the focus to leave the 'next tag' field, making it hard to quickly add multiple tags.
            //const s = $('.thmb', this.$target).parent().selectable('option', 'stop');
            //if (typeof (s) == 'function')
            //    s();
        };
        GsThumbnails.prototype.renderThmbView = function () {
            var albumHtml = $.render[this.data.Settings.ThumbnailTmplName](this.data);
            if (!this.renderPager(albumHtml)) {
                var $albumHtml = $(albumHtml);
                this.activateImages($albumHtml);
                this.$target.empty().append($albumHtml);
                this.configThmbs(); // Assign width & height of thumbnails, make selectable
            }
            this.configHeader();
        };
        GsThumbnails.prototype.selectThumbnails = function () {
            $('.thmb', this.$target).addClass('ui-selected');
            this.triggerThumbnailSelectionStopEvent();
        };
        GsThumbnails.prototype.deselectThumbnails = function () {
            $('.thmb', this.$target).removeClass('ui-selected');
            this.triggerThumbnailSelectionStopEvent();
        };
        /**
         * Fire the selectable stop event associated with the thumbnail selection behavior. This updates the current selection
         * in our client data (ActiveGalleryItems) and does a few other housekeeping items. See thmbSelected function for details.
         */
        GsThumbnails.prototype.triggerThumbnailSelectionStopEvent = function () {
            var s = $('.thmb', this.$target).parent().selectable('option', 'stop');
            if (typeof (s) == 'function')
                s();
        };
        GsThumbnails.prototype.configHeader = function () {
            var _this = this;
            // When user clicks header area, make the album the current item, unselect any selected thumbnails, and trigger event to be handled in meta plug-in
            $('.gsp_abm_sum', this.$target).click(function () {
                $('.thmb', _this.$target).removeClass('ui-selected');
                _this.data.ActiveGalleryItems = [Utils.convertAlbumToGalleryItem(_this.data.Album)];
                _this.$target.trigger("select." + _this.data.Settings.ClientId, [_this.data.ActiveGalleryItems]);
            });
        };
        ;
        GsThumbnails.prototype.pagerRequired = function () {
            return (this.data.Settings.PageSize > 0 && this.data.Album.GalleryItems.length > this.data.Settings.PageSize);
        };
        ;
        /**
         * If present, replace attribute 'srcDelay' with 'src'. This activates image sources, which will trigger a call to the server.
         * We start with 'srcDelay' to prevent server calls for every image in an album.
         * See https://galleryserverpro.com/get-faster-page-loading-with-on-demand-thumbnail-image-retrieval/
         */
        GsThumbnails.prototype.activateImages = function (html) {
            $('img.gsp_thmb_img', html).each(function (idx, el) {
                if (el.getAttribute('srcDelay')) {
                    el.setAttribute('src', el.getAttribute('srcDelay'));
                    el.removeAttribute('srcDelay');
                }
            });
        };
        GsThumbnails.prototype.renderPager = function (albumHtml) {
            var _this = this;
            if (!this.pagerRequired())
                return false;
            var $albumHtml = $(albumHtml);
            var $albumHtmlThmbs = $albumHtml.find('.thmb').clone();
            var $albumHtmlWithoutThmbs = $albumHtml.find('.thmb').remove().end();
            var pagerOptions = {
                format: '[< c >]',
                page: null,
                lapping: 0,
                perpage: this.data.Settings.PageSize,
                onSelect: function (pagerData, page) { return _this.onPagerSelect(pagerData, page, $albumHtmlThmbs); },
                onFormat: function (pagerData, pagerEvent) { return _this.onPagerFormat(pagerData, pagerEvent); }
            };
            // Render album template except for thumbnails (we'll add the thumbs in onSelect)
            this.$target.html($albumHtmlWithoutThmbs);
            var pgr = $();
            var pagerHtml = '<div class="gsp_pager"></div>';
            if (this.data.Settings.PagerLocation === 'Top' || this.data.Settings.PagerLocation === 'TopAndBottom') {
                pgr = $(pagerHtml).prependTo(this.$target);
            }
            if (this.data.Settings.PagerLocation === 'Bottom' || this.data.Settings.PagerLocation === 'TopAndBottom') {
                pgr = pgr.add($(pagerHtml).appendTo(this.$target));
            }
            var pager = pgr.paging(this.data.Album.GalleryItems.length, pagerOptions);
            $(window).on('hashchange', (function () {
                if (window.location.hash)
                    pager.setPage(parseInt(window.location.hash.substr(1), 10));
                else
                    pager.setPage(1); // Default to 1st page
            }));
            $(window).trigger('hashchange');
            return true;
        };
        GsThumbnails.prototype.onPagerSelect = function (pagerData, page, $albumHtmlThmbs) {
            // Retrieve the HTML for the desired slice and replace existing thumbnails with them.
            var visibleIndices = pagerData.slice; // Contains start and end indices for visible elements
            $('.thmb', this.$target).remove();
            // Get array of thumbnail elements for the desired page, then add to page DOM, and configure
            var html = $albumHtmlThmbs.slice(visibleIndices[0], visibleIndices[1]);
            this.activateImages(html);
            $('.gsp_abm_thmbs').append(html.hide().fadeIn());
            this.configThmbs();
            this.$target.trigger("page." + this.data.Settings.ClientId, this);
            return true;
        };
        GsThumbnails.prototype.onPagerFormat = function (pagerData, pagerEvent) {
            switch (pagerEvent) {
                case 'block':
                    // n and c
                    return '<span class="gsp_pagerText">' + this.data.Resource.AbmPgrStatus.format(pagerData.value, pagerData.pages) + '</span>';
                case 'next':
                    // >
                    if (pagerData.active)
                        return '<a href="#' + pagerData.value + '" title="' + this.data.Resource.AbmPgrNextTt + '"></a>';
                    else
                        return '<span class="gsp_disabled"></span>';
                case 'prev':
                    // <
                    if (pagerData.active)
                        return '<a href="#' + pagerData.value + '" title="' + this.data.Resource.AbmPgrPrevTt + '"></a>';
                    else
                        return '<span class="gsp_disabled"></span>';
                case 'first':
                    // [
                    if (pagerData.active)
                        return '<a href="#' + pagerData.value + '" title="' + this.data.Resource.AbmPgrFirstTt + '" class="gsp_first-child"></a>';
                    else
                        return '<span class="gsp_disabled gsp_first-child"></span>';
                case 'last':
                    // ]
                    if (pagerData.active)
                        return '<a href="#' + pagerData.value + '" title="' + this.data.Resource.AbmPgrLastTt + '" class="gsp_last-child"></a>';
                    else
                        return '<span class="gsp_disabled gsp_last-child"></span>';
                default:
                    return '';
            }
        };
        GsThumbnails.prototype.thmbSelected = function (e, ui) {
            var _this = this;
            // Get a reference to the selected gallery items, then trigger event to be handled in meta plug-in
            var selItems = $.map($('.ui-selected', this.$target), function (item) {
                var $this = $(item);
                var id = $this.data('id');
                var itemType = $this.data('it');
                // Get the gallery item that matches the thumbnail that was selected
                return $.map(_this.data.Album.GalleryItems, function (obj) { return (obj.Id === id && obj.ItemType === itemType ? obj : null); })[0];
            });
            if (this.data.Album.Permissions.EditAlbum && this.data.Album.SortById === Constants.IntMinValue) {
                if (Utils.isTouchScreen() && selItems.length === 1) {
                    $('.ui-selected', this.$target).prepend(this.hndleDom);
                }
            }
            this.data.ActiveGalleryItems = selItems.length > 0 ? selItems : [Utils.convertAlbumToGalleryItem(this.data.Album)];
            if (!(selItems.length === 1 && selItems[0].Id === Constants.IntMinValue)) {
                // User selected another thumbnail before finishing the creation of a new album. Blur the input to finish the album creation
                $('.mce-edit-focus', this.$target).blur();
            }
            this.$target.trigger("select." + this.data.Settings.ClientId, [this.data.ActiveGalleryItems]);
        };
        ;
        GsThumbnails.prototype.thmbUnselected = function (e, ui) {
            $('.hndl', ui.unselected).remove();
        };
        ;
        GsThumbnails.prototype.configThmbs = function () {
            var _this = this;
            var $thmbs = $('.thmb', this.$target);
            $thmbs.equalSize(); // Make all thumbnail tags the same width & height
            var isSinglePaneTouchScreen = Utils.isTouchScreen() && Utils.isWidthLessThan(750);
            if (!isSinglePaneTouchScreen) {
                // Use jQuery UI selectable interaction for thumbnail selection, which gives us dragging and CTRL-click multiple selection.
                // We can't use this on single pane touchscreens because it prevents the user from scrolling with their finger.
                $thmbs.parent().selectable({
                    filter: 'li',
                    cancel: 'a,.hndl,input,.mce-edit-focus',
                    stop: this.thmbSelected.bind(this),
                    unselected: this.thmbUnselected.bind(this)
                });
            }
            else {
                // We have single pane touchscreen (probably a smart phone < 750px wide). Hook into click event of thumbnail. User will only be
                // able to select one thumbnail at a time, but it's better than nothing. (see gallery.css & media.ascx)
                $thmbs.click(function (e) {
                    $thmbs.removeClass('ui-selected').filter($(e.currentTarget)).addClass('ui-selected');
                    _this.thmbSelected(e, null);
                });
            }
            // Make thumbnails sortable
            if (this.data.Album.Permissions.EditAlbum && this.data.Album.SortById === Constants.IntMinValue) {
                var onManualSort = function (e, ui) {
                    var $thmb = ui.item;
                    $thmb.addClass('gsp_wait');
                    // Get the items in their current sequence and pass that to the server's sort method.
                    var gItems = $.map($thmb.parent().children(), function (item) {
                        var $this = $(item);
                        var id = $this.data('id');
                        var itemType = $this.data('it');
                        return { Id: id, ItemType: itemType };
                    });
                    DataService.sortGalleryItems(gItems, function () {
                        // DONE callback
                        $thmb.removeClass('gsp_wait');
                    }, null, function (jqXHR) {
                        Msg.show('Cannot Save', Utils.parseJqXhrMsg(jqXHR), { msgType: 'error', autoCloseDelay: 0 });
                    });
                };
                $thmbs
                    .css({ '-ms-touch-action': 'none', 'touch-action': 'none' }) // Required to allow dragging on touchscreens (-ms-touch-action applies to IE10 only)
                    .parent()
                    .sortable({
                    start: function (e, ui) {
                        ui.placeholder.width(ui.helper.width());
                        ui.placeholder.height(ui.helper.height());
                    },
                    stop: onManualSort,
                    scroll: true,
                    containment: 'document',
                    cursor: 'move',
                    handle: '.hndl'
                });
                // Show/hide the drag bar when a user hovers over the thumbnail, but only for non-touchscreens.
                // We use stop/unselected events to handle show/hide for touchscreens.
                if (!Utils.isTouchScreen()) {
                    $thmbs.hover(function (e) { $(e.currentTarget).prepend(_this.hndleDom); }, function (e) { $('.hndl', $(e.currentTarget)).remove(); });
                }
            }
        };
        GsThumbnails.prototype.jsRenderSetup = function () {
            var _this = this;
            // Set up converters that can strip all HTML from some text and truncate. There is a related stripHtml converter in
            // Gs.Utils.Init(). Note that the released version of jsRender may support chained converters, which would allow 
            // us to create one for stripping and one for truncating, then chain them instead of using stripHtmlAndTruncate.
            // See https://github.com/BorisMoore/jsrender/issues/127
            $.views.converters({
                stripHtmlAndTruncate: function (text) {
                    var t = text.replace(/(<[^<>]*>)/g, '');
                    var m = _this.data.Settings.MaxThmbTitleDisplayLength;
                    return (t.length > m ? Utils.escape(t.substr(0, m)) + '...' : Utils.escape(t));
                }
            });
        };
        ;
        return GsThumbnails;
    }());
    //#endregion GsThumbnails class
    //#region gspMeta plug-in
    $.fn.gspMeta = function (data, options) {
        var self = this;
        return this.each(function () {
            if (!$.data(this, 'plugin_gspMeta')) {
                var gspMeta = new GsMeta();
                gspMeta.init(self, data, options);
                $.data(this, 'plugin_gspMeta', gspMeta);
            }
        });
    };
    $.fn.gspMeta.defaults = {
        tmplName: ''
    };
    var GsMeta = /** @class */ (function () {
        function GsMeta() {
        }
        GsMeta.prototype.init = function (target, gsData, options) {
            this.$target = target;
            this.data = gsData;
            this.settings = $.extend({}, $.fn.gspMeta.defaults, options);
            this.bindData();
            // Bind to next, previous, and mediaUpdated events from the GspMedia plug-in so that we can refresh the metadata.
            $("#" + this.data.Settings.MediaClientId).on('next.' + this.data.Settings.ClientId + ' previous.' + this.data.Settings.ClientId + ' mediaUpdate.' + this.data.Settings.ClientId, $.proxy(this.showMeta, this));
            // Bind to the select event from the gsThumbnails plug-in so we can refresh the metadata.
            $("#" + this.data.Settings.ThumbnailClientId).on('select.' + this.data.Settings.ClientId, $.proxy(this.showMeta, this)); // $.proxy(this.showMeta, this) *or* e => this.showMeta(e) *or* this.showMeta.bind(this) http://stackoverflow.com/questions/12756423/
        };
        GsMeta.prototype.bindData = function () {
            var _this = this;
            // Render the right pane template to the page DOM
            this.$target.removeClass('gsp_wait').html($.render[this.settings.tmplName](this.data));
            // Add separator row between the top and bottom sections of the metadata table
            $('.gsp_m1Row:last').after('<tr class="gsp_mSep"><td colspan="2"></td></tr>');
            var hasExistingMetaItems = this.data.ActiveMetaItems.length > 0;
            var hasEditPermission = function (callback) {
                // Determine if user has edit permission to ActiveGalleryItems. Since this calculation may involve an async post to the server,
                // instead of returning a boolean we take a callback function and pass the result (as a boolean) to the function.
                // If any of the selected items are a media object, verify user has EditMediaObject perm.
                // If any of the selected items are an album, verify user has EditAlbum perm.
                var hasAlbum, hasMediaItem;
                $.each(_this.data.ActiveGalleryItems, function (i, gItem) {
                    if (gItem.IsAlbum)
                        hasAlbum = true;
                    else
                        hasMediaItem = true;
                });
                var canEdit = ((!hasAlbum || _this.data.Album.Permissions.EditAlbum) && (!hasMediaItem || _this.data.Album.Permissions.EditMediaObject));
                var isVirtualAlbum = _this.data.Album.VirtualType !== Enums.VirtualAlbumType.NotVirtual;
                var isChildSelected = (_this.data.ActiveGalleryItems.length >= 0 && _this.data.ActiveGalleryItems[0].Id !== _this.data.Album.Id);
                if (!canEdit && isVirtualAlbum && isChildSelected && _this.data.User.IsAuthenticated) {
                    // Logged-on user is looking at a virtual album and has limited permissions. User may have edit permission to the 
                    // particular items that are selected, so make a callback to see.
                    DataService.canUserEdit(_this.data.ActiveGalleryItems, null, function (canEditFromServer) {
                        // SUCCESS callback: Send result from server to callback function passed to this function
                        callback.apply(_this, [canEditFromServer]);
                    }, function (jqXHR) {
                        Msg.show('Cannot Determine User Permission', Utils.parseJqXhrMsg(jqXHR), { msgType: 'error', autoCloseDelay: 0 });
                    });
                }
                else {
                    callback.apply(_this, [canEdit]);
                }
                //return canEdit;
            };
            if (hasExistingMetaItems) {
                hasEditPermission(function (canUserEdit) {
                    if (canUserEdit) {
                        _this.makeMetaEditable();
                    }
                    else {
                        _this.convertTagsToLinks();
                    }
                });
            }
            this.configureRating();
        };
        GsMeta.prototype.convertTagsToLinks = function () {
            var _this = this;
            // Look for the comma-separated tags (they have CSS class names gsp_mtag & gsp_mpeople) and convert them to hyperlinks.
            $.each(['tag', 'people'], function (i, tagType) {
                // Find the tag or people tag, but not if it's been previously made editable (we won't do anything in those cases)
                var tagContainer = $('.gsp_meta tr td.gsp_m' + tagType, _this.$target);
                // Build HTML links to represent the tags.
                var html = $.map(tagContainer.text().split(','), function (item) {
                    var tag = item.trim();
                    if (tag.length > 0) {
                        var parms = { title: null, tag: null, people: null, search: null, latest: null, filter: null, rating: null, top: null, aid: null, moid: null };
                        parms[tagType] = tag.replace(/\s+\(\d+\)$/gi, ''); // Strip off the trailing count (e.g ' (3)') if present
                        return "<a href=\"" + Utils.GetUrl(window.location.href, parms) + "\" class=\"gsp_mtaglink\">" + tag + "</a>";
                    }
                    return null;
                });
                tagContainer.text('').html(html.join('')); // Replace text with HTML links
            });
        };
        GsMeta.prototype.configureRating = function () {
            var _this = this;
            // Get rating element. Gets a match ONLY when the admin has configured the rating meta item as editable.
            var editableRatingEls = $('tr[data-editmode=2] .gsp_rating, tr[data-editmode=3] .gsp_rating', this.$target);
            if (editableRatingEls.length > 0 && (this.data.User.IsAuthenticated || this.data.Settings.AllowAnonymousRating)) {
                // Configure an editable rating
                editableRatingEls.rateit({
                    min: 0,
                    max: 5,
                    resetable: false
                }).on('rated', function (e, v) {
                    _this.$target.addClass('gsp_wait');
                    var metaTypeId = _this.getMetaItem($(e.target).closest('.gsp_m2Row').data('id')).MTypeId;
                    var galleryItemMeta = { GalleryItems: _this.data.ActiveGalleryItems, MetaItem: { MTypeId: metaTypeId, Value: v } };
                    DataService.saveMeta(galleryItemMeta, function () { _this.$target.removeClass('gsp_wait'); }, function (gim, resMsg, ajax) {
                        // Success callback - Ajax request to rate completed. Check for validation and other errors and respond accordingly
                        switch (gim.ActionResult.Status) {
                            case 'Success':
                                _this.syncGalleryDataOnMetaUpdate(gim);
                                break;
                            case 'Info':
                            case 'Warning':
                            case 'Error':
                                Msg.show(gim.ActionResult.Title, gim.ActionResult.Message, { msgType: gim.ActionResult.Status.toLowerCase(), autoCloseDelay: 0 });
                                break;
                        }
                    }, function (jqXHR) {
                        Msg.show('Cannot Save Changes', Utils.parseJqXhrMsg(jqXHR), { msgType: 'error', autoCloseDelay: 0 });
                    });
                });
            }
            else {
                // Configure a read-only rating
                $('.gsp_rating', this.$target).rateit({
                    min: 0,
                    max: 5,
                    resetable: false,
                    readonly: true
                });
            }
        };
        GsMeta.prototype.syncGalleryDataOnMetaUpdate = function (gim) {
            // Update related properties on albums, media objects, and their metadata when meta items are changed.
            for (var i = 0; i < gim.GalleryItems.length; i++) {
                // Update GalleryItem, MediaItem, Album, and MetaItems
                var gNew = gim.GalleryItems[i];
                var metaItems = void 0;
                // Update gallery item if present in our data
                var gCurrent = Utils.findGalleryItem(this.data, gNew.Id, gNew.ItemType);
                if (gCurrent != null) {
                    switch (gim.MetaItem.MTypeId) {
                        case Enums.MetaType.Title:
                            gCurrent.Title = gim.MetaItem.Value;
                            break;
                        case Enums.MetaType.Caption:
                            gCurrent.Caption = gim.MetaItem.Value;
                            break;
                    }
                }
                // Update media object if present in our data
                var mCurrent = Utils.findMediaItem(this.data, gNew.Id, gNew.ItemType);
                if (mCurrent != null) {
                    switch (gim.MetaItem.MTypeId) {
                        case Enums.MetaType.Title:
                            mCurrent.Title = gim.MetaItem.Value;
                            break;
                        case Enums.MetaType.HtmlSource:
                            {
                                var view = Utils.getView(mCurrent, Enums.ViewSize.External);
                                if (view)
                                    view.HtmlOutput = gim.MetaItem.Value;
                                break;
                            }
                    }
                    metaItems = mCurrent.MetaItems;
                }
                // Update album if present in our data
                if (this.data.Album != null && this.data.Album.Id === gNew.Id && gNew.ItemType === Enums.ItemType.Album) {
                    switch (gim.MetaItem.MTypeId) {
                        case Enums.MetaType.Title:
                            this.data.Album.Title = gim.MetaItem.Value;
                            break;
                        case Enums.MetaType.Caption:
                            this.data.Album.Caption = gim.MetaItem.Value;
                            break;
                    }
                    metaItems = this.data.Album.MetaItems;
                }
                // Update meta item if present in our data
                if (metaItems != null) {
                    var mi = Utils.findMetaItem(metaItems, gim.MetaItem.MTypeId);
                    if (mi != null)
                        mi.Value = gim.MetaItem.Value;
                }
                // Update meta item in our ActiveMetaItems array
                var activeMetaItem = $.grep(this.data.ActiveMetaItems, function (mi) { return (mi.MTypeId === gim.MetaItem.MTypeId); })[0];
                if (activeMetaItem != null) {
                    activeMetaItem.Value = gim.MetaItem.Value;
                }
            }
        };
        GsMeta.prototype.makeMetaEditable = function () {
            var _this = this;
            var tinyMcePlainTextOptions = {
                selector: "#" + this.data.Settings.RightPaneClientId + " tr[data-editMode=2] .gs_vv",
                menubar: false,
                inline: true,
                skin: this.data.App.Skin,
                plugins: ['placeholder'],
                toolbar: false,
                forced_root_block: false,
                verify_html: false,
                placeholder_text: this.data.Resource.MetaEditPlaceholder,
                setup: function (editor) {
                    var selectedGalleryItemsKey = 'sgi';
                    var semaphoreKey = 'sk';
                    var getMetaItemId = function ($targetElm) {
                        return $targetElm.closest('tr').data('id');
                    };
                    var getMetaItemKey = function ($targetElm) {
                        return "cmi_" + getMetaItemId($targetElm).toString();
                    };
                    editor.on('init', function (e) {
                        // Navigate to hyperlink if user clicks on one. Without this tinyMCE simply makes the area editable and doesn't send the user to the URL.
                        $(editor.getBody()).on('click', 'a[href]', function (e1) {
                            window.location.href = $(e1.currentTarget).attr('href');
                        });
                    });
                    editor.on('focus', function (e) {
                        var $targetElm = $(e.target.targetElm);
                        $targetElm.data(semaphoreKey, true);
                        _this.$target.data(selectedGalleryItemsKey, _this.data.ActiveGalleryItems);
                        var metaItem = _this.getMetaItem(getMetaItemId($targetElm));
                        _this.$target.data(getMetaItemKey($targetElm), metaItem);
                        if (metaItem.EditMode === Enums.PropertyEditorMode.PlainTextEditor) {
                            // Need to encode any HTML for plain text editing
                            var tinyMceEditor = tinyMCE.get(e.target.id);
                            tinyMceEditor.setContent(Utils.htmlEncode(metaItem.Value));
                        }
                        else if (metaItem.MTypeId === Enums.MetaType.HtmlSource) {
                            // External HTML is encoded for display, so we need to get the un-encoded value from the metadata item
                            tinyMCE.get(e.target.id).setContent(metaItem.Value);
                        }
                        // Disable left/right arrow navigation so user can use these keys while editing
                        $("#" + _this.data.Settings.MediaClientId).gsMedia('removeCursorNavigationHandler');
                    });
                    editor.on('blur', function (e) {
                        var tinyMceEditor = tinyMCE.get(e.target.id);
                        var $targetElm = $(tinyMceEditor.targetElm);
                        // If tinyMCE thinks there are changes OR more than one thumbnail was selected and the property is set to a blank value, save changes.
                        // We need the second test because one or more of the selected items may have a value that needs deleting.
                        var isDirty = tinyMceEditor.isDirty() || (_this.data.ActiveGalleryItems.length > 1 && tinyMceEditor.getContent().length === 0);
                        // Persist unsaved changes
                        if (isDirty) {
                            // Retrieve the selected gallery items. We can't use data.ActiveGalleryItems because it will be different if user made a new selection
                            // (this is because the blur event we're running right now fires after the jQuery UI selected event)
                            var selectedGalleryItems = _this.$target.data(selectedGalleryItemsKey);
                            var cachedMetaItem_2 = _this.$target.data(getMetaItemKey($targetElm));
                            var editorFormat = (cachedMetaItem_2.EditMode === Enums.PropertyEditorMode.TinyMCEHtmlEditor ? 'html' : 'text');
                            var galleryItemMeta = { GalleryItems: selectedGalleryItems, MetaItem: { MTypeId: cachedMetaItem_2.MTypeId, Value: tinyMceEditor.getContent({ format: editorFormat }) } };
                            var $parentCell_2 = $targetElm.parent().addClass('gsp_wait_center'); // This is the TD cell containing the meta value
                            DataService.saveMeta(galleryItemMeta, function () { $parentCell_2.removeClass('gsp_wait_center'); }, function (gim) {
                                // Success callback - Ajax request to save meta property completed. Check for validation and other errors and respond accordingly
                                switch (gim.ActionResult.Status) {
                                    case 'Success':
                                    case 'Info':
                                    case 'Warning':
                                        {
                                            _this.syncGalleryDataOnMetaUpdate(gim);
                                            if (cachedMetaItem_2.MTypeId === Enums.MetaType.HtmlSource) {
                                                // HTML encode the external HTML meta property so user can see HTML codes
                                                tinyMCE.get(e.target.id).targetElm.innerHTML = Utils.htmlEncode(gim.MetaItem.Value);
                                            }
                                            else if (cachedMetaItem_2.EditMode === Enums.PropertyEditorMode.PlainTextEditor) {
                                                // Editor may have been displaying HTML-encoded text, so now display the un-encoded value
                                                tinyMCE.get(e.target.id).targetElm.innerHTML = gim.MetaItem.Value;
                                            }
                                            // Trigger event to refresh the center pane. We could trigger only when title is updated since that's the only property shown
                                            // in the center in a default install, but we do it for all updates in case admin has added other properties to the center.
                                            $("#" + _this.data.Settings.MediaClientId).trigger("metaUpdate." + _this.data.Settings.ClientId, [gim]);
                                            $("#" + _this.data.Settings.ThumbnailClientId).trigger("metaUpdate." + _this.data.Settings.ClientId, [gim]);
                                            // The thumbnail 'select' event fires in between the focus and blur events, so if user selected a thumbnail while editing a meta property,
                                            // the right pane will have been re-rendered with the old meta data before this event fires. Detect this situation and trigger the
                                            // thumbnail 'select' event a second time, which will cause the right pane to be re-rendered, this time with correct meta data.
                                            // We want to fire only when necessary because if the focus is on a right pane property, it will be lost.
                                            // Step 1: Has right pane been rendered since focus event fired? Will be true when user selects any thumbnail, which causes our semaphore to disappear
                                            var rightPaneHasBeenRenderedSinceFocus = typeof $targetElm.data(semaphoreKey) === 'undefined';
                                            // Step 2: Is the last selected thumbnail one of the gallery items we just updated?
                                            var lastSelectedItemWasUpdated = function (updatedItems) {
                                                var itemWasUpdated = false;
                                                if (updatedItems.length > 0) {
                                                    updatedItems.forEach(function (gi) {
                                                        if (gi.Id === _this.data.ActiveGalleryItems[_this.data.ActiveGalleryItems.length - 1].Id) {
                                                            itemWasUpdated = true;
                                                        }
                                                    });
                                                }
                                                return itemWasUpdated;
                                            };
                                            if (rightPaneHasBeenRenderedSinceFocus && lastSelectedItemWasUpdated(gim.GalleryItems)) {
                                                $("#" + _this.data.Settings.ThumbnailClientId).trigger("select." + _this.data.Settings.ClientId, [_this.data.ActiveGalleryItems]);
                                            }
                                            break;
                                        }
                                    case 'Error':
                                        // Revert to previous value and show or hide the placeholder text.
                                        $targetElm.html(cachedMetaItem_2.Value).nextAll('label').toggle(cachedMetaItem_2.Value.length === 0);
                                        break;
                                }
                                if (gim.ActionResult.Status !== 'Success') {
                                    Msg.show(gim.ActionResult.Title, gim.ActionResult.Message, { msgType: gim.ActionResult.Status.toLowerCase(), autoCloseDelay: 0 });
                                }
                            }, function (jqXHR) {
                                // Revert to previous value and show or hide the placeholder text.
                                $targetElm.html(cachedMetaItem_2.Value).nextAll('label').toggle(cachedMetaItem_2.Value.length === 0);
                                Msg.show('Cannot Save Changes', Utils.parseJqXhrMsg(jqXHR), { msgType: 'error', autoCloseDelay: 0 });
                            });
                        }
                        // Restore left/right arrow navigation
                        $("#" + _this.data.Settings.MediaClientId).gsMedia('addCursorNavigationHandler');
                    });
                    editor.on('keydown', (function (e) {
                        var tinyMceEditor = tinyMCE.get(e.target.id);
                        if (e.keyCode === Enums.KeyCode.Escape) {
                            var cachedMetaItem = _this.$target.data(getMetaItemKey($(tinyMceEditor.targetElm)));
                            tinyMceEditor.setContent((cachedMetaItem.MTypeId === Enums.MetaType.HtmlSource ? Utils.htmlEncode(cachedMetaItem.Value) : cachedMetaItem.Value));
                            tinyMceEditor.setDirty(false);
                            tinyMceEditor.targetElm.blur();
                            return false; // Prevent event propagation. If we return true (or omit this line), tinyMceEditor.isDirty() returns true in blur event handler
                        }
                        else if (e.keyCode === Enums.KeyCode.Enter) {
                            if (_this.$target.data(getMetaItemKey($(tinyMceEditor.targetElm))).EditMode === Enums.PropertyEditorMode.PlainTextEditor) {
                                // User hit 'enter' while in text mode. Blur editor to trigger save. Do nothing for HTML mode to allow user to move to next line.
                                tinyMceEditor.targetElm.blur();
                                return false;
                            }
                        }
                        return true;
                    }));
                }
            };
            tinyMCE.init(tinyMcePlainTextOptions);
            // Set up the HTML editor.
            var tinyMceHtmlOptions = Utils.deepCopy(tinyMcePlainTextOptions);
            tinyMceHtmlOptions.selector = "#" + this.data.Settings.RightPaneClientId + " tr[data-editMode=3] section";
            tinyMceHtmlOptions.plugins = ['code autolink image link textcolor placeholder'];
            tinyMceHtmlOptions.image_advtab = true; // Add advanced tab to image editor
            tinyMceHtmlOptions.verify_html = false; // Use Gallery Server's scrubber. When verify_html is ommitted or set to true, tinyMCE strips out invalid elements, but only on the client. 
            tinyMceHtmlOptions.toolbar1 = 'formatselect fontsizeselect forecolor backcolor image';
            tinyMceHtmlOptions.toolbar2 = 'undo redo | code bold italic link | alignleft aligncenter alignright | bullist numlist indent';
            delete tinyMceHtmlOptions.forced_root_block; // Remove forced_root_block setting to force it to inherit default value
            tinyMCE.init(tinyMceHtmlOptions);
            // Get the tag value, stripping off trailing count if present. Ex: If tag="Animal (3)", change it to "Animal".
            // The parameter 'e' is expected to be a jQuery reference to the li element containing the tag.
            var getTagValue = function (e) { return e.contents()
                .filter(function (idx, el) { return (el.nodeType === 3); })
                .text().trim().replace(/\s+\(\d+\)$/gi, ''); };
            // Configure the tag/people properties
            $('.gsp_ns .gsp_meta tr[data-editmode=2] .gsp_mtag,.gsp_ns .gsp_meta tr[data-editmode=2] .gsp_mpeople').each(function (idx, el) {
                $(el).html("<input class='' value='" + Utils.escape($(el).text()) + "' placeholder='" + _this.data.Resource.MetaEditPlaceholder + "' />");
                var initComplete = false;
                var ipt = $('input', $(el));
                var tagType = ipt.closest('.gsp_mtag').length > 0 ? 'tags' : 'people';
                ipt.autoSuggest(Vars.AppRoot + '/api/meta/' + tagType, {
                    extraParams: "&galleryId=" + _this.data.Settings.GalleryId,
                    preFill: ipt.val(),
                    minChars: 1,
                    startText: '',
                    selectionClick: function (e) {
                        // User clicked the tag. Navigate to a page showing all objects with that tag.
                        var tagValue = e.parents('.gsp_mtag').length === 0 ? null : getTagValue(e);
                        var peopleValue = e.parents('.gsp_mpeople').length === 0 ? null : getTagValue(e);
                        window.location.href = Utils.GetUrl(window.location.href, { title: null, tag: tagValue, people: peopleValue, search: null, latest: null, filter: null, rating: null, top: null, aid: null, moid: null });
                    },
                    selectionAdded: function (e) {
                        if (initComplete) {
                            e.addClass('gsp_wait_spinner');
                            var newTag = e.contents()
                                .filter(function (idx2, el2) { return (el2.nodeType === 3); })
                                .text().trim();
                            var metaTypeId = _this.getMetaItem(e.closest('.gsp_mRowDtl').data('id')).MTypeId;
                            var galleryItemMeta = { GalleryItems: _this.data.ActiveGalleryItems, MetaItem: { MTypeId: metaTypeId, Value: newTag } };
                            DataService.saveMeta(galleryItemMeta, function () { e.removeClass('gsp_wait_spinner'); }, function (gim) {
                                // Success callback - Ajax request to save tag/person completed. Check for validation and other errors and respond accordingly
                                switch (gim.ActionResult.Status) {
                                    case 'Success':
                                    case 'Info':
                                    case 'Warning':
                                        if (_this.data.MediaItem != null) {
                                            // When showing a single media object, update the data object's meta value so it is available during next/previous browsing
                                            var mi = Utils.findMetaItem(_this.data.MediaItem.MetaItems, gim.MetaItem.MTypeId);
                                            if (mi != null)
                                                mi.Value += ', ' + gim.MetaItem.Value;
                                        }
                                        if (_this.data.ActiveGalleryItems.length > 1) {
                                            // Append the count to the end of the tag value showing how many of the selected items have that tag (e.g. "Vacation (12)")
                                            var textNode = e.contents().filter(function (idx3, el3) { return el3.nodeType === 3; })[0];
                                            textNode.textContent = textNode.textContent + ' (' + _this.data.ActiveGalleryItems.length + ')';
                                        }
                                        // Uncomment the following to trigger the metaUpdata event in the media or thumbnail view. We have it commented out because it
                                        // causes the media/thumbnail view to be re-rendered, triggering a flash, and serving no useful purpose in a stock installation.
                                        //$(`#${me.data.Settings.MediaClientId}`).trigger(`metaUpdate.${me.data.Settings.ClientId}`, [gim]);
                                        //$(`#${me.data.Settings.ThumbnailClientId}`).trigger(`metaUpdate.${me.data.Settings.ClientId}`, [gim]);
                                        break;
                                }
                                if (gim.ActionResult.Status !== 'Success') {
                                    Msg.show(gim.ActionResult.Title, gim.ActionResult.Message, { msgType: gim.ActionResult.Status.toLowerCase(), autoCloseDelay: 0 });
                                }
                            }, function (jqXHR) {
                                Msg.show('Cannot Save Changes', Utils.parseJqXhrMsg(jqXHR), { msgType: 'error', autoCloseDelay: 0 });
                            });
                        }
                    },
                    selectionRemoved: function (e) {
                        e.animate({ opacity: .2 }, 'slow', function () { e.addClass('gsp_wait_spinner'); });
                        // Get the tag value, stripping off trailing count if present. Ex: If tag="Animal (3)", change it to "Animal".
                        var newTag = getTagValue(e);
                        var metaTypeId = _this.getMetaItem(e.closest('.gsp_mRowDtl').data('id')).MTypeId;
                        var galleryItemMeta = { GalleryItems: _this.data.ActiveGalleryItems, MetaItem: { MTypeId: metaTypeId, Value: newTag } };
                        DataService.deleteMeta(galleryItemMeta, null, function () {
                            // Success callback
                            e.remove();
                            if (_this.data.MediaItem != null) {
                                // When showing a single media object, update the data object's meta value so it is available during next/previous browsing
                                var mi = Utils.findMetaItem(_this.data.MediaItem.MetaItems, metaTypeId);
                                if (mi != null) {
                                    // Remove the tag from the comma separated list of tags
                                    mi.Value = $.grep(mi.Value.split(/\s*,\s*/), function (tag, i) { return (tag !== newTag); }).join(', ');
                                }
                            }
                            $("#" + _this.data.Settings.MediaClientId).trigger("metaUpdate." + _this.data.Settings.ClientId, [galleryItemMeta]);
                            $("#" + _this.data.Settings.ThumbnailClientId).trigger("metaUpdate." + _this.data.Settings.ClientId, [galleryItemMeta]);
                        }, function (jqXHR) {
                            Msg.show('Cannot Save Changes', Utils.parseJqXhrMsg(jqXHR), { msgType: 'error', autoCloseDelay: 0 });
                        });
                    }
                });
                initComplete = true;
            });
        };
        GsMeta.prototype.getMetaItem = function (id) {
            // Find the meta item with the specified ID.
            return $.grep(this.data.ActiveMetaItems, function (mi) { return (mi.Id === id); })[0];
        };
        GsMeta.prototype.showMeta = function (e, gItems) {
            var _this = this;
            // gItems is an array of GalleryItem objects. It should be the same reference as data.ActiveGalleryItems
            this.$target.addClass('gsp_wait'); // Show wait animated gif
            // Are we showing the meta for the current media item?
            var showMetaForMediaItem = (gItems != null) && (gItems.length === 1) && (gItems[0].ItemType !== Enums.ItemType.Album) && (this.data.MediaItem != null) && (this.data.MediaItem.Id === gItems[0].Id);
            if (showMetaForMediaItem && this.data.MediaItem.MetaItems) {
                // We already have the meta items on the client, so grab them, bind and return (no need to get them from server).
                this.data.ActiveMetaItems = this.data.MediaItem.MetaItems;
                this.bindData();
                return;
            }
            if (gItems == null || gItems.length < 1) {
                // No gallery items have been passed. It is not expected that we'll get here, but just in case, clear out the active
                // meta items and re-bind.
                this.data.ActiveMetaItems = [];
                this.bindData();
            }
            else if (gItems.length === 1) {
                // A single gallery item is selected.
                var i = gItems[0];
                if (i.Id === Constants.IntMinValue) {
                    // User is viewing a virtual album and clicked in the album area. Bind to the meta items we already have on the client.
                    this.data.ActiveMetaItems = this.data.Album.MetaItems;
                    this.bindData();
                }
                else {
                    // Get meta items from server and show.
                    var gt = (i.ItemType === Enums.ItemType.Album ? 'albums' : 'mediaitems');
                    var url = Vars.AppRoot + '/api/' + gt + '/' + i.Id + '/meta';
                    DataService.getAsJson(url, null, null, function (metaItems) {
                        // Success callback
                        _this.data.ActiveMetaItems = metaItems;
                        if (_this.data.MediaItem != null) {
                            _this.data.MediaItem.MetaItems = metaItems;
                        }
                        _this.bindData();
                    }, function (jqXHR) {
                        _this.$target.removeClass('gsp_wait');
                        Msg.show('Cannot Retrieve Data From Server', Utils.parseJqXhrMsg(jqXHR), { msgType: 'error', autoCloseDelay: 0 });
                    });
                }
            }
            else {
                // More than one gallery item has been passed. Send the items to the server so we can get a merged list of meta.
                DataService.getMeta(gItems, null, function (metaItems) {
                    _this.data.ActiveMetaItems = metaItems;
                    if (_this.data.MediaItem != null)
                        _this.data.MediaItem.MetaItems = metaItems;
                    _this.bindData();
                }, function (jqXHR) {
                    Msg.show('Cannot Retrieve Data', Utils.parseJqXhrMsg(jqXHR), { msgType: 'error', autoCloseDelay: 0 });
                });
            }
        };
        return GsMeta;
    }());
    //#endregion
    //#region gs.gsHeader widget
    $.widget('gs.gsHeader', {
        options: {
            clientId: ''
        },
        _create: function () {
            this.gsHeader = new GsHeader(this.element, Vars[this.options.clientId].gsData);
            this.gsHeader.initialize();
        }
    });
    //#endregion gs.gsHeader widget
    //#region gsHeader class
    var GsHeader = /** @class */ (function () {
        function GsHeader(target, data) {
            var _this = this;
            this.viewSizeClick = function (e) {
                var $trigger = $(e.currentTarget).parent().siblings('.gs_rbn_hm_vs').removeClass('gs_rbn_tab_slctd').end().addClass('gs_rbn_tab_slctd');
                // Handle event when user selects a new size from the media view size dropdown under the view all ribbon button. Update UI so
                // requested media asset size is displayed.
                var viewSize = parseInt($trigger.data('size'), 10);
                if (viewSize === _this.data.Settings.MediaViewSize) {
                    return true; // Nothing has changed, so just return
                }
                _this.data.Settings.MediaViewSize = viewSize;
                // Replace the current media item with the requested size, plus preload any images in the album.
                $("#" + _this.data.Settings.MediaClientId).gsMedia('render').gsMedia('preloadImages'); // Has no effect when on thumbnails page
                _this.data.User.GalleryId = _this.data.Album.GalleryId;
                _this.data.User.MediaViewSize = _this.data.Settings.MediaViewSize;
                _this.data.User.SlideShowType = _this.data.Settings.SlideShowType;
                _this.data.User.SlideShowLoop = _this.data.Settings.SlideShowLoop;
                DataService.saveCurrentUserProfile(_this.data.User, null, null, function (jqXHR) {
                    Msg.show('Could not update user profile', Utils.parseJqXhrMsg(jqXHR), { msgType: 'error', autoCloseDelay: 0 });
                });
                return true; // Allow event bubbling so other dialogs can be closed if they are open
            };
            this.selectClick = function (e) {
                // User clicked 'All' or 'None'. Select or deselect thumbnails.
                var action = $(e.currentTarget).data('action') === 'select' ? 'selectThumbnails' : 'deselectThumbnails';
                $("#" + _this.data.Settings.ThumbnailClientId).gsThumbnails(action);
                return true; // Allow event bubbling so other dialogs can be closed if they are open
            };
            this.slideShowOptionsClick = function (e) {
                var $trigger = $(e.currentTarget).addClass('gs_rbn_tab_slctd');
                var $dg = $('.gs_rbn_hm_ss_mr_dlg', _this.$target);
                if ($dg.is(':ui-dialog')) {
                    if ($dg.dialog('isOpen')) {
                        $dg.dialog('close');
                        $trigger.removeClass('gs_rbn_tab_slctd').find('.fa').removeClass('fa-rotate-180');
                        return false;
                    }
                }
                else {
                    // First time user clicked 'more' button. Wire up events.
                    $('.gs_rbn_mr_dlg_ss_type', $dg).on('change', function (e1) {
                        // Handle event when user selects a new slide show type under the slide show ribbon button.
                        _this.data.Settings.SlideShowType = parseInt(e1.currentTarget.value, 10);
                        _this.data.User.GalleryId = _this.data.Album.GalleryId;
                        _this.data.User.MediaViewSize = _this.data.Settings.MediaViewSize;
                        _this.data.User.SlideShowType = _this.data.Settings.SlideShowType;
                        _this.data.User.SlideShowLoop = _this.data.Settings.SlideShowLoop;
                        DataService.saveCurrentUserProfile(_this.data.User, null, null, function (jqXHR) {
                            Msg.show('Could not update user profile', Utils.parseJqXhrMsg(jqXHR), { msgType: 'error', autoCloseDelay: 0 });
                        });
                        return true;
                    });
                    $('.gs_rbn_mr_dlg_ss_loop', $dg).on('click', function (e1) {
                        // Handle event when user toggles the loop checkbox under the slide show ribbon button.
                        _this.data.Settings.SlideShowLoop = $(e1.currentTarget).prop('checked');
                        _this.data.User.GalleryId = _this.data.Album.GalleryId;
                        _this.data.User.MediaViewSize = _this.data.Settings.MediaViewSize;
                        _this.data.User.SlideShowType = _this.data.Settings.SlideShowType;
                        _this.data.User.SlideShowLoop = _this.data.Settings.SlideShowLoop;
                        DataService.saveCurrentUserProfile(_this.data.User, null, null, function (jqXHR) {
                            Msg.show('Could not update user profile', Utils.parseJqXhrMsg(jqXHR), { msgType: 'error', autoCloseDelay: 0 });
                        });
                        return true;
                    });
                }
                $dg.dialog({
                    appendTo: "#" + _this.data.Settings.HeaderClientId,
                    autoOpen: true,
                    draggable: false,
                    resizable: false,
                    closeOnEscape: true,
                    classes: { 'ui-dialog': 'gs_rbn_mr_dlg_container' },
                    width: 320,
                    minHeight: 0,
                    show: 'fade',
                    hide: 'fade',
                    position: { my: "left top", at: "left bottom", of: $trigger },
                    open: function (e1, ui) {
                        $(document).on('click', function (e2) {
                            // We want to close the dialog for any click outside the dialog or the 'more' button
                            if ($(e2.target).parents('.gs_rbn_mr_dlg_container,.gs_rbn_hm_ss').length === 0) {
                                $dg.dialog('close');
                                $trigger.removeClass('gs_rbn_tab_slctd').find('.fa').removeClass('fa-rotate-180');
                                $(document).unbind(e2);
                            }
                        });
                    },
                    close: function (e1, ui) {
                        // Revert arrow. We don't really need this code in the other two places, but we leave them there because this event has a noticable lag to it (at least in Chrome)
                        $trigger.removeClass('gs_rbn_tab_slctd').find('.fa').removeClass('fa-rotate-180');
                    }
                });
                $('.fa', $trigger).addClass('fa-rotate-180');
                return true; // Allow event bubbling so other dialogs can be closed if they are open
            };
            this.slideShowClick = function (e) {
                if (_this.data.Settings.SlideShowIsRunning) {
                    $("#" + _this.data.Settings.MediaClientId).gsMedia('stopSlideshow');
                    $('.gs_rbn_hm_ss_icon', $(e.currentTarget)).removeClass('fa-pause').addClass('fa-eject fa-rotate-90');
                }
                else if (_this.data.MediaItem != null) {
                    // User on media view page, so start slide show
                    $("#" + _this.data.Settings.MediaClientId).gsMedia('startSlideshow');
                    if (_this.data.Settings.SlideShowIsRunning && _this.data.Settings.SlideShowType === Enums.SlideShowType.Inline) {
                        // Change slide show icon to 'pause' icon. This isn't needed for fullscreen slideshows.
                        $('.gs_rbn_hm_ss_icon', $(e.currentTarget)).removeClass('fa-eject fa-rotate-90').addClass('fa-pause');
                    }
                }
                else {
                    // User on thumbnail page, so send the user to the media view page of the first image in this album, including
                    // the 'ss=1' query string parm that will trigger an auto slide show when the page loads.
                    var findFirstImage = function () {
                        if (_this.data.Album != null && _this.data.Album.GalleryItems != null)
                            return $.grep(_this.data.Album.GalleryItems, function (gi) { return (gi.ItemType === Enums.ItemType.Image); })[0];
                        else
                            return null;
                    };
                    var img = findFirstImage();
                    if (img != null) {
                        var qs = { aid: null, moid: null, ss: '1' };
                        qs.moid = img.Id;
                        window.location.href = Utils.GetUrl(document.location.href, qs);
                    }
                    else
                        Msg.show(_this.data.Resource.MoNoSsHdr, _this.data.Resource.MoNoSsBdy, { msgType: 'info' });
                }
                return true; // Allow event bubbling so other dialogs can be closed if they are open
            };
            this.downloadClick = function (e) {
                var $trigger = $(e.currentTarget).addClass('gs_rbn_tab_slctd');
                var $dg = $('.gs_rbn_hm_dl_mr_dlg', _this.$target);
                if ($dg.is(':ui-dialog')) {
                    if ($dg.dialog('isOpen')) {
                        $dg.dialog('close');
                        $trigger.removeClass('gs_rbn_tab_slctd');
                        return false;
                    }
                }
                else {
                    // First time user clicked 'Download' button. Wire up events.
                    $('.chkCheckUncheckAll', $dg).on('click', _this.toggleThumbnailSelection);
                    $('.gs_rbn_hm_dl_btn', $dg).button();
                    $('.gs_rbn_hm_dl_btn', $dg).click(function (e1) {
                        // User clicked 'download media asset button'. If a single media asset is selected, give that to user as a simple download.
                        // If more than one media asset or an album is selected, give the user a zip file.
                        // If no thumbnail has been selected, inform user
                        if (document.getElementById(_this.data.Settings.ThumbnailClientId) !== null && $("#" + _this.data.Settings.ThumbnailClientId + " .thmb.ui-selected").length === 0) {
                            Msg.show('No Thumbnail Selected', 'Select one or more thumbnails and try again.', { msgType: 'warning' });
                            return false;
                        }
                        var mediaSize = parseInt($('.gs_rbn_mr_dlg_mv_size', $dg).val(), 10);
                        if (_this.data.ActiveGalleryItems.length === 1 && _this.data.ActiveGalleryItems[0].ItemType !== Enums.ItemType.Album) {
                            // Single media asset selected.
                            var mi = _this.data.ActiveGalleryItems[0];
                            if (mi.ItemType === Enums.ItemType.External && mediaSize !== Enums.ViewSize.Thumbnail) {
                                Msg.show('Download not available', 'External media objects cannot be downloaded. However, the source HTML can be accessed in the right pane.', { msgType: 'info', autoCloseDelay: 0 });
                            }
                            else {
                                // Get URL from the desired media size, then append sa=1 to it
                                var assetView = Utils.getView(mi, mediaSize);
                                document.location.href = assetView.Url + "&sa=1";
                                $dg.dialog('close');
                                $trigger.removeClass('gs_rbn_tab_slctd');
                            }
                        }
                        else {
                            // Either an album or multiple items are selected. Use zip processor. We have to make 2 API calls, the first is a POST to generate the zip.
                            // The 2nd is a GET request we can assign to document.location.href. (We could've used 1 call if we could send all our data in a GET request.)
                            $(e1.currentTarget).siblings('.gs_rbn_hm_dl_btn_lbl').toggleClass('gsp_invisible');
                            DataService.prepareZipDownload(_this.data.ActiveGalleryItems, mediaSize, function () {
                                // DONE callback
                                $(e1.currentTarget).siblings('.gs_rbn_hm_dl_btn_lbl').toggleClass('gsp_invisible');
                                $dg.dialog('close');
                                $trigger.removeClass('gs_rbn_tab_slctd');
                            }, function (actionResult) {
                                // SUCCESS callback - Ajax request to generate ZIP successfull. Check for validation and other errors and respond accordingly
                                switch (actionResult.Status) {
                                    case 'Success':
                                        document.location.href = Utils.AddQSParm(Vars.AppRoot + '/api/mediaitems/downloadzip', 'filename', actionResult.ActionTarget);
                                        break;
                                    default:
                                        Msg.show(actionResult.Title, actionResult.Message, { msgType: actionResult.Status.toLowerCase(), autoCloseDelay: 0 });
                                        break;
                                }
                            }, function (jqXHR) {
                                Msg.show('Cannot Download', Utils.parseJqXhrMsg(jqXHR), { msgType: 'error', autoCloseDelay: 0 });
                            });
                        }
                        return false;
                    });
                }
                $dg.dialog({
                    appendTo: "#" + _this.data.Settings.HeaderClientId,
                    autoOpen: true,
                    draggable: false,
                    resizable: false,
                    closeOnEscape: true,
                    classes: { 'ui-dialog': 'gs_rbn_mr_dlg_container' },
                    width: 320,
                    minHeight: 0,
                    show: 'fade',
                    hide: 'fade',
                    position: { my: 'left top', at: 'left bottom', of: $trigger },
                    open: function (e1, ui) {
                        $(document).on('click', function (e2) {
                            // We want to close the dialog for any click outside the dialog or the 'more' button
                            if ($(e2.target).parents('.gs_rbn_mr_dlg_container,.gs_rbn_hm_dl').length === 0) {
                                $dg.dialog('close');
                                $trigger.removeClass('gs_rbn_tab_slctd');
                                $(document).unbind(e2);
                            }
                        });
                    },
                    close: function (e1, ui) {
                        $trigger.removeClass('gs_rbn_tab_slctd');
                    }
                });
                return true; // Allow event bubbling so other dialogs can be closed if they are open
            };
            this.shareClick = function (e) {
                var $trigger = $(e.currentTarget).addClass('gs_rbn_tab_slctd');
                var $dg = $('.gs_rbn_hm_sh_mr_dlg', _this.$target);
                if ($dg.is(':ui-dialog')) {
                    if ($dg.dialog('isOpen')) {
                        $dg.dialog('close');
                        $trigger.removeClass('gs_rbn_tab_slctd');
                        return false;
                    }
                }
                //else {
                //    // First time user clicked 'Share' button. Wire up events.
                //}
                // Update URL & embed code to current values
                var hdr;
                var thisAssetUrl = null;
                var thisPageUrl;
                var embedCode = null;
                if (_this.data.ActiveGalleryItems.length === 1) {
                    // One item is active. Get URL to it.
                    var gi = _this.data.ActiveGalleryItems[0];
                    var albumOrAsset = gi.IsAlbum ? _this.data.Resource.RbnShAbm : _this.data.Resource.RbnShAsset;
                    if (gi.IsAlbum) {
                        thisPageUrl = Utils.GetAlbumExternalUrl(gi.Id);
                    }
                    else {
                        embedCode = Utils.GetEmbedCode(gi.Id);
                        var assetView = Utils.getView(_this.data.ActiveGalleryItems[0], _this.data.Settings.MediaViewSize);
                        if (assetView != null) {
                            thisAssetUrl = assetView.Url;
                        }
                        thisPageUrl = Utils.GetMediaExternalUrl(gi.Id);
                    }
                    hdr = albumOrAsset + " <span class='gsp_vibrant'>" + gi.Title + "</span>";
                }
                else {
                    // Multiple items are selected. Get URL to parent album instead.
                    thisPageUrl = Utils.GetAlbumExternalUrl(_this.data.Album.Id);
                    hdr = _this.data.Resource.RbnShAbm + " <span class='gsp_vibrant'>" + _this.data.Album.Title + "</span>";
                }
                $('.gs_rbn_mr_dlg_sh_hdr').html(hdr);
                $('.gs_rbn_mr_dlg_sh_ipt_url', $dg).val(thisPageUrl);
                if (thisAssetUrl != null) {
                    $('.gs_rbn_mr_dlg_asset_sh_ipt_url', $dg).val(thisAssetUrl);
                    $('.gs_rbn_mr_dlg_sh_asset_pg_hdr,.gs_rbn_mr_dlg_sh_asset_pg_dtl', $dg).show();
                }
                else {
                    $('.gs_rbn_mr_dlg_sh_asset_pg_hdr,.gs_rbn_mr_dlg_sh_asset_pg_dtl', $dg).hide();
                }
                if (embedCode != null) {
                    $('.gs_rbn_mr_dlg_sh_ipt_embed', $dg).text(embedCode);
                    $('.gs_rbn_mr_dlg_sh_html_hdr,.gs_rbn_mr_dlg_sh_html_dtl', $dg).show();
                }
                else {
                    $('.gs_rbn_mr_dlg_sh_html_hdr,.gs_rbn_mr_dlg_sh_html_dtl', $dg).hide();
                }
                $dg.dialog({
                    appendTo: "#" + _this.data.Settings.HeaderClientId,
                    autoOpen: true,
                    draggable: false,
                    resizable: false,
                    closeOnEscape: true,
                    classes: { 'ui-dialog': 'gs_rbn_mr_dlg_container' },
                    width: Utils.isWidthLessThan(420) ? Utils.getViewportWidth() : 420,
                    minHeight: 0,
                    show: 'fade',
                    hide: 'fade',
                    position: { my: 'left top', at: 'left bottom', of: $trigger },
                    open: function (e1, ui) {
                        $(document).on('click', function (e2) {
                            // We want to close the dialog for any click outside the dialog or the 'more' button
                            if ($(e2.target).parents('.gs_rbn_mr_dlg_container,.gs_rbn_hm_sh').length === 0) {
                                $dg.dialog('close');
                                $trigger.removeClass('gs_rbn_tab_slctd');
                                $(document).unbind(e2);
                            }
                        });
                    },
                    close: function (e1, ui) {
                        $trigger.removeClass('gs_rbn_tab_slctd');
                    },
                    create: function (e1, ui) { }
                });
                return true; // Allow event bubbling so other dialogs can be closed if they are open
            };
            this.sortClick = function (e) {
                var $trigger = $(e.currentTarget).addClass('gs_rbn_tab_slctd');
                var $dg = $('.gs_rbn_hm_st_mr_dlg', _this.$target);
                if ($dg.is(':ui-dialog')) {
                    if ($dg.dialog('isOpen')) {
                        $dg.dialog('close');
                        $trigger.removeClass('gs_rbn_tab_slctd');
                        return false;
                    }
                }
                else {
                    // First time user clicked 'Sort' button. Wire up events.
                    $(".gs_rbn_mr_dlg_st_btn_group a[data-sortup=" + _this.data.Album.SortUp + "]", $dg).addClass('gs_rbn_mr_dlg_st_sltd');
                    var sortAlbum = function () {
                        var persistToAlbum = (_this.data.Album.Permissions.EditAlbum && _this.data.Album.VirtualType === Enums.VirtualAlbumType.NotVirtual);
                        $('.gs_rbn_mr_dlg_st_mi_ctr .fa').removeClass('fa-check').parent().filter("[data-id=" + _this.data.Album.SortById + "]").find('.fa').addClass('fa-spinner fa-spin');
                        var album = Utils.deepCopy(_this.data.Album);
                        // Save bandwidth by lightening up our object. Keep the gallery items for virtual albums, though, because those are what the server will be sorting.
                        if (_this.data.Album.VirtualType === Enums.VirtualAlbumType.NotVirtual) {
                            album.GalleryItems = null;
                        }
                        album.MediaItems = null;
                        album.MetaItems = null;
                        album.Permissions = null;
                        DataService.sortAlbum(album, persistToAlbum, function () {
                            // DONE
                            $(".gs_rbn_mr_dlg_st_mi_ctr a[data-id=" + _this.data.Album.SortById + "] .fa").removeClass('fa-spinner fa-spin').addClass('fa-check');
                            $dg.dialog('close');
                            $trigger.removeClass('gs_rbn_tab_slctd');
                        }, function (galleryItems) {
                            // SUCCESS
                            if (_this.data.Album.GalleryItems != null) {
                                _this.data.Album.GalleryItems = galleryItems;
                                $("#" + _this.data.Settings.ThumbnailClientId).gsThumbnails('renderThumbnails'); // No effect in media view
                            }
                        }, function (jqXHR) {
                            Msg.show('Cannot Sort', Utils.parseJqXhrMsg(jqXHR), { msgType: 'error', autoCloseDelay: 0 });
                        });
                    };
                    $('.gs_rbn_mr_dlg_st_btn', $dg).click(function (e1) {
                        // User clicked a sort direction (up or down). Highlight the selected sort direction and carry out the sort.
                        $(e1.currentTarget).addClass('gs_rbn_mr_dlg_st_sltd').siblings().removeClass('gs_rbn_mr_dlg_st_sltd');
                        var sortUp = $(e1.currentTarget).data('sortup');
                        if (_this.data.Album.SortUp !== sortUp) {
                            _this.data.Album.SortUp = sortUp;
                            sortAlbum();
                        }
                        return false;
                    });
                    // Configure the sort fields as a menu and handle the select event.
                    $('.gs_rbn_mr_dlg_st_mi_ctr', $dg).menu({
                        select: function (e1, ui) {
                            var sortById = ui.item.find('a').data('id');
                            if (sortById != null) {
                                _this.data.Album.SortById = sortById; // Get the sort ID (e.g. <li><a href='#' data-id='29'>Title</a></li>)
                                sortAlbum();
                            }
                        }
                    })
                        .find("a[data-id=" + _this.data.Album.SortById + "] .fa").addClass('fa-check'); // Add a checkbox to the current sort field
                }
                $dg.dialog({
                    appendTo: "#" + _this.data.Settings.HeaderClientId,
                    autoOpen: true,
                    draggable: false,
                    resizable: false,
                    closeOnEscape: true,
                    classes: { 'ui-dialog': 'gs_rbn_mr_dlg_container' },
                    width: 320,
                    minHeight: 0,
                    show: 'fade',
                    hide: 'fade',
                    position: { my: 'left top', at: 'left bottom', of: $trigger },
                    open: function (e1, ui) {
                        $(document).on('click', function (e2) {
                            // We want to close the dialog for any click outside the dialog or the 'more' button
                            if ($(e2.target).parents('.gs_rbn_mr_dlg_container,.gs_rbn_hm_st').length === 0) {
                                $dg.dialog('close');
                                $trigger.removeClass('gs_rbn_tab_slctd');
                                $(document).unbind(e2);
                            }
                        });
                    },
                    close: function (e1, ui) {
                        $trigger.removeClass('gs_rbn_tab_slctd');
                    }
                });
                return true; // Allow event bubbling so other dialogs can be closed if they are open
            };
            this.createAlbumClick = function (e) {
                var $btn = $(e.currentTarget);
                if ($btn.hasClass('gs_rbn_tab_slctd'))
                    return false;
                else
                    $btn.addClass('gs_rbn_tab_slctd');
                if ($btn.parents('.gs_rbn_tab').hasClass('gsp_disabled'))
                    return false;
                var renderThmbView = function () {
                    $("#" + _this.data.Settings.ThumbnailClientId).gsThumbnails('renderThumbnails');
                };
                var thmbUrl = Vars.AppRoot + '/' + Vars.GalleryResourcesRoot + '/handler/getmedia.ashx?moid=0&dt=1&g=' + _this.data.Album.GalleryId;
                var thmb = { Width: _this.data.Settings.EmptyAlbumThmbWidth, Height: _this.data.Settings.EmptyAlbumThmbHeight, ViewSize: Enums.ViewSize.Thumbnail, ViewType: Enums.MimeType.Image, Url: thmbUrl };
                var emptyAlbum = { Id: 0, ParentId: 0, IsAlbum: true, MimeType: 0, ItemType: Enums.ItemType.Album, NumAlbums: 0, NumMediaItems: 0, Caption: '', Title: _this.data.Resource.AbmDefTitle, ViewIndex: 0, Views: [thmb] };
                _this.data.Album.GalleryItems.splice(0, 0, emptyAlbum);
                renderThmbView();
                // Configure editor in plain text mode for album title. There are a few issues with trying to use HTML mode here (thumbnails are designed not to
                // render HTML, narrow thumbnail width, broken behavior for certain commands like bullet lists), so we stick with plain text editor.
                tinyMCE.init({
                    menubar: false,
                    inline: true,
                    skin: _this.data.App.Skin,
                    selector: "#" + _this.data.Settings.ThumbnailClientId + " .gsp_abm_thmbs li:first .gsp_go_t",
                    toolbar: false,
                    forced_root_block: false,
                    setup: function (editor) {
                        editor.on('focus', function (focusEv) {
                            Utils.selectElementContents(focusEv.target.targetElm);
                        });
                        editor.on('blur', function (blurEv) {
                            var tinyMceEditor = tinyMCE.get(blurEv.target.id);
                            // Create new album
                            var album = { Title: tinyMceEditor.getContent({ format: 'text' }), ParentId: _this.data.Album.Id, GalleryId: _this.data.Album.GalleryId };
                            var $parentCell = $(blurEv.target.targetElm).addClass('gsp_wait_center');
                            DataService.createAlbum(album, function () { $parentCell.removeClass('gsp_wait_center'); }, function (actionResult) {
                                // Success callback - Ajax request to save meta property completed. Check for validation and other errors and respond accordingly
                                switch (actionResult.Status) {
                                    case 'Success':
                                    case 'Info':
                                    case 'Warning':
                                        {
                                            $btn.removeClass('gs_rbn_tab_slctd');
                                            var a = _this.data.Album.GalleryItems[0]; // Get reference to album
                                            a.Title = actionResult.ActionTarget.Title; // Update title (which may have been changed by the server (e.g. HTML removed))
                                            a.Id = actionResult.ActionTarget.Id;
                                            // Re-render, which updates the HTML (like the data-id on the li element) and the link to the album
                                            renderThmbView();
                                            // Add new album to album tree in left pane
                                            var $albumTree = $("#" + _this.data.Settings.ClientId + "_lptv").jstree(true);
                                            if ($albumTree) {
                                                $albumTree.create_node($albumTree.get_selected()[0], { text: a.Title, state: { opened: true }, a_attr: { href: Utils.GetAlbumUrl(a.Id), title: a.Title }, li_attr: { id: "tv_" + a.Id, 'data-id': a.Id } }, 'first');
                                                $albumTree.open_node($albumTree.get_selected()[0]);
                                            }
                                            break;
                                        }
                                    case 'Error':
                                        _this.data.Album.GalleryItems.gspRemove(0);
                                        renderThmbView();
                                        break;
                                }
                                if (actionResult.Status !== 'Success') {
                                    Msg.show(actionResult.Title, actionResult.Message, { msgType: actionResult.Status.toLowerCase(), autoCloseDelay: 0 });
                                }
                            }, function (jqXHR) {
                                _this.data.Album.GalleryItems.gspRemove(0);
                                renderThmbView();
                                Msg.show('Cannot Save Changes', Utils.parseJqXhrMsg(jqXHR), { msgType: 'error', autoCloseDelay: 0 });
                            });
                        });
                        editor.on('keydown', (function (keydownEv) {
                            var tinyMceEditor = tinyMCE.get(keydownEv.target.id);
                            if (keydownEv.keyCode === Enums.KeyCode.Escape) {
                                tinyMceEditor.destroy();
                                $btn.removeClass('gs_rbn_tab_slctd');
                                _this.data.Album.GalleryItems.gspRemove(0);
                                renderThmbView();
                                return false;
                            }
                            else if (keydownEv.keyCode === Enums.KeyCode.Enter) {
                                tinyMceEditor.targetElm.blur();
                                return false;
                            }
                            return true;
                        }));
                    },
                    init_instance_callback: (function (editor) {
                        // Activate tinyMCE by giving it the focus
                        $("#" + _this.data.Settings.ThumbnailClientId + " .gsp_abm_thmbs li:first .gsp_go_t").focus();
                    })
                });
                return true; // Allow event bubbling so other dialogs can be closed if they are open
            };
            this.transferToAlbumClick = function (e) {
                var $trigger = $(e.currentTarget);
                if ($(e.currentTarget).parents('.gs_rbn_tab').hasClass('gsp_disabled'))
                    return false;
                // User clicked 'move to' or 'copy to' button. Show album tree and move/copy selected items to album when a node is selected.
                var $dg = $('.gs_rbn_mng_mt_tv_dlg', _this.$target);
                // If tree and dialog haven't yet been generated, do so now.
                if ($dg.length === 0) {
                    $dg = $("<div class='gs_rbn_mng_mt_tv_dlg gsp_dlg'><div class='gs_am_rbn_mt_tv'><div class='gsp_textcenter'><span class='fa fa-2x fa-spinner fa-pulse'></span></div></div></div>");
                    $dg.dialog({
                        appendTo: "#" + _this.data.Settings.HeaderClientId,
                        autoOpen: false,
                        draggable: false,
                        resizable: false,
                        closeOnEscape: true,
                        classes: { 'ui-dialog': 'gs_rbn_mr_dlg_container' },
                        width: Utils.isWidthLessThan(420) ? Utils.getViewportWidth() : 420,
                        minHeight: 0,
                        show: 'fade',
                        hide: 'fade',
                        //position: { my: "left top", at: "left bottom", of: $btn },
                        open: function (e1, ui) {
                            $(document).on('click', function (e2) {
                                // We want to close the dialog for any click outside the dialog
                                if ($(e2.target).parents('.gs_rbn_mr_dlg_container,.gs_rbn_mng_mt,.gs_rbn_mng_ct').length === 0) {
                                    $dg.dialog('close');
                                    $trigger.removeClass('gs_rbn_tab_slctd');
                                    $(document).unbind(e2);
                                }
                            });
                        }
                    });
                    // Call the gsTreeView plug-in, which adds an album treeview
                    var treeOptions = {
                        galleryId: (_this.data.Album.Permissions.AdministerSite || _this.data.Album.Permissions.AdministerGallery ? 'all' : _this.data.Album.GalleryId),
                        containerClientId: _this.data.Settings.ClientId,
                        treeDataUrl: Vars.GalleryResourcesRoot + '/handler/gettreeview.ashx',
                        requiredSecurityPermissions: Enums.SecurityActions.AddChildAlbum | Enums.SecurityActions.AddMediaObject,
                        albumIdsToSelect: _this.data.Album.Id
                    };
                    $('.gs_am_rbn_mt_tv', $dg).gsTreeView(null, treeOptions);
                    $('.gs_am_rbn_mt_tv', $dg).on('changed.jstree', function (e, nodeData) {
                        if (nodeData.action === 'select_node') {
                            // Add spinner icon to the right of the album text (this is removed in the complete callback below)
                            $(nodeData.event.currentTarget).append("<span class='fa fa-spinner fa-pulse gsp_addleftmargin3'></span>");
                            var transferType = _this.$target.data('transfertype'); // moveTo or copyTo. Must match Gs.DataService method.
                            var destAlbumId = parseInt(nodeData.node.li_attr['data-id'], 10);
                            // Get selected thumbnails and call API for moving or copying items
                            DataService[transferType](destAlbumId, _this.data.ActiveGalleryItems, function () {
                                // Always callback - remove spinner icon
                                $(nodeData.event.currentTarget).find('.fa-spinner').remove();
                            }, function (actionResult, ajaxResult, ajaxObj) {
                                // Success callback - Ajax request to move/copy items successfully completed. Check for validation and other errors and respond accordingly
                                switch (actionResult.Status) {
                                    case 'Success':
                                        Msg.show(actionResult.Title, actionResult.Message, { msgType: 'success' });
                                        if (transferType === 'moveTo' && _this.data.Album.VirtualType === Enums.VirtualAlbumType.NotVirtual) {
                                            // We moved items from a physical album, so remove them from the client-side data and update the screen
                                            if (_this.data.MediaItem != null) {
                                                // Media view
                                                Utils.removeMediaItem(_this.data, _this.data.MediaItem);
                                                $("#" + _this.data.Settings.MediaClientId).gsMedia('showNextMediaObject');
                                            }
                                            else if (_this.data.Album.GalleryItems != null && destAlbumId !== _this.data.Album.Id) {
                                                // Thumbnail view - Remove items from current album and rebind, but only when the destination album is NOT the current album.
                                                Utils.removeGalleryItems(_this.data, _this.data.ActiveGalleryItems);
                                                // Select the current album so its metadata shows up in the right pane
                                                _this.data.ActiveGalleryItems = [Utils.convertAlbumToGalleryItem(_this.data.Album)];
                                                $("#" + _this.data.Settings.ThumbnailClientId).gsThumbnails('renderThumbnails');
                                            }
                                            // Since we have new ActiveGalleryItems, raise the select event, which will show their meta in the right pane
                                            $("#" + _this.data.Settings.ThumbnailClientId).trigger("select." + _this.data.Settings.ClientId, [_this.data.ActiveGalleryItems]);
                                        }
                                        else if (transferType === 'copyTo') {
                                            // If we copied items to the current album and we're on the thumbnail view, update the client-side data and refresh the thumbnails
                                            // This will pull in the newly copied items and ensure they are sorted correctly.
                                            if (destAlbumId === _this.data.Album.Id && _this.data.Album.GalleryItems != null) {
                                                DataService.getGalleryItems(_this.data.Album.Id, null, function (galleryItems) {
                                                    _this.data.Album.GalleryItems = galleryItems;
                                                    $("#" + _this.data.Settings.ThumbnailClientId).gsThumbnails('renderThumbnails');
                                                }, function (jqXHR) {
                                                    Msg.show('Action Aborted', Utils.parseJqXhrMsg(jqXHR), { msgType: 'error', autoCloseDelay: 0 });
                                                });
                                            }
                                        }
                                        break;
                                    default:
                                        Msg.show(actionResult.Title, actionResult.Message, { msgType: 'error', autoCloseDelay: 0 });
                                        break;
                                }
                                $dg.dialog('close');
                            }, function (jqXHR) {
                                Msg.show('Cannot Move Items', Utils.parseJqXhrMsg(jqXHR), { msgType: 'error', autoCloseDelay: 0 });
                            });
                        }
                    });
                }
                if ($dg.dialog('isOpen')) {
                    $dg.dialog('close');
                }
                else {
                    _this.$target.data('transfertype', $trigger.data('transfertype')); // Store moveTo or copyTo on instance property (we can't access it any other way from inside the changed.jstree event)
                    $dg.dialog('option', 'hide', null).dialog('close').dialog('option', 'hide', 'fade'); // Kill, then restore fade for quicker closing
                    $dg.dialog('option', 'position', { my: 'left top', at: 'left bottom', of: $trigger });
                    $dg.dialog('option', 'close', function () { $trigger.removeClass('gs_rbn_tab_slctd'); });
                    $dg.dialog('open');
                    $trigger.addClass('gs_rbn_tab_slctd');
                }
                return true; // Allow event bubbling so other dialogs can be closed if they are open
            };
            this.replaceFileClick = function (e) {
                var hdr;
                if (_this.data.ActiveGalleryItems.length === 1 && !_this.data.ActiveGalleryItems[0].IsAlbum) {
                    // One media asset is active. Display it's title.
                    hdr = _this.data.Resource.RbnShAsset + " <span class='gsp_vibrant'>" + _this.data.ActiveGalleryItems[0].Title + "</span>";
                    $('.gs_rbn_mr_dlg_rf_hdr').html(hdr);
                }
                else {
                    // Either more than one asset is selected or an album is selected. Replace is not supported in this scenario.
                    return false;
                }
                var $trigger = $(e.currentTarget).addClass('gs_rbn_tab_slctd');
                var $dg = $('.gs_rbn_mng_rf_mr_dlg', _this.$target);
                if ($dg.is(':ui-dialog')) {
                    if ($dg.dialog('isOpen')) {
                        $dg.dialog('close');
                        $trigger.removeClass('gs_rbn_tab_slctd');
                        return false;
                    }
                }
                else {
                    $('.gs_rbn_mng_rf_btn', $dg).button({
                        disabled: true
                    });
                    var configUploader = function () {
                        var applyButtonIcon = function (iconClasses) {
                            $('.gs_rbn_mng_rf_btn', $dg).siblings('.gs_rbn_mng_rf_btn_lbl').find('.fa').attr('class', iconClasses);
                        };
                        var addDropText = function () {
                            $('.plupload_droptext', $dg).html('Drag file here');
                        };
                        var removeDropText = function () {
                            $('.plupload_droptext', $dg).html('');
                        };
                        var onFileUpload = function (e3, args) {
                            // File has been transferred to the server; now call web service to replace media asset file with this one.
                            var mediaId = _this.data.ActiveGalleryItems[0].Id;
                            DataService.replaceMediaAssetFile(mediaId, args.file.target_name, args.file.name, function () {
                                // Done handler
                            }, function (actionResult) {
                                // Success handler. Check for validation and other errors. If none, refresh URL to show image as it now exists on server.
                                var msgOptions = { msgType: actionResult.Status.toLowerCase() };
                                if (actionResult.Status === 'Warning' || actionResult.Status === 'Error') {
                                    msgOptions.autoCloseDelay = 0;
                                }
                                if (actionResult.Message != null) {
                                    Msg.show(actionResult.Title, actionResult.Message, msgOptions);
                                }
                                if (actionResult.Status === 'Success') {
                                    // Grab a reference to either the media view img element or the thumbnail view img element
                                    var $imgEl = $("#" + _this.data.Settings.MediaClientId + " .gsp_mo_img, #" + _this.data.Settings.ThumbnailClientId + " .thmb[data-id=" + mediaId + "] .gsp_thmb_img");
                                    // Remove any previous width/height.
                                    $imgEl.add($imgEl.parents('.thmb')).css({ width: '', height: '' });
                                    // If we're on the thumbnail view, set the max width. Without this, when we call equalSize() thumbs with long captions will cause the thumbnails to expand to fit the caption on a single line.
                                    if ($("#" + _this.data.Settings.ThumbnailClientId).length > 0) {
                                        $imgEl.parents('.thmb').css({ 'max-width': (_this.data.Settings.MaxThumbnailLength + 40) + 'px' });
                                    }
                                    if ($imgEl.length > 0 && typeof $imgEl.attr('src') !== 'undefined') {
                                        // Force the browser to reload the image
                                        $imgEl[0].src += "&ver=" + new Date().getTime().toString();
                                        // When the image loads, update the thumbnail borders to reflect the latest width/height
                                        if (_this.data.Album.GalleryItems && !$imgEl[0].complete) {
                                            $imgEl.load(function () {
                                                var wBuffer = (_this.data.Album.GalleryItems.length > 1 ? 0 : 20); // We only need a buffer when there's 1 asset since the other thumbnails already include a buffer.
                                                $("#" + _this.data.Settings.ThumbnailClientId + " .thmb").equalSize(wBuffer, 0);
                                            });
                                        }
                                    }
                                    else if (_this.data.ActiveGalleryItems.length === 1) {
                                        // If we get here, no image element was found. We are probably on the single media view page looking at a non-image (video, etc).
                                        // Retrieve the asset from the server and re-render.
                                        DataService.getMediaAsset(_this.data.ActiveGalleryItems[0].Id, null, function (mediaItem) {
                                            // SUCCESS callback
                                            _this.data.MediaItem = mediaItem;
                                            $("#" + _this.data.Settings.MediaClientId).gsMedia('render');
                                        }, function (jqXHR) {
                                            Msg.show('Cannot Refresh Media Asset', Utils.parseJqXhrMsg(jqXHR), { msgType: 'error', autoCloseDelay: 0 });
                                        });
                                    }
                                    else {
                                        Msg.show('Cannot Refresh Media Asset', 'Refresh your browser to see the updated media asset.', { msgType: 'info', autoCloseDelay: 0 });
                                    }
                                    applyButtonIcon('fa fa-check gsp_msgfriendly');
                                }
                                else {
                                    applyButtonIcon('fa fa-close gsp_msgattention');
                                }
                            }, function (jqXHR) {
                                Msg.show('Cannot Replace File', Utils.parseJqXhrMsg(jqXHR), { msgType: 'error', autoCloseDelay: 0 });
                                applyButtonIcon('fa fa-close gsp_msgattention');
                            });
                        };
                        var onComplete = function (e3, args) {
                            // Invoked when a plUpload error occurs, file has either failed to upload/be processed in some way or has successfully been uploaded and processed
                            var uploader = $('.gs_rbn_mr_dlg_rf_uploader', $dg).plupload('getUploader');
                            $.each(uploader.files, function (i, file) { return uploader.removeFile(file); });
                        };
                        var onError = function (up, args) {
                            // args.error.code can be any of these values:
                            //STOPPED:1,STARTED:2,QUEUED:1,UPLOADING:2,FAILED:4,DONE:5,GENERIC_ERROR:-100,HTTP_ERROR:-200,IO_ERROR:-300,SECURITY_ERROR:-400,INIT_ERROR:-500,FILE_SIZE_ERROR:-600,FILE_EXTENSION_ERROR:-601,IMAGE_FORMAT_ERROR:-700,IMAGE_MEMORY_ERROR:-701,IMAGE_DIMENSIONS_ERROR:-702
                            var getErrMsg = function () {
                                if (args.error.code === plupload.FILE_SIZE_ERROR) {
                                    return "File size must be less than " + args.up.settings.max_file_size + ". The file '" + args.error.file.name + "' is " + Globalize.format(args.error.file.size / 1024 / 1024, 'n1') + " MB.";
                                }
                                if (args.error.code === plupload.FILE_EXTENSION_ERROR) {
                                    return "The file '" + args.error.file.name + "' has an extension not currently allowed by the gallery configuration. If you are an administrator, you can enable this extension in the site administration.";
                                }
                                var msg = "<p>" + args.error.message + " Code " + args.error.code + ".</p>";
                                if (args.error.file != null) {
                                    msg += "<p>File: " + args.error.file.name + ".</p>";
                                }
                                if (args.error.response != null) {
                                    // Unfortunately, the response is invalid json and can't be parsed into an object, so we just show the raw text
                                    msg += "<p>HTTP response data: " + args.error.response + "</p>";
                                }
                                return msg;
                            };
                            Msg.show('Cannot Replace File', getErrMsg(), { msgType: 'error', autoCloseDelay: 0 });
                            applyButtonIcon('fa fa-close gsp_msgattention');
                        };
                        $('.gs_rbn_mr_dlg_rf_uploader', $dg).plupload({
                            browse_button: null,
                            runtimes: 'html5,silverlight,flash,html4',
                            url: '',
                            flash_swf_url: Vars.GalleryResourcesRoot + "/script/plupload/Moxie.swf",
                            silverlight_xap_url: Vars.GalleryResourcesRoot + "/script/plupload/Moxie.xap",
                            multi_selection: false,
                            //filters: <%= GetFileFilters() %>, // No easy way to specify file types here; server side logic will protect us from disabled file types
                            unique_names: true,
                            max_file_size: _this.data.Settings.MaxUploadSizeKB + " KB",
                            chunk_size: '2mb',
                            views: {
                                list: false,
                                thumbs: true,
                                active: 'thumbs'
                            },
                            uploaded: onFileUpload,
                            complete: onComplete,
                            error: onError,
                            init: {
                                FilesAdded: function (up, filesAdded) {
                                    $('.gs_rbn_mng_rf_btn', $dg).button('option', 'disabled', up.files.length !== 1);
                                    removeDropText();
                                    if (up.files.length > 1) {
                                        applyButtonIcon('fa fa-close gsp_msgattention');
                                    }
                                    else {
                                        applyButtonIcon('fa');
                                    }
                                },
                                FilesRemoved: function (up, filesRemoved) {
                                    $('.gs_rbn_mng_rf_btn', $dg).button('option', 'disabled', up.files.length !== 1);
                                    if (up.files.length === 1) {
                                        applyButtonIcon('fa');
                                    }
                                    else if (up.files.length < 1) {
                                        addDropText();
                                    }
                                }
                            }
                        });
                        addDropText();
                        var uploadFiles = function (e2) {
                            // Begin the upload of files to the server.
                            var uploader = $('.gs_rbn_mr_dlg_rf_uploader', $dg).plupload('getUploader');
                            var mediaId = _this.data.ActiveGalleryItems[0].Id;
                            var albumId = _this.data.ActiveGalleryItems[0].ParentId;
                            uploader.settings.url = Vars.GalleryResourcesRoot + "/handler/upload.ashx?aid=" + albumId + "&moid=" + mediaId;
                            // Files in queue upload them first
                            if (uploader.files.length === 1) {
                                applyButtonIcon('fa fa-spinner fa-pulse');
                                uploader.start();
                            }
                            else {
                                applyButtonIcon('fa');
                                Msg.show('Replacement canceled', 'Select or drag a single replacement file. Multiple replacement files are not supported.', { msgType: 'warning', autoCloseDelay: 0 });
                            }
                        };
                        $('.gs_rbn_mng_rf_btn', $dg).click(function (e1) {
                            // User clicked upload button
                            if (_this.data.ActiveGalleryItems.length === 1 && !_this.data.ActiveGalleryItems[0].IsAlbum) {
                                uploadFiles(e1);
                            }
                            else {
                                Msg.show('Replacement canceled', 'Multiple assets are selected or the selected asset is an album. Select a single media asset and try again.', { msgType: 'warning', autoCloseDelay: 0 });
                            }
                            e1.preventDefault();
                        });
                    };
                    var loadScripts = function (files, callback) {
                        $.getScript(files.shift(), files.length ? function () { loadScripts(files, callback); } : callback);
                    };
                    if (!jQuery().plupload) {
                        var scripts = [Vars.GalleryResourcesRoot + "/script/plupload/plupload.full.min.js", Vars.GalleryResourcesRoot + "/script/plupload/jquery.ui.plupload.min.js"];
                        if (_this.data.App.IsDebugEnabled) {
                            scripts = [Vars.GalleryResourcesRoot + "/script/plupload/moxie.js", Vars.GalleryResourcesRoot + "/script/plupload/plupload.dev.js", Vars.GalleryResourcesRoot + "/script/plupload/jquery.ui.plupload.js"];
                        }
                        loadScripts(scripts, configUploader);
                    }
                    else {
                        configUploader();
                    }
                    $('.gs_rbn_hlp_ctr span', $dg).gsTooltip({
                        title: _this.data.Resource.RbnRplTtHdr,
                        content: _this.data.Resource.RbnRplTtDtl
                    });
                }
                $dg.dialog({
                    appendTo: "#" + _this.data.Settings.HeaderClientId,
                    autoOpen: true,
                    draggable: false,
                    resizable: false,
                    closeOnEscape: true,
                    classes: { 'ui-dialog': 'gs_rbn_mr_dlg_container' },
                    width: 320,
                    minHeight: 0,
                    show: 'fade',
                    hide: 'fade',
                    position: { my: 'left top', at: 'left bottom', of: $trigger },
                    open: function (e1, ui) {
                        $(document).on('click', function (e2) {
                            // We want to close the dialog for any click outside the dialog or the 'more' button
                            if ($(e2.target).parents('.gs_rbn_mr_dlg_container,.gs_rbn_mng_rf').length === 0) {
                                $dg.dialog('close');
                                $trigger.removeClass('gs_rbn_tab_slctd');
                                $(document).unbind(e2);
                            }
                        });
                    },
                    close: function (e1, ui) {
                        $trigger.removeClass('gs_rbn_tab_slctd');
                    }
                });
                return true; // Allow event bubbling so other dialogs can be closed if they are open
            };
            /**
             * Show the disk space used by the original files on each thumbnail.
             */
            this.appendOriginalFileSizeUsage = function () {
                var getOriginalFileSizeString = function (gItem) {
                    // Generate a string like '(571 KB)' or '(23.7 MB)' representing the size of the original file(s) associated with the gallery item
                    var fileSizeKB = 0;
                    if (gItem.ItemType === Enums.ItemType.Album) {
                        fileSizeKB = Utils.getView(gItem, Enums.ViewSize.Original).FileSizeKB;
                    }
                    else if (Utils.hasView(gItem, Enums.ViewSize.Optimized) && Utils.hasView(gItem, Enums.ViewSize.Original)) {
                        // Media asset: return the size of the original file, but only when there's both an optimized and original file
                        fileSizeKB = Utils.getView(gItem, Enums.ViewSize.Original).FileSizeKB;
                    }
                    return fileSizeKB < 1024 ? "(" + fileSizeKB + " KB)" : "(" + Globalize.format(fileSizeKB / 1024, 'n1') + " MB)";
                };
                var appendOrUpdateThmbMsg = function ($thmb, msg) {
                    // Add msg to end of thumbnail. Re-use existing DOM element if present; otherwise add one
                    var $thmbMsg = $thmb.find('.gs_of_svgs');
                    if ($thmbMsg.length > 0) {
                        $thmbMsg.html(msg);
                    }
                    else {
                        $thmb.append("<p class='gs_of_svgs gsp_msgsuccess'>" + msg + "</p>");
                    }
                };
                var $thmbs = $("#" + _this.data.Settings.ThumbnailClientId + " .thmb");
                // Loop through each item in gallery, creating a DOM element in the thumbnail showing the file size
                $.each(_this.data.Album.GalleryItems, function (idx, gItem) {
                    var $thmb = $thmbs.filter("[data-id=" + gItem.Id + "][data-it=" + gItem.ItemType + "]");
                    if (gItem.ItemType === Enums.ItemType.Album && !Utils.hasView(gItem, Enums.ViewSize.Original)) {
                        // Call the server to request the size of original files in the album, then append.
                        $thmb.find('.gsp_go_t').addClass('gsp_wait');
                        appendOrUpdateThmbMsg($thmb, '(Estimating savings...)');
                        DataService.calculateOriginalFileSize(gItem, null, function (gItem1) {
                            gItem.Views = gItem1.Views;
                            $thmb.find('.gsp_go_t').removeClass('gsp_wait');
                            appendOrUpdateThmbMsg($thmb, getOriginalFileSizeString(gItem));
                            $thmbs.css('height', 'auto').equalHeights();
                        }, null);
                    }
                    else {
                        appendOrUpdateThmbMsg($thmb, getOriginalFileSizeString(gItem));
                    }
                });
                $thmbs.css('height', 'auto').equalHeights();
            };
            this.deleteOptionsClick = function (e) {
                var $trigger = $(e.currentTarget).addClass('gs_rbn_tab_slctd');
                var $dg = $('.gs_rbn_mng_dlt_mr_dlg', _this.$target);
                var removeOriginalFileSizaUsage = function () {
                    $("#" + _this.data.Settings.ThumbnailClientId + " .thmb").find('p.gs_of_svgs').remove().end().css('height', 'auto').equalHeights();
                };
                if ($dg.is(':ui-dialog')) {
                    if ($dg.dialog('isOpen')) {
                        $dg.dialog('close');
                        $trigger.removeClass('gs_rbn_tab_slctd').find('.fa').removeClass('fa-rotate-180');
                        return false;
                    }
                }
                else {
                    // First time user clicked 'more' button. Wire up events.
                    $('.chkCheckUncheckAll', $dg).on('click', _this.toggleThumbnailSelection);
                    $('.gs_delete_db_records_only_lbl', $dg).gsTooltip({
                        title: _this.data.Resource.RbnDelDbRcrdsTtHdr,
                        content: _this.data.Resource.RbnDelDbRcrdsTtDtl
                    });
                    $('.gs_delete_original_files_lbl', $dg).gsTooltip({
                        title: _this.data.Resource.RbnDelOrgTtHdr,
                        content: _this.data.Resource.RbnDelOrgTtDtl
                    });
                    $('.gs_delete_db_records_only, .gs_delete_original_files', $dg).on('click', function (e1) {
                        // User clicked one of the checkboxes in the delete options dialog.
                        if ($(e1.currentTarget).hasClass('gs_delete_db_records_only')) {
                            // User clicked 'Delete DB records only'.
                            $('.gs_delete_original_files', $dg).prop('checked', false); // Deselect the other checkbox.
                            // Remove (if present) the original file sizes that were added in showOriginalFileSizaUsage()
                            removeOriginalFileSizaUsage();
                        }
                        else {
                            // User clicked 'Delete original files'.
                            $('.gs_delete_db_records_only', $dg).prop('checked', false); // Deselect the other checkbox.
                            // Toggle the the potential disk savings below the thumbnail image
                            if (_this.data.Album.GalleryItems != null) {
                                $('.gs_delete_original_files', $dg).prop('checked') ? _this.appendOriginalFileSizeUsage() : removeOriginalFileSizaUsage();
                            }
                        }
                        //return true;
                    });
                }
                $dg.dialog({
                    appendTo: "#" + _this.data.Settings.HeaderClientId,
                    autoOpen: true,
                    draggable: false,
                    resizable: false,
                    closeOnEscape: true,
                    classes: { 'ui-dialog': 'gs_rbn_mr_dlg_container' },
                    width: 'auto',
                    minHeight: 0,
                    show: 'fade',
                    hide: 'fade',
                    position: { my: "left top", at: "left bottom", of: $trigger },
                    open: function (e1, ui) {
                        $(document).on('click', function (e2) {
                            // We want to close the dialog for any click outside the dialog or the 'more' button
                            if ($(e2.target).parents('.gs_rbn_mr_dlg_container,.gs_rbn_mng_dlt').length === 0) {
                                $dg.dialog('close');
                                $trigger.removeClass('gs_rbn_tab_slctd').find('.fa').removeClass('fa-rotate-180');
                                $(document).unbind(e2);
                            }
                        });
                    },
                    close: function (e1, ui) {
                        // Revert arrow. We don't really need this code in the other two places, but we leave them there because this event has a noticable lag to it (at least in Chrome)
                        $trigger.removeClass('gs_rbn_tab_slctd').find('.fa').removeClass('fa-rotate-180');
                        //$('.fa', $trigger).removeClass('fa-rotate-180');
                    }
                });
                $('.fa', $trigger).addClass('fa-rotate-180');
                return true; // Allow event bubbling so other dialogs can be closed if they are open
            };
            this.toggleThumbnailSelection = function (e) {
                var $chk = $(e.target);
                var isChecked = $chk.data('ischecked'); // true when we want to check all; otherwise false
                if (isChecked) {
                    $chk.text(_this.data.Resource.ThmbSltAll);
                    $("#" + _this.data.Settings.ThumbnailClientId).gsThumbnails('deselectThumbnails');
                }
                else {
                    $chk.text(_this.data.Resource.ThmbSltNone);
                    $("#" + _this.data.Settings.ThumbnailClientId).gsThumbnails('selectThumbnails');
                }
                $chk.data('ischecked', !isChecked);
                return true;
            };
            this.deleteClick = function (e) {
                var DeletionMode;
                (function (DeletionMode) {
                    DeletionMode[DeletionMode["Unknown"] = 0] = "Unknown";
                    DeletionMode[DeletionMode["Delete"] = 1] = "Delete";
                    DeletionMode[DeletionMode["DeleteOriginalFiles"] = 2] = "DeleteOriginalFiles";
                    DeletionMode[DeletionMode["DeleteDbRecordsOnly"] = 3] = "DeleteDbRecordsOnly";
                })(DeletionMode || (DeletionMode = {}));
                ;
                var getDeletionMode = function () {
                    var $dgDltOptions = $('.gs_rbn_mng_dlt_mr_dlg', _this.$target);
                    if ($('.gs_delete_original_files', $dgDltOptions).prop('checked')) {
                        return DeletionMode.DeleteOriginalFiles;
                    }
                    else if ($('.gs_delete_db_records_only', $dgDltOptions).prop('checked')) {
                        return DeletionMode.DeleteDbRecordsOnly;
                    }
                    else {
                        return DeletionMode.Delete;
                    }
                };
                /**
                 * Generate the message to display to the user in the delete confirmation dialog.
                 */
                var getDeleteConfirmMsg = function () {
                    var delMode = getDeletionMode();
                    var isParentAlbumSelected = _this.data.ActiveGalleryItems.length === 1 && _this.data.ActiveGalleryItems[0].Id === _this.data.Album.Id;
                    var isVirtualAlbum = _this.data.Album.VirtualType !== Enums.VirtualAlbumType.NotVirtual;
                    if (isParentAlbumSelected && (isVirtualAlbum || delMode === DeletionMode.DeleteOriginalFiles)) {
                        // If the user hasn't selected anything and the album is virtual or user is deleting original files, select all child items
                        $("#" + _this.data.Settings.ThumbnailClientId).gsThumbnails('selectThumbnails');
                    }
                    var isSingleMediaAsset = _this.data.ActiveGalleryItems.length === 1 && _this.data.ActiveGalleryItems[0].ItemType !== Enums.ItemType.Album;
                    var isSingleAlbum = _this.data.ActiveGalleryItems.length === 1 && _this.data.ActiveGalleryItems[0].ItemType === Enums.ItemType.Album;
                    var numAlbums = _this.data.ActiveGalleryItems.filter(function (gi) { return gi.ItemType === Enums.ItemType.Album; }).length;
                    var numMediaAssets = _this.data.ActiveGalleryItems.length - numAlbums;
                    switch (delMode) {
                        case DeletionMode.DeleteOriginalFiles:
                            {
                                // Items with something to delete will have a viewSize=2
                                var sumFileSizesKB = 0;
                                $.each(_this.data.ActiveGalleryItems, function (indx, gi) {
                                    var isAlbumWithOriginal = (gi.ItemType === Enums.ItemType.Album) && Utils.hasView(gi, Enums.ViewSize.Original);
                                    var isMediaAssetWithOriginal = (gi.ItemType !== Enums.ItemType.Album) && Utils.hasView(gi, Enums.ViewSize.Optimized) && Utils.hasView(gi, Enums.ViewSize.Original);
                                    if (isAlbumWithOriginal || isMediaAssetWithOriginal) {
                                        sumFileSizesKB += Utils.getView(gi, Enums.ViewSize.Original).FileSizeKB;
                                    }
                                });
                                var sumFileSizesStr = sumFileSizesKB < 1024 ? sumFileSizesKB + " KB" : Globalize.format(sumFileSizesKB / 1024, 'n1') + " MB";
                                return "<p>The original file" + (numAlbums + numMediaAssets === 1 ? '' : 's') + " for " + numMediaAssets + " media asset" + (numMediaAssets === 1 ? '' : 's') + " and " + numAlbums + " child album" + (numAlbums === 1 ? '' : 's') + " will be permanently deleted, but the items will stay in the gallery along with their thumbnail and optimized files.</p><p class='gsp_msgfriendly'>This is expected to free up " + sumFileSizesStr + " of disk space.</p>";
                            }
                        case DeletionMode.DeleteDbRecordsOnly:
                            {
                                var msg;
                                if (isSingleMediaAsset) {
                                    msg = "<p>The media asset '" + Utils.removeHtmlTags(_this.data.ActiveGalleryItems[0].Title) + "' will be removed from the gallery but the original file will be left in its current location.</p>";
                                }
                                else if (isSingleAlbum) {
                                    msg = "<p>The album '" + Utils.removeHtmlTags(_this.data.ActiveGalleryItems[0].Title) + "' and its contents will be removed from the gallery but the original directory and files will be left in their current location.</p>";
                                }
                                else {
                                    msg = "<p>" + numMediaAssets + " media asset" + (numMediaAssets === 1 ? '' : 's') + " and " + numAlbums + " album" + (numAlbums === 1 ? '' : 's') + " will be removed from the gallery but the original directories and files will be left in their current location.</p>";
                                }
                                return msg + '<p class=\'gsp_msgfriendly\'>You can add them back at a later time with the synchronize function.</p>';
                            }
                        case DeletionMode.Delete:
                        default:
                            {
                                if (isSingleMediaAsset) {
                                    return "<p class='gsp_msgwarning'>The media asset '" + Utils.removeHtmlTags(_this.data.ActiveGalleryItems[0].Title) + "' will be permanently deleted.</p>";
                                }
                                else if (isSingleAlbum) {
                                    return "<p class='gsp_msgwarning'>The album '" + Utils.removeHtmlTags(_this.data.ActiveGalleryItems[0].Title) + "' will be permanently deleted.</p>";
                                }
                                else {
                                    return "<p class='gsp_msgwarning'>" + numMediaAssets + " media asset" + (numMediaAssets === 1 ? '' : 's') + " and " + numAlbums + " album" + (numAlbums === 1 ? '' : 's') + " will be permanently deleted.</p>";
                                }
                            }
                    }
                };
                /**
                 * Generate the text to apply to the delete confirmation button
                 */
                var getDeleteConfirmBtnLbl = function () {
                    switch (getDeletionMode()) {
                        case DeletionMode.DeleteOriginalFiles: return 'Delete original media files';
                        case DeletionMode.DeleteDbRecordsOnly: return 'Delete from gallery';
                        default: return 'Delete';
                    }
                };
                var deleteGalleryItems = function () {
                    var keepFiles = $('.gs_delete_db_records_only', _this.$target).prop('checked');
                    DataService.deleteGalleryItems(_this.data.ActiveGalleryItems, !keepFiles, function () {
                        // Always callback
                        $('.gs_rbn_mng_dlt', _this.$target).removeClass('gsp_wait');
                    }, function (actionResult, ajaxResult, ajaxObj) {
                        // Success callback - Ajax request to delete items successfully completed. Check for validation and other errors and respond accordingly
                        var msgOptions = { msgType: actionResult.Status.toLowerCase() };
                        if (actionResult.Status === 'Warning' || actionResult.Status === 'Error') {
                            msgOptions.autoCloseDelay = 0;
                        }
                        Msg.show(actionResult.Title, actionResult.Message, msgOptions);
                        // We deleted items, so remove them from the client-side data and update the screen. Note that we remove all items even if one or 
                        // more weren't actually deleted on the server (e.g. permission denied). Could refactor in future so that only successful deletions
                        // are removed, but this isn't important enough to do now.
                        if (_this.data.MediaItem != null) {
                            // Media view
                            Utils.removeMediaItem(_this.data, _this.data.MediaItem);
                            $("#" + _this.data.Settings.MediaClientId).gsMedia('showNextMediaObject');
                        }
                        else if (_this.data.Album.GalleryItems != null) {
                            var deletedItems = actionResult.ActionTarget;
                            // Thumbnail view
                            if (_this.data.ActiveGalleryItems.length === 1 && _this.data.ActiveGalleryItems[0].Id === _this.data.Album.Id && deletedItems.length === _this.data.ActiveGalleryItems.length) {
                                // User deleted current album. Redirect to parent album.
                                window.location.href = Utils.AddQSParm(Utils.GetAlbumUrl(_this.data.Album.ParentId), 'msg', String(Enums.MessageType.AlbumSuccessfullyDeleted));
                                return;
                            }
                            else {
                                // User deleted one or more items within the album. Remove from client data and rebind.
                                Utils.removeGalleryItems(_this.data, deletedItems);
                                // Select the current album so its metadata shows up in the right pane
                                _this.data.ActiveGalleryItems = [Utils.convertAlbumToGalleryItem(_this.data.Album)];
                                $("#" + _this.data.Settings.ThumbnailClientId).gsThumbnails('renderThumbnails');
                            }
                        }
                        // Since we have new ActiveGalleryItems, raise the select event, which will show their meta in the right pane
                        $("#" + _this.data.Settings.ThumbnailClientId).trigger("select." + _this.data.Settings.ClientId, [_this.data.ActiveGalleryItems]);
                    }, function (jqXHR) {
                        Msg.show('Cannot Delete Items', Utils.parseJqXhrMsg(jqXHR), { msgType: 'error', autoCloseDelay: 0 });
                    });
                };
                var deleteOriginalFiles = function () {
                    DataService.deleteOriginalFiles(_this.data.ActiveGalleryItems, function () {
                        // Always callback
                        $('.gs_rbn_mng_dlt', _this.$target).removeClass('gsp_wait');
                    }, function (actionResult, ajaxResult, ajaxObj) {
                        // Success callback - Ajax request to delete original files successfully completed. Check for validation and other errors and respond accordingly
                        var msgOptions = { msgType: actionResult.Status.toLowerCase() };
                        if (actionResult.Status === 'Warning' || actionResult.Status === 'Error') {
                            msgOptions.autoCloseDelay = 0;
                        }
                        Msg.show(actionResult.Title, actionResult.Message, msgOptions);
                        $.each(actionResult.ActionTarget, function (idx, giServer) {
                            // ActionTarget contains the successfully processed items. Find the matching items in our client data and update the original file size.
                            var giLocal = Utils.findGalleryItem(_this.data, giServer.Id, giServer.ItemType);
                            var origDTLocal = Utils.getView(giLocal, Enums.ViewSize.Original);
                            var origDTFromServer = Utils.getView(giServer, Enums.ViewSize.Original);
                            if (origDTLocal != null && origDTFromServer != null) {
                                origDTLocal.FileSizeKB = origDTFromServer.FileSizeKB;
                            }
                            // Now update the UI to reflect the new file sizes
                            _this.appendOriginalFileSizeUsage();
                        });
                    }, function (jqXHR) {
                        Msg.show('Cannot Delete Original Files', Utils.parseJqXhrMsg(jqXHR), { msgType: 'error', autoCloseDelay: 0 });
                    });
                };
                var $dg = $('.gs_rbn_mg_dlt_confirm_dlg', _this.$target);
                if (!$dg.is(':ui-dialog')) {
                    // First time user clicked delete button. Wire up our events and configured the dialog.
                    $dg.dialog({
                        appendTo: "#" + _this.data.Settings.HeaderClientId,
                        resizable: true,
                        width: Utils.isWidthLessThan(420) ? Utils.getViewportWidth() : 420,
                        modal: true,
                        show: 'fade',
                        hide: 'fade',
                        position: { my: 'center top', at: 'right bottom', of: $(e.currentTarget) }
                    });
                    $('.ui-dialog-buttonset button', $dg).button();
                    // Wire up event for user confirming item deletion
                    $('.gs_rbn_mg_dlt_confirm_dlt_btn', $dg).on('click', function (e1) {
                        $dg.dialog('close');
                        $('.gs_rbn_mng_dlt', _this.$target).addClass('gsp_wait');
                        if ($('.gs_delete_original_files', _this.$target).prop('checked')) {
                            deleteOriginalFiles();
                        }
                        else {
                            deleteGalleryItems();
                        }
                        //$('.gs_rbn_mng_dlt', this.$target).removeClass('gsp_wait');
                    });
                    // Wire up event for user cancelling item deletion
                    $('.gs_rbn_mg_dlt_confirm_cncl_btn', $dg).on('click', function (e1) { $dg.dialog('close'); });
                }
                $('.gs_rbn_mg_dlt_confirm_msg', $dg).html(getDeleteConfirmMsg());
                $('.gs_rbn_mg_dlt_confirm_dlt_btn', $dg).text(getDeleteConfirmBtnLbl());
                $dg.dialog('open');
                return true; // Allow event bubbling so other dialogs can be closed if they are open
            };
            this.assignThumbnailOptionsClick = function (e) {
                if ($(e.currentTarget).parents('.gs_rbn_tab').hasClass('gsp_disabled'))
                    return false;
                // User clicked assign thumbnail options. Show album tree.
                var $trigger = $(e.currentTarget).addClass('gs_rbn_tab_slctd');
                var $dg = $('.gs_rbn_mng_at_mr_dlg', _this.$target);
                if ($dg.is(':ui-dialog')) {
                    if ($dg.dialog('isOpen')) {
                        $dg.dialog('close');
                        $trigger.removeClass('gs_rbn_tab_slctd').find('.fa').removeClass('fa-rotate-180');
                        return false;
                    }
                }
                else {
                    // First time user clicked 'more' button. Call the gsTreeView plug-in, which adds an album treeview
                    var treeOptions = {
                        galleryId: _this.data.Album.GalleryId,
                        containerClientId: _this.data.Settings.ClientId,
                        treeDataUrl: Vars.GalleryResourcesRoot + '/handler/gettreeview.ashx',
                        numberOfLevels: 2,
                        requiredSecurityPermissions: Enums.SecurityActions.EditAlbum,
                        albumIdsToSelect: _this.data.Album.Id
                    };
                    $('.gs_rbn_at_tv', $dg).gsTreeView(null, treeOptions);
                    $('.gs_rbn_at_tv', $dg).on('changed.jstree', function (e, nodeData) {
                        if (nodeData.action === 'select_node') {
                            // Add spinner icon to the right of the album text (this is removed in the complete callback below)
                            $(nodeData.event.currentTarget).append("<span class='fa fa-spinner fa-pulse gsp_addleftmargin3'></span>");
                            $('.gs_rbn_mng_thmb .gs_rbn_btn', _this.$target).click();
                        }
                    });
                    $('.gs_rbn_hlp_ctr span', $dg).gsTooltip({
                        title: _this.data.Resource.RbnThmbTtHdr,
                        content: _this.data.Resource.RbnThmbTtDtl
                    });
                }
                $dg.dialog({
                    appendTo: "#" + _this.data.Settings.HeaderClientId,
                    autoOpen: true,
                    draggable: false,
                    resizable: false,
                    closeOnEscape: true,
                    classes: { 'ui-dialog': 'gs_rbn_mr_dlg_container' },
                    width: 'auto',
                    minHeight: 0,
                    show: 'fade',
                    hide: 'fade',
                    position: { my: 'left top', at: 'left bottom', of: $trigger },
                    open: function (e1, ui) {
                        $(document).on('click', function (e2) {
                            // We want to close the dialog for any click outside the dialog or the 'more' button
                            if ($(e2.target).parents('.gs_rbn_mr_dlg_container,.gs_rbn_mng_thmb').length === 0) {
                                $dg.dialog('close');
                                $trigger.removeClass('gs_rbn_tab_slctd').find('.fa').removeClass('fa-rotate-180');
                                $(document).unbind(e2);
                            }
                        });
                    },
                    close: function (e1, ui) {
                        // Revert arrow. We don't really need this code in the other two places, but we leave them there because this event has a noticable lag to it (at least in Chrome)
                        $trigger.removeClass('gs_rbn_tab_slctd').find('.fa').removeClass('fa-rotate-180');
                    }
                });
                $('.fa', $trigger).addClass('fa-rotate-180');
                return true; // Allow event bubbling so other dialogs can be closed if they are open
            };
            this.assignThumbnailClick = function (e) {
                // Grab the thumbnail for the first selected asset and assign it as the thumbnail for the current album or the specified album
                var closeAssignThmbDialog = function () {
                    var $dg = $('.gs_rbn_mng_at_mr_dlg', _this.$target);
                    if ($dg.is(':ui-dialog') && $dg.dialog('isOpen')) {
                        $dg.dialog('close');
                        $('.fa-spinner', $dg).remove();
                    }
                };
                // If no thumbnail has been selected, inform user
                if (document.getElementById(_this.data.Settings.ThumbnailClientId) !== null && $("#" + _this.data.Settings.ThumbnailClientId + " .thmb.ui-selected").length === 0) {
                    Msg.show('No Thumbnail Selected', 'Select a thumbnail and try again.', { msgType: 'warning' });
                    closeAssignThmbDialog();
                    return false;
                }
                // If there is a selected album in the assign thumbnail treeview, use that. Otherwise use the current album.
                var albumId = _this.data.Album.Id;
                var $assignThmbAlbumTree = $($('.gs_rbn_at_tv', _this.$target)).jstree(true);
                if ($assignThmbAlbumTree) {
                    var selectedAlbumNode = $assignThmbAlbumTree.get_selected(true)[0]; // There should just be one selected album
                    if (selectedAlbumNode != null) {
                        albumId = selectedAlbumNode.li_attr['data-id'];
                    }
                }
                // If the album is virtual, inform user
                if (albumId === Constants.IntMinValue) {
                    Msg.show('No Album Selected', 'Select an album from the thumbnail options window and try again.', { msgType: 'warning' });
                    closeAssignThmbDialog();
                    return false;
                }
                DataService.assignThumbnail(_this.data.ActiveGalleryItems[0], albumId, function () {
                    // Always callback: Close assign thumbnail options dialog if open
                    closeAssignThmbDialog();
                }, function (actionResult, ajaxResult, ajaxObj) {
                    // Success callback: Ajax request to delete items successfully completed. Check for validation and other errors and respond accordingly
                    var msgOptions = { msgType: actionResult.Status.toLowerCase() };
                    if (actionResult.Status === 'Warning' || actionResult.Status === 'Error') {
                        msgOptions.autoCloseDelay = 0;
                    }
                    Msg.show(actionResult.Title, actionResult.Message, msgOptions);
                }, function (jqXHR) {
                    Msg.show('Cannot Assign Thumbnail', Utils.parseJqXhrMsg(jqXHR), { msgType: 'error', autoCloseDelay: 0 });
                });
                return true; // Allow event bubbling so other dialogs can be closed if they are open
            };
            this.editImageClick = function (e) {
                // Make an invisible DOM element for the original version of selected image, then apply tinyMCE and invoke the mceEditImage command.
                var $editImgBtn = $(e.currentTarget).addClass('gsp_wait_center');
                var galleryItem = _this.data.ActiveGalleryItems[0];
                // Verify selected item is an image
                if (galleryItem.ItemType !== Enums.ItemType.Image) {
                    Msg.show('Image Not Selected', 'Select an image and try again.', { msgType: 'warning' });
                    $editImgBtn.removeClass('gsp_wait_center');
                    return true;
                }
                var originalView = Utils.getView(galleryItem, Enums.ViewSize.Original);
                // Verify we retrieved the original image.
                if (originalView == null || originalView.ViewSize !== Enums.ViewSize.Original) {
                    Msg.show('Image Editor Requires Original Image', 'The image editor requires access to the original, high resolution image, but it is not available. Your security settings may be preventing you from accessing it.', { msgType: 'warning', autoCloseDelay: 0 });
                    $editImgBtn.removeClass('gsp_wait_center');
                    return true;
                }
                if (!$(originalView.HtmlOutput).is('img') || !$(originalView.HtmlOutput).has('img')) {
                    // There is no image tag in the HTML - user is probably viewing an image that can't be shown in the browser (wmf, psd, etc). Abort.
                    Msg.show('Unsupported Image Type', 'The image editor supports browser-compatible images. Unfortunately, the original, high-resolution file associated with this image cannot be displayed in a browser window.', { msgType: 'warning', autoCloseDelay: 0 });
                    $editImgBtn.removeClass('gsp_wait_center');
                    return true;
                }
                // If we have DOM elements left over from a previous edit, remove now
                $('.gs_tinymce_wrapper', _this.$target).remove();
                // Create DOM element for the original we will be editing
                var $tinymceEl = $('<div>', { 'class': 'gs_tinymce_wrapper', 'style': 'display:none' }).append(originalView.HtmlOutput).appendTo(_this.$target);
                _this.makeImageEditable($tinymceEl, $editImgBtn);
                return true; // Allow event bubbling so other dialogs can be closed if they are open
            };
            this.makeImageEditable = function ($el, $editImgBtn) {
                // Show the tinyMCE image tools when the user clicks the 'Edit image' ribbon button
                if (typeof tinyMCE === 'undefined') {
                    Msg.show('tinyMCE Not Found', 'The image editor requires tinyMCE, but it was not found.', { msgType: 'warning' });
                    $editImgBtn.removeClass('gsp_wait_center');
                }
                tinyMCE.init({
                    selector: "#" + _this.data.Settings.HeaderClientId + " .gs_tinymce_wrapper",
                    menubar: false,
                    inline: true,
                    skin: _this.data.App.Skin,
                    toolbar: false,
                    plugins: 'imagetools',
                    setup: function (editor) {
                        editor.on('init', function (e) {
                            editor.selection.select($('.gsp_mo_img', $el)[0]);
                            editor.execCommand('mceEditImage');
                            $editImgBtn.removeClass('gsp_wait_center');
                        });
                    },
                    images_upload_handler: function (blobInfo, success, failure, progress) {
                        $("#" + _this.data.Settings.MediaClientId + " .gsp_mvMediaHeader, #" + _this.data.Settings.ThumbnailClientId + " .gsp_abm_sum").addClass('gsp_wait_center');
                        var galleryItem = _this.data.ActiveGalleryItems[0];
                        var xhr = new XMLHttpRequest();
                        xhr.open('POST', "gs/handler/upload.ashx?aid=" + galleryItem.ParentId + "&moid=" + galleryItem.Id);
                        xhr.withCredentials = true;
                        progress(0); // Show progress bar and initialize to 0%
                        // Fix the CSS of the progress bar so it is centered along the top. Without this it is partially hidden on the left.
                        if (tinyMCE.activeEditor.notificationManager.notifications.length > 0) {
                            tinyMCE.activeEditor.notificationManager.notifications[0].$el.css({ 'left': '50%', 'transform': 'translate(-50%, 0)' });
                        }
                        var filename = Utils.createPseudoGuid() + '.' + blobInfo.filename().split('.').pop();
                        xhr.upload.onprogress = function (e) {
                            var percentLoaded = Math.round(e.loaded / e.total * 100);
                            progress(percentLoaded);
                        };
                        xhr.onload = function () {
                            if (xhr.status !== 200) {
                                failure("HTTP Error: " + xhr.status);
                                return;
                            }
                            // Upload is successful. Now call replaceFromFile.
                            DataService.replaceWithEditedImage(galleryItem.Id, filename, function () {
                                // Done handler
                                $("#" + _this.data.Settings.MediaClientId + " .gsp_mvMediaHeader, #" + _this.data.Settings.ThumbnailClientId + " .gsp_abm_sum").removeClass('gsp_wait_center');
                                $el.remove();
                                tinyMCE.activeEditor.destroy();
                            }, function (actionResult) {
                                // Success handler. Check for validation and other errors. If none, refresh URL to show image as it now exists on server.
                                var msgOptions = { msgType: actionResult.Status.toLowerCase() };
                                if (actionResult.Status === 'Warning' || actionResult.Status === 'Error') {
                                    msgOptions.autoCloseDelay = 0;
                                }
                                if (actionResult.Message != null) {
                                    Msg.show(actionResult.Title, actionResult.Message, msgOptions);
                                }
                                if (actionResult.Status === 'Success') {
                                    // Grab a reference to either the media view img element or the thumbnail view img element
                                    var $imgEl = $("#" + _this.data.Settings.MediaClientId + " .gsp_mo_img, #" + _this.data.Settings.ThumbnailClientId + " .thmb[data-id=" + galleryItem.Id + "] .gsp_thmb_img");
                                    // Remove any previous width/height.
                                    $imgEl.add($imgEl.parents('.thmb')).css({ width: '', height: '' });
                                    // If we're on the thumbnail view, set the max width. Without this, when we call equalSize() thumbs with long captions will cause the thumbnails to expand to fit the caption on a single line.
                                    if ($("#" + _this.data.Settings.ThumbnailClientId).length > 0) {
                                        $imgEl.parents('.thmb').css({ 'max-width': (_this.data.Settings.MaxThumbnailLength + 40) + 'px' });
                                    }
                                    if ($imgEl.length > 0 && typeof $imgEl.attr('src') !== 'undefined') {
                                        $imgEl[0].src += "&ver=" + new Date().getTime().toString();
                                        // When the image loads, update the thumbnail borders to reflect the latest width/height
                                        if (_this.data.Album.GalleryItems && !$imgEl[0].complete) {
                                            $imgEl.load(function () {
                                                var wBuffer = (_this.data.Album.GalleryItems.length > 1 ? 0 : 20); // We only need a buffer when there's 1 asset since the other thumbnails already include a buffer.
                                                $("#" + _this.data.Settings.ThumbnailClientId + " .thmb").equalSize(wBuffer, 0);
                                            });
                                        }
                                    }
                                    else {
                                        Msg.show('Cannot Refresh Image', "Your changes were successfully saved on the server, but we couldn't refresh the image in your browser because an error occurred while trying to find the image element. $imgEl.length==" + $imgEl.length, { msgType: 'error', autoCloseDelay: 0 });
                                    }
                                }
                            }, function (jqXHR) {
                                Msg.show('Cannot Save Changes', Utils.parseJqXhrMsg(jqXHR), { msgType: 'error', autoCloseDelay: 0 });
                            });
                        };
                        var formData = new FormData();
                        formData.append('name', filename);
                        formData.append('file', blobInfo.blob(), filename);
                        xhr.send(formData);
                    }
                });
            };
            this.rotateLeftClick = function (e) {
                _this.rotateFlip(Enums.RotateFlip.Rotate270FlipNone, e);
                return true;
            };
            this.rotateRightClick = function (e) {
                _this.rotateFlip(Enums.RotateFlip.Rotate90FlipNone, e);
                return true;
            };
            this.flipHorizontalClick = function (e) {
                _this.rotateFlip(Enums.RotateFlip.Rotate0FlipX, e);
                return true;
            };
            this.flipVerticalClick = function (e) {
                _this.rotateFlip(Enums.RotateFlip.Rotate0FlipY, e);
                return true;
            };
            this.rotateFlip = function (rotateFlipAmount, e) {
                // Handle the rotate/flip request the user initiated in the ribbon toolbar. This is unrelated to rotate/flip requests handled 
                // within the tinyMCE image editor.
                var getRotateFlipClassName = function () {
                    switch (rotateFlipAmount) {
                        case Enums.RotateFlip.Rotate270FlipNone:
                            return 'fa-rotate-left';
                        case Enums.RotateFlip.Rotate90FlipNone:
                            return 'fa-rotate-right';
                        case Enums.RotateFlip.Rotate0FlipX:
                            return 'fa-shield fa-rotate-270';
                        case Enums.RotateFlip.Rotate0FlipY:
                            return 'fa-shield fa-rotate-180';
                        default:
                            return null;
                    }
                };
                var getViewSize = function (galleryItems) {
                    // Get view size of first item. We assume all items have the same size (all thumbnails, optimized, or originals).
                    return galleryItems[0].Views[galleryItems[0].ViewIndex].ViewSize;
                };
                // Verify selected items are images or videos
                var selectedImagesAndVideos = $.grep(_this.data.ActiveGalleryItems, function (gi) { return (gi.ItemType === Enums.ItemType.Image || gi.ItemType === Enums.ItemType.Video); });
                if (selectedImagesAndVideos.length === 0) {
                    Msg.show('Image or Video Not Selected', 'Select an image or video and try again.', { msgType: 'warning' });
                    return;
                }
                $(e.currentTarget).find('.fa').removeClass(getRotateFlipClassName()).addClass('fa-spinner fa-spin');
                DataService.rotateFlipMediaAsset(selectedImagesAndVideos, rotateFlipAmount, getViewSize(selectedImagesAndVideos), function () {
                    // Done callback - restore icon
                    $(e.currentTarget).find('.fa').removeClass('fa-spinner fa-spin').addClass(getRotateFlipClassName());
                }, function (actionResult) {
                    // Success callback
                    var msgOptions = { msgType: actionResult.Status.toLowerCase() };
                    if (actionResult.Status === 'Warning' || actionResult.Status === 'Error') {
                        msgOptions.autoCloseDelay = 0;
                    }
                    if (actionResult.Message != null) {
                        Msg.show(actionResult.Title, actionResult.Message, msgOptions);
                    }
                    var rotatedFlippedItems = actionResult.ActionTarget;
                    $.each(rotatedFlippedItems, function (indx, galleryItem) {
                        // Grab a reference to either the media view img element or the thumbnail view img element
                        var $imgEl = $("#" + _this.data.Settings.MediaClientId + " .gsp_mo_img, #" + _this.data.Settings.ThumbnailClientId + " .thmb[data-id=" + galleryItem.Id + "] .gsp_thmb_img");
                        // Remove any previous width/height.
                        $imgEl.add($imgEl.parents('.thmb')).css({ 'width': '', 'height': '' });
                        if ($imgEl.length > 0 && typeof $imgEl.attr('src') !== 'undefined') {
                            $imgEl[0].src += "&ver=" + new Date().getTime().toString();
                            // When the image loads, update the thumbnail borders to reflect the latest width/height
                            if (_this.data.Album.GalleryItems && !$imgEl[0].complete) {
                                $imgEl.load(function () {
                                    var wBuffer = (_this.data.Album.GalleryItems.length > 1 ? 0 : 20); // We only need a buffer when there's 1 asset since the other thumbnails already include a buffer.
                                    $("#" + _this.data.Settings.ThumbnailClientId + " .thmb").equalSize(wBuffer, 0);
                                });
                            }
                        }
                    });
                }, function (jqXHR) {
                    Msg.show('Cannot Rotate/Flip', Utils.parseJqXhrMsg(jqXHR), { msgType: 'error', autoCloseDelay: 0 });
                });
            };
            this.securityClick = function (e) {
                var $trigger = $(e.currentTarget).addClass('gs_rbn_tab_slctd');
                var $dg = $('.gs_rbn_mng_sc_mr_dlg', _this.$target);
                if ($dg.is(':ui-dialog')) {
                    if ($dg.dialog('isOpen')) {
                        $dg.dialog('close');
                        $trigger.removeClass('gs_rbn_tab_slctd');
                        return false;
                    }
                }
                else {
                    // First time user clicked 'Security' button. Wire up events.
                    $('.gs_rbn_mng_sc_isprivate_lbl', $dg).gsTooltip({
                        title: _this.data.Resource.AbmPvtHdr,
                        content: _this.data.Resource.AbmPvtDtl
                    });
                    $('.gs_rbn_mr_pvt_abm_ownr_ipt', $dg).gsTooltip({
                        title: _this.data.Resource.AbmOwnrLbl,
                        content: _this.data.Resource.AbmOwnrTtDtl
                    }).on('change', function (e1) {
                        // User changed the album owner
                        var oldAbmOwnr = _this.data.Album.Owner;
                        _this.data.Album.Owner = $(e1.currentTarget).val();
                        if (oldAbmOwnr !== _this.data.Album.Owner) {
                            $(e1.currentTarget).addClass('gsp_wait_center');
                            DataService.changeAlbumOwner(_this.data.Album.Id, encodeURIComponent(_this.data.Album.Owner), function () {
                                // Done event.
                                $(e1.currentTarget).removeClass('gsp_wait_center');
                                $(e1.currentTarget).val(_this.data.Album.Owner);
                            }, function (actionResult) {
                                // Success callback: Ajax request to delete items successfully completed. Check for validation and other errors and respond accordingly
                                var msgOptions = { msgType: actionResult.Status.toLowerCase() };
                                if (actionResult.Status === 'Warning' || actionResult.Status === 'Error') {
                                    msgOptions.autoCloseDelay = 0;
                                }
                                Msg.show(actionResult.Title, actionResult.Message, msgOptions);
                                if (actionResult.Status === 'Error') {
                                    _this.data.Album.Owner = oldAbmOwnr; // Revert back
                                }
                                else {
                                    _this.data.Album.Owner = actionResult.ActionTarget; // Update to reflect correct case if necessary
                                }
                            }, function (jqXHR) {
                                _this.data.Album.Owner = oldAbmOwnr; // Revert back
                                Msg.show('Cannot Edit Album', Utils.parseJqXhrMsg(jqXHR), { msgType: 'error', autoCloseDelay: 0 });
                            });
                        }
                    });
                    $('.gs_rbn_mng_sc_isprivate', $dg).on('change', function (e1) {
                        // User clicked 'hide this album'. Toggle IsPrivate for the album.
                        if (!_this.data.Settings.AllowAnonBrowsing) {
                            Msg.show(_this.data.Resource.AbmAnonDisabledTitle, _this.data.Resource.AbmAnonDisabledMsg, { msgType: 'warning', autoCloseDelay: 0 });
                            e1.currentTarget.checked = true;
                            return false;
                        }
                        var $lockIcon = $('.gs_isp_icn', $dg);
                        _this.data.Album.IsPrivate = e1.currentTarget.checked;
                        // Switch lock icon to spinner
                        $lockIcon.removeClass('gsp_gold').toggleClass('fa-lock fa-spinner fa-spin');
                        DataService.saveAlbum(_this.data.Album, function () {
                            // Done event.
                            $lockIcon.toggleClass('fa-lock fa-spinner fa-spin').attr('title', _this.data.Album.IsPrivate ? _this.data.Resource.AbmIsPvtTt : _this.data.Resource.AbmNotPvtTt);
                            if (_this.data.Album.IsPrivate) {
                                $lockIcon.addClass('gsp_gold');
                            }
                        }, function () {
                            // Success event
                        }, function (jqXHR) {
                            _this.data.Album.IsPrivate = e1.currentTarget.checked = !_this.data.Album.IsPrivate; // Revert back
                            Msg.show('Cannot Edit Album', Utils.parseJqXhrMsg(jqXHR), { msgType: 'error', autoCloseDelay: 0 });
                        });
                        return false;
                    });
                }
                $dg.dialog({
                    appendTo: "#" + _this.data.Settings.HeaderClientId,
                    autoOpen: true,
                    draggable: false,
                    resizable: false,
                    closeOnEscape: true,
                    classes: { 'ui-dialog': 'gs_rbn_mr_dlg_container' },
                    width: Utils.isWidthLessThan(420) ? Utils.getViewportWidth() : 420,
                    minHeight: 0,
                    show: 'fade',
                    hide: 'fade',
                    position: { my: 'left top', at: 'left bottom', of: $trigger },
                    open: function (e1, ui) {
                        $(document).on('click', function (e2) {
                            // We want to close the dialog for any click outside the dialog or the 'more' button
                            if ($(e2.target).parents('.gs_rbn_mr_dlg_container,.gs_rbn_mng_sc').length === 0) {
                                $dg.dialog('close');
                                $trigger.removeClass('gs_rbn_tab_slctd');
                                $(document).unbind(e2);
                            }
                        });
                    },
                    close: function (e1, ui) {
                        $trigger.removeClass('gs_rbn_tab_slctd');
                    }
                });
                return true; // Allow event bubbling so other dialogs can be closed if they are open
            };
            this.$target = target; // A jQuery object to receive the rendered HTML from the template.
            this.data = data;
        }
        GsHeader.prototype.initialize = function () {
            this.renderHeader();
            this.configRibbon();
            this.configLogin();
            this.configSearch();
            $(document.documentElement).trigger("gsHeaderLoaded." + this.data.Settings.ClientId);
        };
        GsHeader.prototype.renderHeader = function () {
            this.$target.html($.render[this.data.Settings.HeaderTmplName](this.data)); // Render HTML template and add to page
        };
        GsHeader.prototype.configRibbon = function () {
            var _this = this;
            // STEP 1: Wire up button events and handle enabled/disabled state
            var isGalleryWritable = !this.data.Settings.IsReadOnlyGallery;
            // OPTIMIZED/ORIGINAL TOGGLE
            $('.gs_rbn_hm_opt .gs_rbn_btn,.gs_rbn_hm_hr .gs_rbn_btn', this.$target).on('click', this.viewSizeClick);
            // SELECT/CLEAR TOGGLE
            $('.gs_rbn_hm_slt .gs_rbn_btn', this.$target).on('click', this.selectClick);
            // SLIDE SHOW
            $('.gs_rbn_hm_ss .gs_rbn_mr', this.$target).on('click', this.slideShowOptionsClick);
            $('.gs_rbn_hm_ss .gs_rbn_btn', this.$target).on('click', this.slideShowClick);
            // DOWNLOAD
            $('.gs_rbn_hm_dl .gs_rbn_btn', this.$target).on('click', this.downloadClick);
            // SHARE
            $('.gs_rbn_hm_sh .gs_rbn_btn', this.$target).on('click', this.shareClick);
            // SORT
            $('.gs_rbn_hm_st .gs_rbn_btn', this.$target).on('click', this.sortClick);
            // CREATE ALBUM
            var createAlbumEnabled = isGalleryWritable && this.data.Album.GalleryItems != null && this.data.Album.VirtualType === Enums.VirtualAlbumType.NotVirtual && this.data.Album.Permissions.AddChildAlbum;
            if (createAlbumEnabled) {
                $('.gs_rbn_mng_ca .gs_rbn_btn', this.$target).on('click', this.createAlbumClick);
            }
            else {
                var msg = 'This function is disabled'; // Fallback text - it is expected this will be overwritten below
                if (this.data.Album.GalleryItems == null)
                    msg = 'Disabled - navigate to the album thumbnail view to create an album';
                else if (this.data.Album.VirtualType !== Enums.VirtualAlbumType.NotVirtual)
                    msg = 'Disabled because you are looking at a virtual album - navigate to a physical album to enable this function';
                else if (!this.data.Album.Permissions.AddChildAlbum)
                    msg = 'Disable because you do not have permission to create an album';
                else if (!isGalleryWritable)
                    msg = 'Disabled because the gallery is read only';
                $('.gs_rbn_mng_ca', this.$target).addClass('gsp_disabled').find('.gs_rbn_btn').attr('title', msg);
            }
            // ADD MEDIA
            if (!this.data.Album.Permissions.AddMediaObject) {
                $('.gs_task_addobjects', this.$target).addClass('gsp_disabled').find('.gs_rbn_btn').attr('title', 'Disabled because you do not have permission for this action');
            }
            // MOVE TO 
            var moveToEnabled = isGalleryWritable && ((this.data.Album.Permissions.DeleteChildAlbum && this.data.User.CanAddAlbumToAtLeastOneAlbum) || (this.data.Album.Permissions.DeleteMediaObject && this.data.User.CanAddMediaToAtLeastOneAlbum));
            if (moveToEnabled) {
                $('.gs_rbn_mng_mt .gs_rbn_btn', this.$target).on('click', this.transferToAlbumClick);
            }
            else {
                $('.gs_rbn_mng_mt', this.$target).addClass('gsp_disabled').find('.gs_rbn_btn').attr('title', 'Disabled because the gallery is read only or you do not have permission for this action');
            }
            // COPY TO
            var copyToEnabled = isGalleryWritable && (this.data.Settings.AllowCopyingReadOnlyObjects ? (this.data.User.CanAddAlbumToAtLeastOneAlbum || this.data.User.CanAddMediaToAtLeastOneAlbum) : this.data.Album.Permissions.AddMediaObject);
            if (copyToEnabled) {
                $('.gs_rbn_mng_ct .gs_rbn_btn', this.$target).on('click', this.transferToAlbumClick);
            }
            else {
                $('.gs_rbn_mng_ct', this.$target).addClass('gsp_disabled').find('.gs_rbn_btn').attr('title', 'Disabled because the gallery is read only or you do not have permission for this action');
            }
            // REPLACE
            var replaceEnabled = isGalleryWritable && this.data.Album.Permissions.EditMediaObject;
            if (replaceEnabled) {
                $('.gs_rbn_mng_rf .gs_rbn_btn', this.$target).on('click', this.replaceFileClick);
            }
            else {
                $('.gs_rbn_mng_rf', this.$target).addClass('gsp_disabled').find('.gs_rbn_btn').attr('title', 'Disabled because the gallery is read only, you do not have permission for this action, or you have not selected a single media asset');
            }
            if (this.data.MediaItem == null) {
                // We're on the album (thumbnail) view. Start with button disabled. Later in this function we hook into the thumb select event to enable it as needed.
                $('.gs_rbn_mng_rf', this.$target).addClass('gsp_disabled').find('.gs_rbn_btn').attr('title', 'Disabled because the gallery is read only, you do not have permission for this action, or you have not selected a single media asset');
            }
            // DELETE
            // User requires only EditMediaObject permission when deleting the original file, so we'll enable even if user doesn't have DeleteMediaObject or DeleteMediaObject
            // permission. Server side code re-evaluates permissions and will prevent the user from deleting when she isn't supposed to.
            var deleteEnabled = isGalleryWritable && (this.data.Album.Permissions.EditMediaObject || this.data.Album.Permissions.DeleteMediaObject || this.data.Album.Permissions.DeleteChildAlbum);
            if (deleteEnabled) {
                $('.gs_rbn_mng_dlt .gs_rbn_mr', this.$target).on('click', this.deleteOptionsClick);
                $('.gs_rbn_mng_dlt .gs_rbn_btn', this.$target).on('click', this.deleteClick);
            }
            else {
                $('.gs_rbn_mng_dlt', this.$target).addClass('gsp_disabled').find('.gs_rbn_btn').attr('title', 'Disabled because the gallery is read only or you do not have permission for this action');
            }
            // THUMBNAIL
            if (this.data.User.CanEditAtLeastOneAlbum) {
                $('.gs_rbn_mng_thmb .gs_rbn_mr', this.$target).on('click', this.assignThumbnailOptionsClick);
                $('.gs_rbn_mng_thmb .gs_rbn_btn', this.$target).on('click', this.assignThumbnailClick);
            }
            else {
                $('.gs_rbn_mng_thmb', this.$target).addClass('gsp_disabled').find('.gs_rbn_btn').attr('title', 'Disabled because you do not have permission for this action');
            }
            // EDIT IMAGE
            if (isGalleryWritable && this.data.Album.Permissions.EditMediaObject) {
                $('.gs_rbn_mng_edt .gs_rbn_btn', this.$target).on('click', this.editImageClick);
                $('.gs_rbn_mng_rtfp .gs_rbn_btn.gs_rt_lt', this.$target).on('click', this.rotateLeftClick);
                $('.gs_rbn_mng_rtfp .gs_rbn_btn.gs_rt_rt', this.$target).on('click', this.rotateRightClick);
                $('.gs_rbn_mng_rtfp .gs_rbn_btn.gs_fh', this.$target).on('click', this.flipHorizontalClick);
                $('.gs_rbn_mng_rtfp .gs_rbn_btn.gs_fv', this.$target).on('click', this.flipVerticalClick);
            }
            else {
                $('.gs_rbn_mng_edt,.gs_rbn_mng_rtfp', this.$target).addClass('gsp_disabled').find('.gs_rbn_btn').attr('title', 'Disabled because the gallery is read only or you do not have permission for this action');
            }
            // SECURITY
            if (this.data.Album.VirtualType === Enums.VirtualAlbumType.NotVirtual && this.data.Album.Permissions.EditAlbum) {
                $('.gs_rbn_mng_sc .gs_rbn_btn', this.$target).on('click', this.securityClick);
            }
            else {
                $('.gs_rbn_mng_sc', this.$target).addClass('gsp_disabled').find('.gs_rbn_btn').attr('title', 'Disabled because you do not have permission for this action or a virtual album is being displayed');
            }
            // SYNCHRONIZE
            if (!this.data.Album.Permissions.Synchronize) {
                $('.gs_task_synchronize', this.$target).addClass('gsp_disabled').find('.gs_rbn_btn').attr('title', 'Disabled because you do not have permission for this action');
            }
            // ADMIN and SETTINGS tabs: The UI template renders HTML only for site & gallery admins, so we only need to disable certain items for gallery admins
            if (!this.data.Album.Permissions.AdministerSite) {
                $('.gs_admin_sitesettings,.gs_admin_mediaqueue,.gs_admin_mediatemplates,.gs_admin_css,.gs_admin_backuprestore,.gs_admin_filetypes', this.$target).addClass('gsp_disabled').find('.gs_rbn_btn').attr('title', 'Disabled - Requires site administrator permission');
                if (this.data.Album.Permissions.AdministerGallery && !this.data.App.AllowGalleryAdminToManageUsersAndRoles) {
                    $('.gs_admin_manageusers,.gs_admin_manageroles', this.$target).addClass('gsp_disabled').find('.gs_rbn_btn').attr('title', 'Disabled because you do not have permission for this action');
                }
            }
            // Show all tabs where at least one of its buttons are enabled (by default all tabs have gsp_invisible class)
            $('.gs_rbn_tab_ctr:has(.gs_rbn_tab > li:not(li.gsp_disabled))', this.$target).each(function (idx, el) {
                $(".gs_rbn_ctr li:has(a[href='#" + el.id + "'])", _this.$target).removeClass('gsp_invisible');
            });
            // STEP 2: Create tab widget for ribbon
            var selRbnCookieName = this.data.Settings.ClientId + '_rbtb_cookie';
            var isRbnExpandedCookieName = this.data.Settings.ClientId + '_rbstate_cookie';
            // Retrieve the selected tab and whether it is expanded. We prefer sessionStorage over a cookie because it is unique to each tab.
            // sessionStorage is supported in IE8+ and all modern browsers. Default to showing the first tab expanded for user's first visit.
            var rbnTabIndex = (sessionStorage && parseInt(sessionStorage.getItem('rbnTabIndex'), 10)) || parseInt(Vars.Cookies.get(selRbnCookieName), 10) || 0;
            var isRbnExpanded = (sessionStorage && sessionStorage.getItem('isRbnExpanded')) || Vars.Cookies.get(isRbnExpandedCookieName) || 'true';
            var $rbnCtr = $("#" + this.data.Settings.HeaderClientId + "_rbn_ctr");
            var activePanel = $rbnCtr.tabs({
                collapsible: true,
                active: isRbnExpanded === 'true' ? (rbnTabIndex || 0) : false,
                activate: function (e, ui) {
                    $('.gs_rbn_tab > li', ui.newPanel).equalHeights();
                    Vars.Cookies.set(selRbnCookieName, ui.newTab.index(), { expires: 365 });
                    Vars.Cookies.set(isRbnExpandedCookieName, (ui.newTab.length > 0), { expires: 365 });
                    if (typeof (Storage) !== 'undefined') {
                        sessionStorage.setItem('rbnTabIndex', ui.newTab.index().toString());
                        sessionStorage.setItem('isRbnExpanded', (ui.newTab.length > 0).toString());
                    }
                }
            })
                .show().tabs('option', 'active');
            // If we wanted the ribbon expanded (isRbnExpanded=true) but it's not (activePanel=false), that's probably because the user logged off
            // and the previously active tab doesn't exist. Activate the first tab.
            if (isRbnExpanded === 'true' && activePanel === false) {
                $('ul.gs_rbn_tab_ctr > li:first a', $rbnCtr).click();
            }
            // Add special class to button that matches current page (if any)
            var $tabPanel = $("#" + this.data.Settings.ClientId + " .gs_rbn_ctr .gs_" + Enums.PageId[this.data.Settings.PageId]).addClass('gs_rbn_tab_slctd').parents('.ui-tabs-panel');
            // Make tab active if it's not already active
            if ($tabPanel.length > 0 && !$tabPanel.is(':visible')) {
                // User may have pasted link in browser, causing them to navigate to a page in a different ribbon tab. Show it.
                $rbnCtr.tabs('option', 'active', $("#" + this.data.Settings.ClientId + " .gs_rbn_ctr .ui-tabs-panel").index($tabPanel));
            }
            // If the active tab is invisible, make the first one active (user probably doesn't have permission where she previously did)
            var $activeTab = $('.gs_rbn_ctr .ui-tabs-nav li.ui-tabs-active', this.$target);
            if ($activeTab.length > 0 && $activeTab.hasClass('gsp_invisible')) {
                $rbnCtr.tabs('option', 'active', 0);
            }
            // activePanel will be false when collapsed; otherwise a zero-based index of active tab
            if (activePanel !== false) {
                // Ribbon is expanded, so make the buttons equal height
                $("#" + this.data.Settings.ClientId + " .gs_rbn_tab > li").equalHeights();
            }
            if ((this.data.Settings.PageId === Enums.PageId.task_addobjects || this.data.Settings.PageId === Enums.PageId.task_synchronize) || Enums.PageId[this.data.Settings.PageId].lastIndexOf('admin_', 0) === 0) {
                // User is on the add/sync page or one of the Admin/Settings pages. Disable applicable buttons on Home and Manage tabs
                $('.gs_rbn_mng_tab_ctr .gs_rbn_tab > li:not(.gs_task_addobjects,.gs_task_synchronize)', this.$target).addClass('gsp_disabled').find('.gs_rbn_btn').off('click');
            }
            if (!this.data.Settings.AllowUrlOverride) {
                // Remove the hyperlinks from the album breadcrumb menu
                $('.albumMenu a', this.$target).contents().filter(function (idx, el) {
                    return el.nodeType === Node.TEXT_NODE;
                }).unwrap();
            }
            // Bind to the select event from the gsThumbnails plug-in so we can enable/disable relevant ribbon buttons.
            $("#" + this.data.Settings.ThumbnailClientId).on('select.' + this.data.Settings.ClientId, $.proxy(this.thumbnailsSelected, this));
        };
        GsHeader.prototype.thumbnailsSelected = function () {
            if (!this.data.Settings.IsReadOnlyGallery && this.data.Album.Permissions.EditMediaObject && this.data.ActiveGalleryItems.length === 1 && !this.data.ActiveGalleryItems[0].IsAlbum) {
                $('.gs_rbn_mng_rf', this.$target).removeClass('gsp_disabled').find('.gs_rbn_btn').attr('title', this.data.Resource.RbnRplTt);
                // Update the asset title on the replace dropdown when a single media asset is selected; otherwise set to blank.
                $('.gs_rbn_mr_dlg_rf_hdr').html(this.data.Resource.RbnShAsset + " <span class='gsp_vibrant'>" + this.data.ActiveGalleryItems[0].Title + "</span>");
            }
            else {
                $('.gs_rbn_mng_rf', this.$target).addClass('gsp_disabled').find('.gs_rbn_btn').attr('title', 'Disabled because the gallery is read only, you do not have permission for this action, or you have not selected a single media asset');
                $('.gs_rbn_mr_dlg_rf_hdr').html(this.data.Resource.RbnShAsset + " <span class='gsp_vibrant'></span>");
            }
        };
        GsHeader.prototype.configLogin = function () {
            var dgLogin;
            if (this.data.User.IsAuthenticated) {
                $('.gsp_logoffLink', this.$target).click(function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    DataService.logOff(function () { Utils.ReloadPage(); });
                });
            }
            else {
                dgLogin = $("#" + this.data.Settings.ClientId + "_loginDlg");
                dgLogin.data('dgLoginWidth', 420);
                dgLogin.dialog({
                    appendTo: "#" + this.data.Settings.ClientId,
                    autoOpen: false,
                    draggable: false,
                    resizable: false,
                    closeOnEscape: true,
                    classes: { 'ui-dialog': 'gsp_loginDlgContainer' },
                    width: dgLogin.data('dgLoginWidth'),
                    minHeight: 0,
                    show: 'fade',
                    hide: 'fade',
                    open: function () {
                        setTimeout(function () { $('.gsp_login_textbox:first', dgLogin).focus(); }, 50); // Delay needed for IE
                    }
                });
                var disableCreateUserValidation = function (disabled) {
                    // When true, the required attribute of form elements in the create user control are disabled. This allows the user to log in 
                    // on the create user page.
                    $('.gsp_createuser input[data-required=true]').prop('required', !disabled);
                };
                $('.gsp_login_trigger', this.$target).click(function (e) {
                    if (dgLogin.dialog('isOpen')) {
                        dgLogin.dialog('close');
                        disableCreateUserValidation(false); // Restore required attribute
                    }
                    else {
                        dgLogin.dialog('option', 'hide', null).dialog('close').dialog('option', 'hide', 'fade'); // Kill, then restore fade for quicker closing
                        dgLogin.dialog('option', 'position', { my: 'right bottom', at: 'right top', of: e.currentTarget });
                        dgLogin.dialog('open');
                        disableCreateUserValidation(true);
                    }
                    return false;
                });
                $('.gsp_login_textbox', dgLogin).on('keydown', function (e) {
                    if (e.keyCode === Enums.KeyCode.Enter) {
                        $('.gsp_login_button', dgLogin).click();
                        return false;
                    }
                    else {
                        return true;
                    }
                });
                $('.gsp_login_button', dgLogin).button();
                // Close dialog when user clicks outside the login window
                $('body').on('click', function (e) {
                    if (dgLogin.dialog('isOpen') && !$(e.target).is('.ui-dialog, a') && !$(e.target).closest('.ui-dialog').length) {
                        dgLogin.dialog('close');
                        disableCreateUserValidation(false); // Restore required attribute
                    }
                });
            }
        };
        GsHeader.prototype.configSearch = function () {
            var _this = this;
            var dgSearch;
            if (this.data.Settings.ShowSearch) {
                dgSearch = $('.gsp_search_dlg', this.$target);
                dgSearch.data('dgSearchWidth', 420);
                dgSearch.dialog({
                    appendTo: "#" + this.data.Settings.ClientId,
                    autoOpen: false,
                    draggable: false,
                    resizable: false,
                    closeOnEscape: true,
                    classes: { 'ui-dialog': 'gsp_searchDlgContainer' },
                    width: dgSearch.data('dgSearchWidth'),
                    minHeight: 0,
                    show: 'fade',
                    hide: 'fade',
                    open: function (t, d) {
                        setTimeout(function () { $('.gsp_searchbox', dgSearch).focus(); }, 50); // Delay needed for IE
                    }
                });
                $('.gsp_search_trigger', this.$target).click(function (e) {
                    if (dgSearch.dialog('isOpen'))
                        dgSearch.dialog('close');
                    else {
                        dgSearch.dialog('option', 'hide', null).dialog('close').dialog('option', 'hide', 'fade'); // Kill, then restore fade for quicker closing
                        dgSearch.dialog('option', 'position', { my: 'right bottom', at: 'right top', of: e.currentTarget });
                        dgSearch.dialog('open');
                    }
                    return false;
                });
                // Start search when search button is clicked
                $('.gsp_searchbutton', dgSearch).on('click', function (e) {
                    var prepSearchTerms = function (st) {
                        // Replace any spaces outside of quotes with +
                        var result = '';
                        var inQuote;
                        $.each(st.split(''), function (idx, v) {
                            if (v === '\"' || v === '\'')
                                inQuote = !inQuote;
                            result += (!inQuote && v === ' ' ? '+' : v);
                        });
                        return result;
                    };
                    e.preventDefault();
                    e.stopPropagation();
                    var minSearchLen = 3;
                    var searchTerm = $('.gsp_searchbox', dgSearch).val();
                    if (searchTerm.length >= minSearchLen) {
                        var sType = $("[name=" + _this.data.Settings.ClientId + "_searchType]:checked").val();
                        var parms = { title: null, tag: null, people: null, search: null, latest: null, filter: null, rating: null, top: null, aid: null, moid: null };
                        parms[sType] = prepSearchTerms(searchTerm);
                        window.location.href = Utils.GetUrl(window.location.href, parms);
                    }
                    else {
                        var $msgEl = $('.gsp_search_msg', dgSearch);
                        $msgEl.css('visibility', 'visible');
                        $('.gsp_searchbox', dgSearch).one('keydown', function () { $msgEl.css('visibility', 'hidden'); }).focus();
                    }
                }).button();
                $('.gsp_searchbox, .gsp_search_type_container input', dgSearch).on('keydown', function (e) {
                    if (e.keyCode === Enums.KeyCode.Enter) {
                        $('.gsp_searchbutton', dgSearch).click();
                        return false;
                    }
                    else
                        return true;
                });
                // Close dialog when user clicks outside the search window
                $('body').on('click', function (e) {
                    if (dgSearch.dialog('isOpen') && !$(e.target).is('.ui-dialog, a') && !$(e.target).closest('.ui-dialog').length) {
                        dgSearch.dialog('close');
                    }
                });
            }
        };
        return GsHeader;
    }());
    $.fn.gsTooltip = function (options) {
        var self = this;
        return this.each(function () {
            if (!$.data(this, 'plugin_gspTooltip')) {
                var tt = new GsTooltip();
                tt.init(self, options);
                $.data(this, 'plugin_gspTooltip', tt);
            }
        });
    };
    $.fn.gsTooltip.defaults = {
        title: '',
        content: ''
    };
    var GsTooltip = /** @class */ (function () {
        function GsTooltip() {
        }
        GsTooltip.prototype.init = function (target, options) {
            this.$target = target;
            this.settings = $.extend({}, $.fn.gsTooltip.defaults, options);
            this.initVars();
            this.configureDialog();
            this.configureTooltip();
        };
        GsTooltip.prototype.initVars = function () {
            this.$dgTrigger = $("<button class='gsp_tt_tgr'></button>");
            this.$dgTooltip = $("<div class='gsp_tt_dlg'><div class='gsp_tt_dlg_title'>" + this.settings.title + "</div><div class='gsp_tt_dlg_bdy'>" + this.settings.content + "</div></div>");
        };
        GsTooltip.prototype.configureDialog = function () {
            var me = this;
            // Configure the tooltip dialog
            this.$dgTooltip.dialog({
                appendTo: '.gsp_ns:first',
                autoOpen: false,
                draggable: false,
                resizable: false,
                closeOnEscape: true,
                classes: { 'ui-dialog': 'gsp_tt_dlg_container' },
                width: Utils.isWidthLessThan(420) ? Utils.getViewportWidth() : 420,
                minHeight: 0,
                show: 'fade',
                hide: 'fade',
                position: { my: 'left top', at: 'left bottom', of: this.$dgTrigger },
                open: function () { me.onTooltipOpen(); }
            });
        };
        GsTooltip.prototype.onTooltipOpen = function () {
            var _this = this;
            $(document).on('click', function (e1) {
                if ($(e1.target).parents('.gsp_tt_dlg_container').length === 0) {
                    _this.$dgTooltip.dialog('close');
                    $(document).unbind(e1);
                }
            });
        };
        GsTooltip.prototype.configureTooltip = function () {
            var _this = this;
            this.$dgTrigger.insertAfter(this.$target)
                .button({
                showLabel: false,
                icon: 'gsp-ui-icon-help' // .gsp-ui-icon { background-position: inherit; font-size: 16px; }
            })
                .click(function (e) {
                if (_this.$dgTooltip.dialog('isOpen'))
                    _this.$dgTooltip.dialog('close');
                else {
                    _this.$dgTooltip.dialog('open');
                }
                return false;
            });
        };
        ;
        return GsTooltip;
    }());
    //#endregion
    //#region equalHeights, equalSize plug-in
    /**
    * equalHeights: Make all elements same height according to tallest one in the collection
    * equalSize: Make all elements same width & height according to widest and tallest one in the collection
    */
    jQuery.fn.equalHeights = function (hBuffer) {
        hBuffer = hBuffer || 0;
        return this.height(hBuffer + Math.max.apply(null, this.map(function () {
            return jQuery(this).height();
        }).get()));
    };
    jQuery.fn.equalWidths = function (wBuffer) {
        wBuffer = wBuffer || 0;
        return this.width(wBuffer + Math.max.apply(null, this.map(function () {
            return jQuery(this).width();
        }).get()));
    };
    jQuery.fn.equalSize = function (wBuffer, hBuffer) {
        wBuffer = wBuffer || 0;
        hBuffer = hBuffer || 0;
        return this.width(wBuffer + Math.max.apply(null, this.map(function () {
            return jQuery(this).width();
        }).get())).height(hBuffer + Math.max.apply(null, this.map(function () {
            return jQuery(this).height();
        }).get()));
    };
    var GsFullScreenSlideShow = /** @class */ (function () {
        function GsFullScreenSlideShow(data, options) {
            var defaults = {
                viewSize: Enums.ViewSize.Optimized,
                on_exit: function () { }
            };
            this.data = data;
            this.settings = $.extend({}, defaults, options);
        }
        GsFullScreenSlideShow.prototype.startSlideShow = function () {
            var _this = this;
            var items = this.data.Album.MediaItems || this.data.Album.GalleryItems;
            var urls = $.map(items, function (mo) {
                if (mo.ItemType === Enums.ItemType.Image)
                    return { id: mo.Id, thumb: Utils.getView(mo, Enums.ViewSize.Thumbnail).Url, title: mo.Title, image: Utils.getView(mo, _this.settings.viewSize).Url };
                else
                    return null;
            });
            if (urls.length === 0) {
                Msg.show(this.data.Resource.MoNoSsHdr, this.data.Resource.MoNoSsBdy, { msgType: 'info' });
                return false;
            }
            ;
            var ssTmpl = '<div class="ssControlsContainer"> \
            <!--Thumbnail Navigation--> \
            <div id="prevthumb"></div> \
            <div id="nextthumb"></div> \
    \
            <!--Arrow Navigation--> \
            <a id="prevslide" class="load-item"></a> \
            <a id="nextslide" class="load-item"></a> \
    \
            <div id="thumb-tray" class="load-item"> \
                <div id="thumb-back"></div> \
                <div id="thumb-forward"></div> \
            </div> \
    \
            <!--Time Bar--> \
            <div id="progress-back" class="load-item"> \
                <div id="progress-bar"></div> \
            </div> \
    \
            <!--Control Bar--> \
            <div id="controls-wrapper" class="load-item"> \
                <div id="controls"> \
    \
                    <a id="play-button"> \
                        <img id="pauseplay" src="{0}/pause.png" /></a> \
    \
                    <a id="stop-button"> \
                        <img src="{0}/stop.png" /></a> \
    \
                    <!--Slide counter--> \
                    <div id="slidecounter"> \
                        <span class="slidenumber"></span> / <span class="totalslides"></span> \
                    </div> \
    \
                    <!--Slide captions displayed here--> \
                    <div id="slidecaption"></div> \
    \
                    <!--Thumb Tray button--> \
                    <a id="tray-button"> \
                        <img id="tray-arrow" src="{0}/button-tray-up.png" /></a> \
    \
                    <!--Navigation--> \
                    <ul id="slide-list"></ul> \
    \
                </div> \
            </div> \
    </div> \
                    '.format(this.data.App.SkinPath + '/images/supersized');
            var getTransition = function (transitionType) {
                switch (transitionType) {
                    case 'fade': return 1;
                    case 'slide': return 3;
                    default: return 0;
                }
            };
            var getStartSlide = function () {
                // Get the current media object and find the index of the matching one in the urls var.
                var startSlide = 1;
                if (_this.data.MediaItem == null)
                    return startSlide;
                $.each(urls, function (idx, ssItem) {
                    if (_this.data.MediaItem.Id === ssItem.id) {
                        startSlide = idx + 1;
                        return false; // false breaks out of $.each
                    }
                    return true;
                });
                return startSlide;
            };
            // Fire up the full screen slide show.
            $.supersized({
                // Functionality
                image_path: this.data.App.SkinPath + '/images/supersized/',
                slideshow: 1,
                autoplay: 1,
                auto_exit: this.data.Settings.SlideShowLoop ? 0 : 1,
                start_slide: getStartSlide(),
                loop: this.data.Settings.SlideShowLoop ? 1 : 0,
                random: 0,
                slide_interval: this.data.Settings.SlideShowIntervalMs,
                transition: getTransition(this.data.Settings.TransitionType),
                transition_speed: 500,
                new_window: 1,
                pause_hover: 0,
                keyboard_nav: 1,
                performance: 1,
                image_protect: 0,
                // Size & Position						   
                min_width: 0,
                min_height: 0,
                vertical_center: 1,
                horizontal_center: 1,
                fit_always: 1,
                fit_portrait: 1,
                fit_landscape: 1,
                // Components							
                slide_links: 'blank',
                thumb_links: 1,
                thumbnail_navigation: 0,
                slides: urls,
                // Theme Options			   
                progress_bar: 0,
                mouse_scrub: 0,
                html_template: ssTmpl,
                on_destroy: function (currentId, autoExit) {
                    _this.settings.on_exit.apply(null, [currentId, autoExit]);
                }
            });
            // Exit slideshow when stop button is clicked.
            $('#stop-button').on('click', function () {
                $.supersized('getApi').destroy();
            });
            return true;
        };
        ;
        return GsFullScreenSlideShow;
    }());
    var GsTimer = /** @class */ (function () {
        function GsTimer(callback, milliseconds, context) {
            this.isRunning = false;
            this.milliseconds = milliseconds;
            this.callback = callback;
            this.context = context;
            if (!this.context)
                this.context = this;
            this.handle = null;
        }
        GsTimer.prototype.start = function () {
            var _this = this;
            if (this.isRunning)
                return;
            var context = this.context;
            var invokeCallback = function () {
                _this.callback.apply(context);
            };
            this.handle = setInterval(invokeCallback, this.milliseconds);
            this.isRunning = true;
        };
        GsTimer.prototype.stop = function () {
            if (!this.isRunning)
                return;
            clearInterval(this.handle);
            this.isRunning = false;
        };
        return GsTimer;
    }());
    Gs.GsTimer = GsTimer;
    var Msg = /** @class */ (function () {
        function Msg() {
        }
        Msg.show = function (title, message, options) {
            var defaults = {
                msgType: 'success',
                autoCloseDelay: 4000,
                width: 500 // The width of the dialog window. 'auto' or a number (e.g. 500) If viewport width is less than this value, the width is set to the viewport width.
            };
            var settings = $.extend({}, defaults, options);
            $('.gsp_msg').remove(); // Remove any previous message that may be visible
            var $dgHtml = $('<div>');
            var cssClass = 'gsp_msg';
            if (message) {
                $dgHtml.append(message);
                cssClass += ' gsp_msgHasContent';
            }
            else {
                cssClass += ' gsp_msgNoContent';
            }
            cssClass += " gsp_msg_" + settings.msgType;
            $dgHtml.dialog({
                appendTo: '.gsp_ns:first',
                position: { my: 'top', at: 'top' },
                title: title,
                width: (typeof settings.width === 'number' && Utils.isWidthLessThan(settings.width)) ? Utils.getViewportWidth() : settings.width,
                height: 'auto',
                resizable: false,
                classes: { 'ui-dialog': cssClass },
                show: 'fade',
                hide: 'fade'
            });
            if (settings.autoCloseDelay > 0) {
                // Auto-close for success messages
                setTimeout(function () {
                    if ($dgHtml.is(':ui-dialog')) {
                        $dgHtml.dialog('destroy');
                    }
                }, settings.autoCloseDelay);
            }
        };
        return Msg;
    }());
    Gs.Msg = Msg;
    /**
    * An object for executing long running tasks on the server and periodically checking its status. The following
    *   assumptions are made: (1) The URL used to invoke the task invokes it on a background thread and returns quickly.
    *   (2) A callback function userDefinedProgressCallback is specified that monitors the returned progress data. This
    *   function is responsible for detecting when the task is complete and subsequently calling resetTask, which cancels the
    *   polling mechanism.
    */
    var ServerTask = /** @class */ (function () {
        function ServerTask(options) {
            var _this = this;
            /**
             * An internal function for invoking the progress URL on the server.
             */
            this.internalProgressCallback = function () {
                // Note the special syntax '= () =>' in the function declaration. It allows the 'this' keyword to work correctly even 
                // though it's being invoked from an ajax callback. See http://stackoverflow.com/questions/14471975/
                $.ajax({
                    url: _this.taskSettings.taskProgressUrl,
                    cache: false,
                    headers: { 'X-ServerTask-TaskId': _this.taskSettings.taskId }
                })
                    .done(function (status) {
                    // Set the timer to call this method again after the specified interval.
                    _this.taskSettings.timerId = window.setTimeout(_this.internalProgressCallback, _this.taskSettings.interval);
                    if (_this.taskSettings.userDefinedProgressCallback != null)
                        _this.taskSettings.userDefinedProgressCallback(status, _this);
                })
                    .fail(function (jqXHR) {
                    Msg.show('Error retrieving status', Utils.parseJqXhrMsg(jqXHR), { msgType: 'error', autoCloseDelay: 0 });
                    if (_this.taskSettings.taskFailedCallback != null)
                        _this.taskSettings.taskFailedCallback(jqXHR, _this);
                });
            };
            var defaults = {
                taskId: this.createTaskId(),
                timerId: 0,
                taskBeginData: null,
                taskBeginUrl: null,
                taskProgressUrl: null,
                taskAbortUrl: null,
                interval: 1000,
                userDefinedProgressCallback: null,
                taskFailedCallback: null,
                taskAbortedCallback: null
            };
            this.taskSettings = $.extend({}, defaults, options);
            //this.self = this;
        }
        /**
         * Internal function to generate a unique task ID.
         * @returns {String} Returns a pseudo-GUID.
         */
        ServerTask.prototype.createTaskId = function () {
            return Utils.createPseudoGuid();
        };
        ;
        /**
         * Send a signal to the server to stop the action. When the polling mechanism detects that the server task has
         * been canceled, it will resets the task (which cancels the timer).
         */
        ServerTask.prototype.abortTask = function () {
            if (this.taskSettings.taskAbortUrl != null && this.taskSettings.taskAbortUrl !== '') {
                $.ajax({
                    url: this.taskSettings.taskAbortUrl,
                    async: false,
                    cache: false,
                    headers: { 'X-ServerTask-TaskId': this.taskSettings.taskId }
                });
            }
        };
        ;
        /**
         * Invoke the long tunning task and begin the periodic polling to check its status.
         */
        ServerTask.prototype.startTask = function () {
            var _this = this;
            $.ajax({
                url: this.taskSettings.taskBeginUrl,
                type: 'POST',
                data: JSON.stringify(this.taskSettings.taskBeginData),
                contentType: 'application/json; charset=utf-8',
                headers: { 'X-ServerTask-TaskId': this.taskSettings.taskId }
            })
                .always(function (jqXHR) {
                if (jqXHR.status !== 0)
                    return;
                if (_this.taskSettings.taskAbortedCallback != null)
                    _this.taskSettings.taskAbortedCallback(self);
                //end();
            })
                .done(function () {
                // Start the progress callback (if any)
                if (_this.taskSettings.userDefinedProgressCallback != null && _this.taskSettings.taskProgressUrl != null) {
                    _this.taskSettings.timerId = window.setTimeout(_this.internalProgressCallback, _this.taskSettings.interval);
                }
            })
                .fail(function (jqXHR) {
                Msg.show('Error starting task', Utils.parseJqXhrMsg(jqXHR), { msgType: 'error', autoCloseDelay: 0 });
                if (_this.taskSettings.taskFailedCallback != null)
                    _this.taskSettings.taskFailedCallback(jqXHR, _this);
            });
        };
        ;
        /**
         * Clears the existing timer function and resets the internal state of the object. Note that
         * this function does not send an abort signal to the server.
         */
        ServerTask.prototype.resetTask = function () {
            this.taskSettings.taskId = '0';
            window.clearTimeout(this.taskSettings.timerId);
        };
        ;
        return ServerTask;
    }());
    Gs.ServerTask = ServerTask;
    //#endregion ServerTask class
})(Gs || (Gs = {}));
/**
 * Remove items from an array. From http://ejohn.org/blog/javascript-array-remove/ Examples of usage:
 * array.remove(1); Remove the second item from the array
 * array.remove(-2); Remove the second-to-last item from the array
 * array.remove(1, 2); Remove the second and third items from the array
 * array.remove(-2, -1); Remove the last and second-to-last items from the array
 * @param {number} from Specifies the index in the array at which to begin removing items. If the 'to' parameter is ommitted, then
 * only the item at this index is removed.
 * @param {number} to Specifies the index in the array at which to stop removing items. All items between 'from' and 'to' are removed.
 * @returns {} Returns the original array with the requested items removed.
 */
Array.prototype.gspRemove = function (from, to) {
    var rest = this.slice((to || from) + 1 || this.length);
    this.length = from < 0 ? this.length + from : from;
    return this.push.apply(this, rest);
};
// Create array method to compare two arrays for equality http://stackoverflow.com/questions/7837456/how-to-compare-arrays-in-javascript
// Warn if overriding existing method
if (Array.prototype.gsEquals)
    console.warn("Overriding existing Array.prototype.equals. Possible causes: New API defines the method, there's a framework conflict or you've got double inclusions in your code.");
// Attach the .gsEquals method to Array's prototype to call it on any array
Array.prototype.gsEquals = function (array) {
    // If the other array is a falsy value, return
    if (!array)
        return false;
    // Compare lengths - can save a lot of time 
    if (this.length !== array.length)
        return false;
    for (var i = 0, l = this.length; i < l; i++) {
        // Check if we have nested arrays
        if (this[i] instanceof Array && array[i] instanceof Array) {
            // recurse into the nested arrays
            if (!this[i].equals(array[i]))
                return false;
        }
        else if (this[i] !== array[i]) {
            // Warning - two different object instances will never be equal: {x:20} != {x:20}
            return false;
        }
    }
    return true;
};
// Hide method from for-in loops
Object.defineProperty(Array.prototype, 'equals', { enumerable: false });
String.prototype.format = function () {
    var params = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        params[_i] = arguments[_i];
    }
    var args = arguments;
    return this.replace(/{(\d+)}/g, function (match, number) { return (typeof args[number] != 'undefined'
        ? args[number]
        : match); });
};
if (!String.prototype.trim) {
    // Add trim() function for browsers that don't implement it (IE 1-8).
    String.prototype.trim = function () {
        return this.replace(/^\s+|\s+$/g, '');
    };
}
//#endregion
//# sourceMappingURL=gallery.js.map